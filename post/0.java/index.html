<!doctype html>
<html lang="en-us">
  <head>
    <title>Java 的核心技术 // Daniel1n</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.69.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Daniel1n" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://daniel1n.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Java 的核心技术"/>
<meta name="twitter:description" content="第一章 Java程序设计概述  1.1 Java “白皮书”的关键术语 1.2 Java applet 与 Internet 1.3 Java发展简史   第二章 Java程序设计环境  2.1 安装Java开发工具包   第三章 Java的基本程序设计结构  3.1 一个简单的Java应用程序 3.2 注释 3.3 数据类型  3.3.1 整数 3.3.2 浮点数 3.3.3 char类型 3.3.4 Unicode 和char类型 3.3.5 boolean类型   3.4 变量  3.4.1 变量初始化 3.4.2 常量   3.5 运算符  3.5.1 数学函数与常量 3.5.2 数值类型之间的转换 3.5.3 强制类型转换 3.5.4 结合赋值和运算符 3.5.5 自增与自减运算符 3.5.6 关系和boolean运算符 3."/>

    <meta property="og:title" content="Java 的核心技术" />
<meta property="og:description" content="第一章 Java程序设计概述  1.1 Java “白皮书”的关键术语 1.2 Java applet 与 Internet 1.3 Java发展简史   第二章 Java程序设计环境  2.1 安装Java开发工具包   第三章 Java的基本程序设计结构  3.1 一个简单的Java应用程序 3.2 注释 3.3 数据类型  3.3.1 整数 3.3.2 浮点数 3.3.3 char类型 3.3.4 Unicode 和char类型 3.3.5 boolean类型   3.4 变量  3.4.1 变量初始化 3.4.2 常量   3.5 运算符  3.5.1 数学函数与常量 3.5.2 数值类型之间的转换 3.5.3 强制类型转换 3.5.4 结合赋值和运算符 3.5.5 自增与自减运算符 3.5.6 关系和boolean运算符 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://daniel1n.github.io/post/0.java/" />
<meta property="article:published_time" content="2020-05-04T22:32:33+08:00" />
<meta property="article:modified_time" content="2020-05-04T22:32:33+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://daniel1n.github.io/"><img class="app-header-avatar" src="/qq1.jpg" alt="Daniel1n" /></a>
      <h1>Daniel1n</h1>
      <p>热爱生活，向往自由，脚踏实地，仰望星空。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/daniel1n" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/daniel1n" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Java 的核心技术</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 4, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          119 min read
        </div></div>
    </header>
    <div class="post-content">
      <!-- raw HTML omitted -->
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0">第一章 Java程序设计概述</a>
<ul>
<li><a href="#11-java-%E7%99%BD%E7%9A%AE%E4%B9%A6%E7%9A%84%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD">1.1 Java “白皮书”的关键术语</a></li>
<li><a href="#12-java-applet-%E4%B8%8E-internet">1.2 Java applet 与 Internet</a></li>
<li><a href="#13-java%E5%8F%91%E5%B1%95%E7%AE%80%E5%8F%B2">1.3 Java发展简史</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83">第二章 Java程序设计环境</a>
<ul>
<li><a href="#21-%E5%AE%89%E8%A3%85java%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E5%8C%85">2.1 安装Java开发工具包</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84">第三章 Java的基本程序设计结构</a>
<ul>
<li><a href="#31-%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84java%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">3.1 一个简单的Java应用程序</a></li>
<li><a href="#32-%E6%B3%A8%E9%87%8A">3.2 注释</a></li>
<li><a href="#33-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">3.3 数据类型</a>
<ul>
<li><a href="#331-%E6%95%B4%E6%95%B0">3.3.1 整数</a></li>
<li><a href="#332-%E6%B5%AE%E7%82%B9%E6%95%B0">3.3.2 浮点数</a></li>
<li><a href="#333-char%E7%B1%BB%E5%9E%8B">3.3.3 char类型</a></li>
<li><a href="#334-unicode-%E5%92%8Cchar%E7%B1%BB%E5%9E%8B">3.3.4 Unicode 和char类型</a></li>
<li><a href="#335-boolean%E7%B1%BB%E5%9E%8B">3.3.5 boolean类型</a></li>
</ul>
</li>
<li><a href="#34-%E5%8F%98%E9%87%8F">3.4 变量</a>
<ul>
<li><a href="#341-%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96">3.4.1 变量初始化</a></li>
<li><a href="#342-%E5%B8%B8%E9%87%8F">3.4.2 常量</a></li>
</ul>
</li>
<li><a href="#35-%E8%BF%90%E7%AE%97%E7%AC%A6">3.5 运算符</a>
<ul>
<li><a href="#351-%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B8%B8%E9%87%8F">3.5.1 数学函数与常量</a></li>
<li><a href="#352-%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2">3.5.2 数值类型之间的转换</a></li>
<li><a href="#353-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">3.5.3 强制类型转换</a></li>
<li><a href="#354-%E7%BB%93%E5%90%88%E8%B5%8B%E5%80%BC%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6">3.5.4 结合赋值和运算符</a></li>
<li><a href="#355-%E8%87%AA%E5%A2%9E%E4%B8%8E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6">3.5.5 自增与自减运算符</a></li>
<li><a href="#356-%E5%85%B3%E7%B3%BB%E5%92%8Cboolean%E8%BF%90%E7%AE%97%E7%AC%A6">3.5.6 关系和boolean运算符</a></li>
<li><a href="#357-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">3.5.7 位运算符</a></li>
<li><a href="#358-%E6%8B%AC%E5%8F%B7%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6%E7%BA%A7%E5%88%AB">3.5.8 括号与运算符级别</a></li>
<li><a href="#359-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B">3.5.9 枚举类型</a></li>
</ul>
</li>
<li><a href="#36-%E5%AD%97%E7%AC%A6%E4%B8%B2">3.6 字符串</a>
<ul>
<li><a href="#361-%E5%AD%90%E4%B8%B2">3.6.1 子串</a></li>
<li><a href="#362-%E6%8B%BC%E6%8E%A5">3.6.2 拼接</a></li>
<li><a href="#363-%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AD%97%E7%AC%A6%E4%B8%B2">3.6.3 不可变字符串</a></li>
<li><a href="#364-%E6%A3%80%E6%B5%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89">3.6.4 检测字符串是否相等</a></li>
<li><a href="#365-%E5%AD%97%E4%B8%B2%E4%B8%8Enull%E4%B8%B2">3.6.5 字串与Null串</a></li>
<li><a href="#366-%E7%A0%81%E7%82%B9%E4%B8%8E%E4%BB%A3%E7%A0%81%E5%8D%95%E5%85%83">3.6.6 码点与代码单元</a></li>
<li><a href="#367-string-api">3.6.7 String API</a></li>
<li><a href="#368-%E9%98%85%E8%AF%BB%E8%81%94%E6%9C%BAapi%E6%96%87%E6%A1%A3">3.6.8 阅读联机API文档</a></li>
<li><a href="#369-%E6%9E%84%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">3.6.9 构建字符串</a></li>
</ul>
</li>
<li><a href="#37-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA">3.7 输入输出</a>
<ul>
<li><a href="#371-%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5">3.7.1 读取输入</a></li>
<li><a href="#372-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA">3.7.2 格式化输出</a></li>
<li><a href="#373-%E6%96%87%E4%BB%B6%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA">3.7.3 文件输入与输出</a></li>
</ul>
</li>
<li><a href="#38-%E6%8E%A7%E5%88%B6%E6%B5%81">3.8 控制流</a>
<ul>
<li><a href="#381-%E5%9D%97%E6%8E%A7%E5%88%B6%E5%9F%9F">3.8.1 块控制域</a></li>
<li><a href="#382-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">3.8.2 条件语句</a></li>
<li><a href="#383-%E5%BE%AA%E7%8E%AF">3.8.3 循环</a></li>
<li><a href="#384-%E7%A1%AE%E5%AE%9A%E5%BE%AA%E7%8E%AF">3.8.4 确定循环</a></li>
<li><a href="#385-%E5%A4%9A%E9%87%8D%E9%80%89%E6%8B%A9switch-%E8%AF%AD%E5%8F%A5">3.8.5 多重选择：switch 语句</a></li>
<li><a href="#386-%E4%B8%AD%E6%96%AD%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%E8%AF%AD%E5%8F%A5">3.8.6 中断控制流程语句</a></li>
</ul>
</li>
<li><a href="#39-%E5%A4%A7%E6%95%B0%E5%80%BC">3.9 大数值</a></li>
<li><a href="#310-%E6%95%B0%E7%BB%84">3.10 数组</a>
<ul>
<li><a href="#3101-for-each-%E5%BE%AA%E7%8E%AF">3.10.1 for each 循环</a></li>
<li><a href="#3102-%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BB%A5%E5%8F%8A%E5%8C%BF%E5%90%8D%E6%95%B0%E7%BB%84">3.10.2 数组初始化以及匿名数组</a></li>
<li><a href="#3103-%E6%95%B0%E7%BB%84%E6%8B%B7%E8%B4%9D">3.10.3 数组拷贝</a></li>
<li><a href="#3104-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0">3.10.4 命令行参数</a></li>
<li><a href="#3105-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">3.10.5 数组排序</a></li>
<li><a href="#3106-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">3.10.6 多维数组</a></li>
<li><a href="#3107-%E4%B8%8D%E8%A7%84%E5%88%99%E6%95%B0%E7%BB%84">3.10.7 不规则数组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB">第四章 对象与类</a>
<ul>
<li><a href="#41-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0">4.1 面向对象程序设计概述</a>
<ul>
<li><a href="#411-%E7%B1%BB">4.1.1 类</a></li>
<li><a href="#412-%E5%AF%B9%E8%B1%A1">4.1.2 对象</a></li>
<li><a href="#413-%E8%AF%86%E5%88%AB%E7%B1%BB">4.1.3 识别类</a></li>
<li><a href="#414-%E7%B1%BB">4.1.4 类</a></li>
</ul>
</li>
<li><a href="#42-%E4%BD%BF%E7%94%A8%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB">4.2 使用预定义类</a>
<ul>
<li><a href="#421-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%8F%98%E9%87%8F">4.2.1 对象与对象变量</a></li>
<li><a href="#422-java%E7%B1%BB%E5%BA%93%E4%B8%AD%E7%9A%84localdate%E7%B1%BB">4.2.2 Java类库中的LocalDate类</a></li>
<li><a href="#423-%E6%9B%B4%E6%94%B9%E5%99%A8%E6%96%B9%E6%B3%95%E4%B8%8E%E8%AE%BF%E9%97%AE%E5%99%A8%E6%96%B9%E6%B3%95">4.2.3 更改器方法与访问器方法</a></li>
</ul>
</li>
<li><a href="#43-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB">4.3 用户自定义类</a>
<ul>
<li><a href="#431-employee%E7%B1%BB">4.3.1 Employee类</a></li>
<li><a href="#432-%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8">4.3.2 多个源文件的使用</a></li>
<li><a href="#433-%E5%89%96%E6%9E%90employee%E7%B1%BB">4.3.3 剖析Employee类</a></li>
<li><a href="#434-%E4%BB%8E%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%80%E5%A7%8B">4.3.4 从构造器开始</a></li>
<li><a href="#435-%E9%9A%90%E5%BC%8F%E5%8F%82%E6%95%B0%E4%B8%8E%E6%98%BE%E5%BC%8F%E5%8F%82%E6%95%B0">4.3.5 隐式参数与显式参数</a></li>
<li><a href="#436-%E5%B0%81%E8%A3%85%E7%9A%84%E4%BC%98%E7%82%B9">4.3.6 封装的优点</a></li>
<li><a href="#437-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90">4.3.7 基于类的访问权限</a></li>
<li><a href="#438-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">4.3.8 私有方法</a></li>
<li><a href="#439-final%E5%AE%9E%E4%BE%8B%E5%9F%9F">4.3.9 final实例域</a></li>
</ul>
</li>
<li><a href="#44-%E9%9D%99%E6%80%81%E5%9F%9F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">4.4 静态域与静态方法</a>
<ul>
<li><a href="#441-%E9%9D%99%E6%80%81%E5%9F%9F">4.4.1 静态域</a></li>
<li><a href="#442-%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F">4.4.2 静态常量</a></li>
<li><a href="#443-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">4.4.3 静态方法</a></li>
<li><a href="#444-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">4.4.4 工厂方法</a></li>
<li><a href="#445-main%E6%96%B9%E6%B3%95">4.4.5 main方法</a></li>
</ul>
</li>
<li><a href="#45-%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0">4.5 方法参数</a></li>
<li><a href="#46-%E5%AF%B9%E8%B1%A1%E6%9E%84%E9%80%A0">4.6 对象构造</a>
<ul>
<li><a href="#461-%E9%87%8D%E8%BD%BD">4.6.1 重载</a></li>
<li><a href="#462-%E9%BB%98%E8%AE%A4%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96">4.6.2 默认域初始化</a></li>
<li><a href="#463-%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8">4.6.3 无参数的构造器</a></li>
<li><a href="#464-%E6%98%BE%E5%BC%8F%E5%9F%9F%E5%88%9D%E5%A7%8B%E5%8C%96">4.6.4 显式域初始化</a></li>
<li><a href="#465-%E5%8F%82%E6%95%B0%E5%90%8D">4.6.5 参数名</a></li>
<li><a href="#466-%E8%B0%83%E7%94%A8%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8">4.6.6 调用另一个构造器</a></li>
<li><a href="#467-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9D%97">4.6.7 初始化块</a></li>
<li><a href="#468-%E5%AF%B9%E8%B1%A1%E6%9E%90%E6%9E%84%E4%B8%8Efinalize%E6%96%B9%E6%B3%95">4.6.8 对象析构与finalize方法</a></li>
</ul>
</li>
<li><a href="#47-%E5%8C%85">4.7 包</a>
<ul>
<li><a href="#471-%E7%B1%BB%E7%9A%84%E5%AF%BC%E5%85%A5">4.7.1 类的导入</a></li>
<li><a href="#472-%E9%9D%99%E6%80%81%E5%AF%BC%E5%85%A5">4.7.2 静态导入</a></li>
<li><a href="#473-%E5%B0%86%E7%B1%BB%E6%94%BE%E5%85%A5%E5%8C%85%E4%B8%AD">4.7.3 将类放入包中</a></li>
<li><a href="#474-%E5%8C%85%E4%BD%9C%E7%94%A8%E5%9F%9F">4.7.4 包作用域</a></li>
</ul>
</li>
<li><a href="#48-%E7%B1%BB%E8%B7%AF%E5%BE%84">4.8 类路径</a>
<ul>
<li><a href="#481-%E8%AE%BE%E7%BD%AE%E7%B1%BB%E8%B7%AF%E5%BE%84">4.8.1 设置类路径</a></li>
</ul>
</li>
<li><a href="#49-%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A">4.9 文档注释</a>
<ul>
<li><a href="#491-%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8F%92%E5%85%A5">4.9.1 注释的插入</a></li>
<li><a href="#492-%E7%B1%BB%E6%B3%A8%E9%87%8A">4.9.2 类注释</a></li>
<li><a href="#493-%E6%96%B9%E6%B3%95%E6%B3%A8%E9%87%8A">4.9.3 方法注释</a></li>
<li><a href="#494-%E5%9F%9F%E6%B3%A8%E9%87%8A">4.9.4 域注释</a></li>
<li><a href="#495-%E9%80%9A%E7%94%A8%E6%B3%A8%E9%87%8A">4.9.5 通用注释</a></li>
<li><a href="#496-%E5%8C%85%E4%B8%8E%E6%A6%82%E8%BF%B0%E6%B3%A8%E9%87%8A">4.9.6 包与概述注释</a></li>
<li><a href="#497-%E6%B3%A8%E9%87%8A%E7%9A%84%E6%8A%BD%E5%8F%96">4.9.7 注释的抽取</a></li>
</ul>
</li>
<li><a href="#410-%E7%B1%BB%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7">4.10 类设计技巧</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF">第五章 继承</a>
<ul>
<li><a href="#51-%E7%B1%BB%E8%B6%85%E7%B1%BB%E5%92%8C%E5%AD%90%E7%B1%BB">5.1 类、超类和子类</a>
<ul>
<li><a href="#511-%E5%AE%9A%E4%B9%89%E5%AD%90%E7%B1%BB">5.1.1 定义子类</a></li>
<li><a href="#512-%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95">5.1.2 覆盖方法</a></li>
<li><a href="#513-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8">5.1.3 子类构造器</a></li>
<li><a href="#514-%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1">5.1.4 继承层次</a></li>
<li><a href="#515-%E5%A4%9A%E6%80%81">5.1.5 多态</a></li>
<li><a href="#516-%E7%90%86%E8%A7%A3%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8">5.1.6 理解方法调用</a></li>
<li><a href="#517-%E9%98%BB%E6%AD%A2%E7%BB%A7%E6%89%BFfinal%E7%B1%BB%E5%92%8C%E6%96%B9%E6%B3%95">5.1.7 阻止继承：final类和方法</a></li>
<li><a href="#518-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">5.1.8 强制类型转换</a></li>
<li><a href="#519-%E6%8A%BD%E8%B1%A1%E7%B1%BB">5.1.9 抽象类</a></li>
<li><a href="#511-%E5%8F%97%E4%BF%9D%E6%8A%A4%E8%AE%BF%E9%97%AE">5.1.1 受保护访问</a></li>
</ul>
</li>
<li><a href="#52-object%E6%89%80%E6%9C%89%E7%B1%BB%E7%9A%84%E8%B6%85%E7%B1%BB">5.2 Object：所有类的超类</a>
<ul>
<li><a href="#521-equals%E6%96%B9%E6%B3%95">5.2.1 equals方法</a></li>
<li><a href="#522-%E7%9B%B8%E7%AD%89%E6%B5%8B%E8%AF%95%E4%B8%8E%E7%BB%A7%E6%89%BF">5.2.2 相等测试与继承</a></li>
<li><a href="#523-hashcode%E6%96%B9%E6%B3%95">5.2.3 hashCode方法</a></li>
<li><a href="#524-tostring%E6%96%B9%E6%B3%95">5.2.4 toString方法</a></li>
</ul>
</li>
<li><a href="#53-%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8">5.3 泛型数组列表</a>
<ul>
<li><a href="#531-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E5%85%83%E7%B4%A0">5.3.1 访问数组列表元素</a></li>
<li><a href="#532-%E7%B1%BB%E5%9E%8B%E5%8C%96%E4%B8%8E%E5%8E%9F%E5%A7%8B%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7">5.3.2 类型化与原始数组列表的兼容性</a></li>
<li><a href="#533-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1">5.3.3 对象包装器与自动装箱</a></li>
<li><a href="#534-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95">5.3.4 参数数量可变的方法</a></li>
</ul>
</li>
<li><a href="#54-%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8%E4%B8%8E%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1">5.4 对象包装器与自动装箱</a></li>
<li><a href="#55-%E5%8F%82%E6%95%B0%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E6%96%B9%E6%B3%95">5.5 参数数量可变的方法</a></li>
<li><a href="#56-%E6%9E%9A%E4%B8%BE%E7%B1%BB">5.6 枚举类</a></li>
<li><a href="#57-%E5%8F%8D%E5%B0%84">5.7 反射</a>
<ul>
<li><a href="#571-class%E7%B1%BB">5.7.1 Class类</a></li>
<li><a href="#572-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">5.7.2 捕获异常</a></li>
<li><a href="#573-%E5%88%A9%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B">5.7.3 利用反射分析类的能力</a></li>
<li><a href="#574-%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E5%88%86%E6%9E%90%E5%AF%B9%E8%B1%A1">5.7.4 在运行时使用反射分析对象</a></li>
<li><a href="#575-%E4%BD%BF%E7%94%A8%E5%8F%8D%E5%B0%84%E7%BC%96%E5%86%99%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84%E4%BB%A3%E7%A0%81">5.7.5 使用反射编写泛型数组代码</a></li>
<li><a href="#576-%E8%B0%83%E7%94%A8%E4%BB%BB%E4%BD%95%E6%96%B9%E6%B3%95">5.7.6 调用任何方法</a></li>
</ul>
</li>
<li><a href="#58-%E7%BB%A7%E6%89%BF%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7">5.8 继承的设计技巧</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC6%E7%AB%A0-%E6%8E%A5%E5%8F%A3lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB">第6章 接口、lambda表达式与内部类</a>
<ul>
<li><a href="#61-%E6%8E%A5%E5%8F%A3">6.1 接口</a>
<ul>
<li><a href="#611-%E6%8E%A5%E5%8F%A3%E6%A6%82%E5%BF%B5">6.1.1 接口概念</a></li>
<li><a href="#612-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%80%A7">6.1.2 接口的特性</a></li>
<li><a href="#613-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB">6.1.3 接口与抽象类</a></li>
<li><a href="#614-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">6.1.4 静态方法</a></li>
<li><a href="#615-%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95">6.1.5 默认方法</a></li>
<li><a href="#616-%E8%A7%A3%E5%86%B3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95%E5%86%B2%E7%AA%81">6.1.6 解决默认方法冲突</a></li>
</ul>
</li>
<li><a href="#62-%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B">6.2 接口示例</a>
<ul>
<li><a href="#621-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%9B%9E%E8%B0%83">6.2.1 接口与回调</a></li>
<li><a href="#622-comparator-%E6%8E%A5%E5%8F%A3">6.2.2 Comparator 接口</a></li>
<li><a href="#623-%E5%AF%B9%E8%B1%A1%E5%85%8B%E9%9A%86">6.2.3 对象克隆</a></li>
</ul>
</li>
<li><a href="#63-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">6.3 lambda表达式</a>
<ul>
<li><a href="#631-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%95%E5%85%A5lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">6.3.1 为什么引入lambda表达式</a></li>
<li><a href="#632-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AF%AD%E6%B3%95">6.3.2 lambda表达式的语法</a></li>
<li><a href="#633-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3">6.3.3 函数式接口</a></li>
<li><a href="#634-%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8">6.3.4 方法引用</a></li>
<li><a href="#635-%E6%9E%84%E9%80%A0%E5%99%A8%E5%BC%95%E7%94%A8">6.3.5 构造器引用</a></li>
<li><a href="#636-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F">6.3.6 变量作用域</a></li>
<li><a href="#637-%E5%A4%84%E7%90%86lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">6.3.7 处理lambda表达式</a></li>
<li><a href="#638-%E5%86%8D%E8%B0%88comparator">6.3.8 再谈Comparator</a></li>
</ul>
</li>
<li><a href="#64-%E5%86%85%E9%83%A8%E7%B1%BB">6.4 内部类</a>
<ul>
<li><a href="#641-%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E7%B1%BB%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81">6.4.1 使用内部类访问对象状态</a></li>
<li><a href="#642-%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95%E8%A7%84%E5%88%99">6.4.2 内部类的特殊语法规则</a></li>
<li><a href="#643-%E5%86%85%E9%83%A8%E7%B1%BB%E6%98%AF%E5%90%A6%E6%9C%89%E7%94%A8%E5%BF%85%E8%A6%81%E5%92%8C%E5%AE%89%E5%85%A8">6.4.3 内部类是否有用、必要和安全</a></li>
<li><a href="#644-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB">6.4.4 局部内部类</a></li>
<li><a href="#645-%E7%94%B1%E5%A4%96%E9%83%A8%E6%96%B9%E6%B3%95%E8%AE%BF%E9%97%AE%E5%8F%98%E9%87%8F">6.4.5 由外部方法访问变量</a></li>
<li><a href="#646-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB">6.4.6 匿名内部类</a></li>
<li><a href="#647-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB">6.4.7 静态内部类</a></li>
</ul>
</li>
<li><a href="#65-%E4%BB%A3%E7%90%86">6.5 代理</a>
<ul>
<li><a href="#651-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86">6.5.1 何时使用代理</a></li>
<li><a href="#652-%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">6.5.2 创建代理对象</a></li>
<li><a href="#653-%E4%BB%A3%E7%90%86%E7%B1%BB%E7%9A%84%E7%89%B9%E6%80%A7">6.5.3 代理类的特性</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC7%E7%AB%A0-%E5%BC%82%E5%B8%B8%E6%96%AD%E8%A8%80%E5%92%8C%E6%97%A5%E5%BF%97">第7章 异常、断言和日志</a>
<ul>
<li><a href="#71-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF">7.1 处理错误</a>
<ul>
<li><a href="#711-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB">7.1.1 异常分类</a></li>
<li><a href="#712-%E5%A3%B0%E6%98%8E%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8">7.1.2 声明受查异常</a></li>
<li><a href="#713-%E5%A6%82%E4%BD%95%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8">7.1.3 如何抛出异常</a></li>
<li><a href="#714-%E5%88%9B%E5%BB%BA%E5%BC%82%E5%B8%B8%E7%B1%BB">7.1.4 创建异常类</a></li>
</ul>
</li>
<li><a href="#72-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">7.2 捕获异常</a>
<ul>
<li><a href="#721-%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8">7.2.1 捕获异常</a></li>
<li><a href="#722-%E6%8D%95%E8%8E%B7%E5%A4%9A%E4%B8%AA%E5%BC%82%E5%B8%B8">7.2.2 捕获多个异常</a></li>
<li><a href="#723-%E5%86%8D%E6%AC%A1%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BC%82%E5%B8%B8%E9%93%BE">7.2.3 再次抛出异常与异常链</a></li>
<li><a href="#724-finally-%E5%AD%90%E5%8F%A5">7.2.4 finally 子句</a></li>
<li><a href="#725-%E5%B8%A6%E8%B5%84%E6%BA%90%E7%9A%84try%E8%AF%AD%E5%8F%A5">7.2.5 带资源的try语句</a></li>
<li><a href="#726-%E5%88%86%E6%9E%90%E5%A0%86%E6%A0%88%E8%BD%A8%E8%BF%B9%E5%85%83%E7%B4%A0">7.2.6 分析堆栈轨迹元素</a></li>
</ul>
</li>
<li><a href="#73-%E4%BD%BF%E7%94%A8%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E7%9A%84%E6%8A%80%E5%B7%A7">7.3 使用异常机制的技巧</a></li>
<li><a href="#74-%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80">7.4 使用断言</a>
<ul>
<li><a href="#741-%E6%96%AD%E8%A8%80%E7%9A%84%E6%A6%82%E5%BF%B5">7.4.1 断言的概念</a></li>
<li><a href="#742-%E5%90%AF%E5%8A%A8%E5%92%8C%E7%A6%81%E7%94%A8%E6%96%AD%E8%A8%80">7.4.2 启动和禁用断言</a></li>
<li><a href="#743-%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80%E5%AE%8C%E6%88%90%E5%8F%82%E6%95%B0%E6%A3%80%E6%9F%A5">7.4.3 使用断言完成参数检查</a></li>
<li><a href="#744-%E4%B8%BA%E6%96%87%E6%A1%A3%E5%81%87%E8%AE%BE%E4%BD%BF%E7%94%A8%E6%96%AD%E8%A8%80">7.4.4 为文档假设使用断言</a></li>
</ul>
</li>
<li><a href="#75-%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97">7.5 记录日志</a>
<ul>
<li><a href="#751-%E5%9F%BA%E6%9C%AC%E6%97%A5%E5%BF%97">7.5.1 基本日志</a></li>
<li><a href="#752-%E9%AB%98%E7%BA%A7%E6%97%A5%E5%BF%97">7.5.2 高级日志</a></li>
<li><a href="#753-%E4%BF%AE%E6%94%B9%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE">7.5.3 修改日志管理器配置</a></li>
<li><a href="#754-%E6%9C%AC%E5%9C%B0%E5%8C%96">7.5.4 本地化</a></li>
<li><a href="#755-%E5%A4%84%E7%90%86%E5%99%A8">7.5.5 处理器</a></li>
<li><a href="#756-%E8%BF%87%E6%BB%A4%E5%99%A8">7.5.6 过滤器</a></li>
<li><a href="#757-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%99%A8">7.5.7 格式化器</a></li>
<li><a href="#758-%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E8%AF%B4%E6%98%8E">7.5.8 日志记录说明</a></li>
</ul>
</li>
<li><a href="#76-%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7">7.6 调试技巧</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC8%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">第8章 泛型程序设计</a>
<ul>
<li><a href="#81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">8.1 为什么要使用泛型程序设计</a>
<ul>
<li><a href="#811-%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E7%9A%84%E5%A5%BD%E5%A4%84">8.1.1 类型参数的好处</a></li>
<li><a href="#812-%E8%B0%81%E6%83%B3%E6%88%90%E4%B8%BA%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E5%91%98">8.1.2 谁想成为泛型程序员</a></li>
</ul>
</li>
<li><a href="#82-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B%E7%B1%BB">8.2 定义简单泛型类</a></li>
<li><a href="#83-%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">8.3 泛型方法</a></li>
<li><a href="#84-%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E9%99%90%E5%AE%9A">8.4 类型变量的限定</a></li>
<li><a href="#85-%E6%B3%9B%E5%9E%8B%E4%BB%A3%E7%A0%81%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA">8.5 泛型代码和虚拟机</a>
<ul>
<li><a href="#851-%E7%B1%BB%E5%9E%8B%E6%93%A6%E9%99%A4">8.5.1 类型擦除</a></li>
<li><a href="#852-%E7%BF%BB%E8%AF%91%E6%B3%9B%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F">8.5.2 翻译泛型表达式</a></li>
<li><a href="#853-%E7%BF%BB%E8%AF%91%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95">8.5.3 翻译泛型方法</a></li>
<li><a href="#854-%E8%B0%83%E7%94%A8%E9%81%97%E7%95%99%E4%BB%A3%E7%A0%81">8.5.4 调用遗留代码</a></li>
</ul>
</li>
<li><a href="#86-%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%B1%80%E9%99%90%E6%80%A7">8.6 约束与局限性</a>
<ul>
<li><a href="#861-%E4%B8%8D%E8%83%BD%E7%94%A8%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">8.6.1 不能用基本类型实例化类型参数</a></li>
<li><a href="#862-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E6%9F%A5%E8%AF%A2%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B">8.6.2 运行时类型查询只适用于原始类型</a></li>
<li><a href="#863-%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E5%8F%82%E6%95%B0%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E7%BB%84">8.6.3 不能创建参数化类型的数组</a></li>
<li><a href="#864-varargs%E8%AD%A6%E5%91%8A">8.6.4 Varargs警告</a></li>
<li><a href="#865-%E4%B8%8D%E8%83%BD%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F">8.6.5 不能实例化类型变量</a></li>
<li><a href="#866-%E4%B8%8D%E8%83%BD%E6%9E%84%E9%80%A0%E6%B3%9B%E5%9E%8B%E6%95%B0%E7%BB%84">8.6.6 不能构造泛型数组</a></li>
<li><a href="#867-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B8%AD%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E6%97%A0%E6%95%88">8.6.7 泛型类的静态上下文中类型变量无效</a></li>
<li><a href="#868-%E4%B8%8D%E8%83%BD%E6%8A%9B%E5%87%BA%E6%88%96%E6%8D%95%E8%8E%B7%E6%B3%9B%E5%9E%8B%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">8.6.8 不能抛出或捕获泛型类的实例</a></li>
<li><a href="#869-%E5%8F%AF%E4%BB%A5%E6%B6%88%E9%99%A4%E5%AF%B9%E5%8F%97%E6%9F%A5%E5%BC%82%E5%B8%B8%E7%9A%84%E6%A3%80%E6%9F%A5">8.6.9 可以消除对受查异常的检查</a></li>
<li><a href="#8610-%E6%B3%A8%E6%84%8F%E6%93%A6%E9%99%A4%E5%90%8E%E7%9A%84%E5%86%B2%E7%AA%81">8.6.10 注意擦除后的冲突</a></li>
</ul>
</li>
<li><a href="#87-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BB%A7%E6%89%BF%E8%A7%84%E5%88%99">8.7 泛型类型的继承规则</a></li>
<li><a href="#88-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%B1%BB%E5%9E%8B">8.8 通配符类型</a></li>
<li><a href="#89-%E5%8F%8D%E5%B0%84%E5%92%8C%E6%B3%9B%E5%9E%8B">8.9 反射和泛型</a>
<ul>
<li><a href="#891-%E6%B3%9B%E5%9E%8Bclass%E7%B1%BB">8.9.1 泛型Class类</a></li>
<li><a href="#892-%E4%BD%BF%E7%94%A8classt%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D">8.9.2 使用Class<!-- raw HTML omitted -->参数进行类型匹配</a></li>
<li><a href="#893-%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF">8.9.3 虚拟机中的泛型类型信息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC9%E7%AB%A0-%E9%9B%86%E5%90%88">第9章 集合</a>
<ul>
<li><a href="#91-java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6">9.1 Java集合框架</a>
<ul>
<li><a href="#911-%E5%B0%86%E9%9B%86%E5%90%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%88%86%E7%A6%BB">9.1.1 将集合的接口与实现分离</a></li>
<li><a href="#912-collection%E6%8E%A5%E5%8F%A3">9.1.2 Collection接口</a></li>
<li><a href="#913-%E8%BF%AD%E4%BB%A3%E5%99%A8">9.1.3 迭代器</a></li>
<li><a href="#914-%E6%B3%9B%E5%9E%8B%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95">9.1.4 泛型实用方法</a></li>
<li><a href="#915-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3">9.1.5 集合框架中的接口</a></li>
</ul>
</li>
<li><a href="#92-%E5%85%B7%E4%BD%93%E7%9A%84%E9%9B%86%E5%90%88">9.2 具体的集合</a>
<ul>
<li><a href="#921-%E9%93%BE%E8%A1%A8">9.2.1 链表</a></li>
<li><a href="#922-%E6%95%B0%E7%BB%84%E5%88%97%E8%A1%A8">9.2.2 数组列表</a></li>
<li><a href="#923-%E6%95%A3%E8%A3%85%E9%9B%86">9.2.3 散装集</a></li>
<li><a href="#924-%E6%A0%91%E9%9B%86">9.2.4 树集</a></li>
<li><a href="#925-%E9%98%9F%E5%88%97%E4%B8%8E%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">9.2.5 队列与双端队列</a></li>
<li><a href="#926-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97">9.2.6 优先级队列</a></li>
</ul>
</li>
<li><a href="#93-%E6%98%A0%E5%B0%84">9.3 映射</a>
<ul>
<li><a href="#931-%E5%9F%BA%E6%9C%AC%E6%98%A0%E5%B0%84%E6%93%8D%E4%BD%9C">9.3.1 基本映射操作</a></li>
<li><a href="#932-%E6%9B%B4%E6%96%B0%E6%98%A0%E5%B0%84%E9%A1%B9">9.3.2 更新映射项</a></li>
<li><a href="#933-%E6%98%A0%E5%B0%84%E8%A7%86%E5%9B%BE">9.3.3 映射视图</a></li>
<li><a href="#934-%E5%BC%B1%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84-weakhashmap">9.3.4 弱散列映射 WeakHashMap</a></li>
<li><a href="#935-%E9%93%BE%E6%8E%A5%E6%95%A3%E5%88%97%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84-linkedhashset%E5%92%8Clinkedhashmap">9.3.5 链接散列集与映射 LinkedHashSet和LinkedHashMap</a></li>
<li><a href="#936-%E6%9E%9A%E4%B8%BE%E9%9B%86%E4%B8%8E%E6%98%A0%E5%B0%84">9.3.6 枚举集与映射</a></li>
<li><a href="#937-%E6%A0%87%E8%AF%86%E6%95%A3%E5%88%97%E6%98%A0%E5%B0%84">9.3.7 标识散列映射</a></li>
</ul>
</li>
<li><a href="#94-%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%8C%85%E8%A3%85%E5%99%A8">9.4 视图与包装器</a></li>
<li><a href="#95-%E7%AE%97%E6%B3%95">9.5 算法</a></li>
<li><a href="#96-%E9%81%97%E7%95%99%E7%9A%84%E9%9B%86%E5%90%88">9.6 遗留的集合</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC10%E7%AB%A0-%E6%B3%A8%E8%A7%A3">第10章 注解</a>
<ul>
<li><a href="#101-%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3">10.1 使用注解</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#102-%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3">10.2 定义注解</a>
<ul>
<li><a href="#%E5%85%83%E6%B3%A8%E8%A7%A3">元注解</a></li>
<li><a href="#target">@Target</a></li>
<li><a href="#retention">@Retention</a></li>
<li><a href="#repeatable">@Repeatable</a></li>
<li><a href="#inherited">@Inherited</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89annotation">如何定义Annotation</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-1">小结</a></li>
</ul>
</li>
<li><a href="#103-%E5%A4%84%E7%90%86%E6%B3%A8%E8%A7%A3">10.3 处理注解</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3">使用注解</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-2">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC11%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B">第11章 多线程</a>
<ul>
<li><a href="#111--%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80">11.1  多线程基础</a>
<ul>
<li><a href="#%E8%BF%9B%E7%A8%8B">进程</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6">线程调度：</a></li>
<li><a href="#%E8%BF%9B%E7%A8%8B-vs-%E7%BA%BF%E7%A8%8B">进程 vs 线程</a></li>
<li><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B">多线程</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0">设置和获取线程名称：</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E6%89%93%E5%8D%B0%E8%AF%AD%E5%8F%A5%E5%92%8C%E7%9B%B4%E6%8E%A5%E5%9C%A8main%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97">使用线程执行的打印语句，和直接在main()方法执行有区别吗？</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7">线程的优先级</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-3">小结</a></li>
</ul>
</li>
<li><a href="#113-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81">11.3 线程的状态</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-4">小结</a></li>
</ul>
</li>
<li><a href="#114-%E4%B8%AD%E6%96%AD%E7%BA%BF%E7%A8%8B">11.4 中断线程</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-5">小结</a></li>
</ul>
</li>
<li><a href="#115-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B">11.5 守护线程</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-6">小结</a></li>
</ul>
</li>
<li><a href="#116-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">11.6 线程同步</a>
<ul>
<li><a href="#%E4%B8%8D%E9%9C%80%E8%A6%81synchronized%E7%9A%84%E6%93%8D%E4%BD%9C">不需要synchronized的操作</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-7">小结</a></li>
</ul>
</li>
<li><a href="#117-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95">11.7 同步方法</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-8">小结</a></li>
</ul>
</li>
<li><a href="#118-%E6%AD%BB%E9%94%81">11.8 死锁</a>
<ul>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-9">小结</a></li>
</ul>
</li>
<li><a href="#119-%E4%BD%BF%E7%94%A8wait%E5%92%8Cnotify">11.9 使用wait和notify</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-10">小结</a></li>
</ul>
</li>
<li><a href="#1110-%E4%BD%BF%E7%94%A8reentrantlock">11.10 使用ReentrantLock</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-11">小结</a></li>
</ul>
</li>
<li><a href="#1111-%E4%BD%BF%E7%94%A8condition">11.11 使用Condition</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-12">小结</a></li>
</ul>
</li>
<li><a href="#1112-%E4%BD%BF%E7%94%A8readwritelock">11.12 使用ReadWriteLock</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-13">小结</a></li>
</ul>
</li>
<li><a href="#1112-%E4%BD%BF%E7%94%A8stampedlock">11.12 使用StampedLock</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-14">小结</a></li>
</ul>
</li>
<li><a href="#1113-%E4%BD%BF%E7%94%A8concurrent%E9%9B%86%E5%90%88">11.13 使用Concurrent集合</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-15">小结</a></li>
</ul>
</li>
<li><a href="#1114-%E4%BD%BF%E7%94%A8atomic">11.14 使用Atomic</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-16">小结</a></li>
</ul>
</li>
<li><a href="#1115-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">11.15 使用线程池</a>
<ul>
<li><a href="#scheduledthreadpool">ScheduledThreadPool</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-17">小结</a></li>
</ul>
</li>
<li><a href="#1116-%E4%BD%BF%E7%94%A8future">11.16 使用Future</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-18">小结</a></li>
</ul>
</li>
<li><a href="#1117-%E4%BD%BF%E7%94%A8completablefuture">11.17 使用CompletableFuture</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-19">小结</a></li>
</ul>
</li>
<li><a href="#1118-%E4%BD%BF%E7%94%A8forkjoin">11.18 使用ForkJoin</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-20">小结</a></li>
</ul>
</li>
<li><a href="#1119-%E4%BD%BF%E7%94%A8threadlocal">11.19 使用ThreadLocal</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-21">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC12%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">第12章 网络编程</a>
<ul>
<li><a href="#121-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80">12.1 网络编程基础</a>
<ul>
<li><a href="#ip%E5%9C%B0%E5%9D%80">IP地址</a></li>
<li><a href="#%E5%9F%9F%E5%90%8D">域名</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B">网络模型</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E5%8D%8F%E8%AE%AE">常用协议</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-22">小结</a></li>
</ul>
</li>
<li><a href="#122-tcp%E7%BC%96%E7%A8%8B">12.2 TCP编程</a>
<ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF">服务器端</a></li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF">客户端</a></li>
<li><a href="#socket%E6%B5%81">Socket流</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-23">小结</a></li>
</ul>
</li>
<li><a href="#123-udo%E7%BC%96%E7%A8%8B">12.3 UDO编程</a>
<ul>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF-1">服务器端</a></li>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF-1">客户端</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-24">小结</a></li>
</ul>
</li>
<li><a href="#124-%E5%8F%91%E9%80%81email">12.4 发送Email</a>
<ul>
<li><a href="#%E5%87%86%E5%A4%87smtp%E7%99%BB%E5%BD%95%E4%BF%A1%E6%81%AF">准备SMTP登录信息</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6">发送邮件</a></li>
<li><a href="#%E5%8F%91%E9%80%81html%E9%82%AE%E4%BB%B6">发送HTML邮件</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E9%99%84%E4%BB%B6">发送附件</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E5%86%85%E5%B5%8C%E5%9B%BE%E7%89%87%E7%9A%84html%E9%82%AE%E4%BB%B6">发送内嵌图片的HTML邮件</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-25">小结</a></li>
</ul>
</li>
<li><a href="#125-%E6%8E%A5%E5%8F%97email">12.5 接受Email</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-26">小结</a></li>
</ul>
</li>
<li><a href="#126-http%E7%BC%96%E7%A8%8B">12.6 HTTP编程</a>
<ul>
<li><a href="#http%E7%BC%96%E7%A8%8B">HTTP编程</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-27">小结</a></li>
</ul>
</li>
<li><a href="#127-rmi%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8">12.7 RMI远程调用</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-28">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC13%E7%AB%A0-io">第13章 IO</a>
<ul>
<li><a href="#131-file">13.1 File</a>
<ul>
<li><a href="#1311-file%E7%B1%BB%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">13.1.1 File类的概述和构造方法</a></li>
<li><a href="#1312-file%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD">13.1.2 File类创建功能</a></li>
<li><a href="#1313-file%E7%B1%BB%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD">13.1.3 File类判断和获取功能</a></li>
<li><a href="#1314-file%E7%B1%BB%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD">13.1.4 File类删除功能</a></li>
<li><a href="#1315-%E9%80%92%E5%BD%92">13.1.5 递归</a></li>
</ul>
</li>
<li><a href="#132-%E5%AD%97%E8%8A%82%E6%B5%81">13.2 字节流</a>
<ul>
<li><a href="#1321-io%E6%B5%81%E6%A6%82%E8%BF%B0%E5%92%8C%E5%88%86%E7%B1%BB">13.2.1 IO流概述和分类</a></li>
<li><a href="#1322-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE">13.2.2 字节流写数据</a></li>
<li><a href="#1323-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F">13.2.3 字节流写数据的3种方式</a></li>
<li><a href="#1324-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98">13.2.4 字节流写数据的两个小问题</a></li>
<li><a href="#1325-%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">13.2.5 字节流写数据加异常处理</a></li>
<li><a href="#1326-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE">13.2.6 字节流读数据</a>
<ul>
<li><a href="#13261-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E4%B8%80%E6%AC%A1%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE">13.2.6.1 字节流读数据（一次读一个字节数据）</a></li>
<li><a href="#13262-%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E4%B8%80%E6%AC%A1%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE">13.2.6.2 字节流读数据（一次读一个字节数组数据）</a></li>
</ul>
</li>
<li><a href="#1327-%E5%AD%97%E8%8A%82%E6%B5%81%E7%BC%93%E5%86%B2%E6%B5%81">13.2.7 字节流缓冲流</a></li>
</ul>
</li>
<li><a href="#133-%E5%AD%97%E7%AC%A6%E6%B5%81">13.3 字符流</a>
<ul>
<li><a href="#1331-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%AD%97%E7%AC%A6%E6%B5%81">13.3.1 为什么会出现字符流</a></li>
<li><a href="#1332-%E7%BC%96%E7%A0%81%E8%A1%A8">13.3.2 编码表</a></li>
<li><a href="#1333-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98">13.3.3 字符串中的编码解码问题</a></li>
<li><a href="#1334-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%9A%84%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98">13.3.4 字符流中的编码解码问题</a></li>
<li><a href="#1335-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F">13.3.5 字符流写数据的5种方式</a></li>
<li><a href="#1336-%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F">13.3.6 字符流读数据的2种方式</a></li>
<li><a href="#1337-%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81">13.3.7 字节缓冲流</a></li>
<li><a href="#1338-%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD">13.3.8 字符缓冲流特有功能</a></li>
<li><a href="#1339-io%E6%B5%81%E5%B0%8F%E7%BB%93">13.3.9 IO流小结</a></li>
</ul>
</li>
<li><a href="#134-%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81">13.4 特殊操作流</a>
<ul>
<li><a href="#1341-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81">13.4.1 标准输入输出流</a></li>
<li><a href="#1342-%E6%89%93%E5%8D%B0%E6%B5%81">13.4.2 打印流</a></li>
<li><a href="#1343-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81">13.4.3 对象序列化流</a></li>
<li><a href="#%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98">序列化中存在的问题</a></li>
<li><a href="#1344-properties">13.4.4 Properties</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC14%E7%AB%A0-jdbc%E7%BC%96%E7%A8%8B">第14章 JDBC编程</a>
<ul>
<li><a href="#141-jdbc%E7%AE%80%E4%BB%8B">14.1 JDBC简介</a>
<ul>
<li><a href="#nosql">NoSQL</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B1%BB%E5%88%AB">数据库类别</a></li>
<li><a href="#%E5%AE%89%E8%A3%85mysql">安装MySQL</a></li>
<li><a href="#jdbc">JDBC</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-29">小结</a></li>
</ul>
</li>
<li><a href="#142-jdbc%E6%9F%A5%E8%AF%A2">14.2 JDBC查询</a>
<ul>
<li><a href="#jdbc%E8%BF%9E%E6%8E%A5">JDBC连接</a></li>
<li><a href="#jdbc%E6%9F%A5%E8%AF%A2">JDBC查询</a></li>
<li><a href="#sql%E6%B3%A8%E5%85%A5">SQL注入</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-30">小结</a></li>
</ul>
</li>
<li><a href="#143-jdbc%E6%9B%B4%E6%96%B0">14.3 JDBC更新</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5">插入</a></li>
<li><a href="#%E6%8F%92%E5%85%A5%E5%B9%B6%E8%8E%B7%E5%8F%96%E4%B8%BB%E9%94%AE">插入并获取主键</a></li>
<li><a href="#%E6%9B%B4%E6%96%B0">更新</a></li>
<li><a href="#%E5%88%A0%E9%99%A4">删除</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-31">小结</a></li>
</ul>
</li>
<li><a href="#144-jdbc%E4%BA%8B%E5%8A%A1">14.4 JDBC事务</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-32">小结</a></li>
</ul>
</li>
<li><a href="#145-jdbc-batch">14.5 JDBC Batch</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-33">小结</a></li>
</ul>
</li>
<li><a href="#146-jdbc%E8%BF%9E%E6%8E%A5%E6%B1%A0">14.6 JDBC连接池</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-34">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC15%E7%AB%A0-xml%E4%B8%8Ejson">第15章 XML与JSON</a>
<ul>
<li><a href="#151-xml%E7%AE%80%E4%BB%8B">15.1 XML简介</a>
<ul>
<li><a href="#xml%E7%9A%84%E7%BB%93%E6%9E%84">XML的结构</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-35">小结</a></li>
</ul>
</li>
<li><a href="#152-%E4%BD%BF%E7%94%A8dom">15.2 使用DOM</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-36">小结</a></li>
</ul>
</li>
<li><a href="#153-%E4%BD%BF%E7%94%A8sax">15.3 使用SAX</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-37">小结</a></li>
</ul>
</li>
<li><a href="#154-%E4%BD%BF%E7%94%A8jackson">15.4 使用Jackson</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-38">小结</a></li>
</ul>
</li>
<li><a href="#155-%E4%BD%BF%E7%94%A8json">15.5 使用JSON</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-39">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC16%E7%AB%A0-maven%E5%9F%BA%E7%A1%80">第16章 Maven基础</a>
<ul>
<li><a href="#161-maven%E4%BB%8B%E7%BB%8D">16.1 Maven介绍</a>
<ul>
<li><a href="#maven%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84">Maven项目结构</a></li>
<li><a href="#%E5%AE%89%E8%A3%85maven">安装Maven</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-40">小结</a></li>
</ul>
</li>
<li><a href="#162-%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">16.2 依赖管理</a>
<ul>
<li><a href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB">依赖关系</a></li>
<li><a href="#%E5%94%AF%E4%B8%80id">唯一ID</a></li>
<li><a href="#maven%E9%95%9C%E5%83%8F">Maven镜像</a></li>
<li><a href="#%E6%90%9C%E7%B4%A2%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BB%84%E4%BB%B6">搜索第三方组件</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-41">小结</a></li>
</ul>
</li>
<li><a href="#163-%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B">16.3 构建流程</a>
<ul>
<li><a href="#lifecycle%E5%92%8Cphase">Lifecycle和Phase</a></li>
<li><a href="#goal">Goal</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-42">小结</a></li>
</ul>
</li>
<li><a href="#164-%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6">16.4 使用插件</a>
<ul>
<li><a href="#%E5%B0%8F%E7%BB%93-43">小结</a></li>
</ul>
</li>
<li><a href="#165-%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86">16.5 模块管理</a>
<ul>
<li><a href="#%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93">中央仓库</a></li>
<li><a href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93">私有仓库</a></li>
<li><a href="#%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93">本地仓库</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-44">小结</a></li>
</ul>
</li>
<li><a href="#166-%E4%BD%BF%E7%94%A8mvnw">16.6 使用mvnw</a>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85maven-wrapper">安装Maven Wrapper</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-45">小结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC17%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">第17章 设计模式</a>
<ul>
<li><a href="#171-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">17.1 创建型模式</a>
<ul>
<li><a href="#1711-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">17.1.1 工厂方法</a></li>
<li><a href="#1712-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82">17.1.2 抽象工厂</a></li>
<li><a href="#1713-%E7%94%9F%E6%88%90%E5%99%A8">17.1.3 生成器</a></li>
<li><a href="#1714-%E5%8E%9F%E5%9E%8B">17.1.4 原型</a></li>
<li><a href="#1715-%E5%8D%95%E4%BE%8B">17.1.5 单例</a></li>
</ul>
</li>
<li><a href="#172-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F">17.2 结构型模式</a></li>
<li><a href="#173-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">17.3 行为型模式</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="第一章-java程序设计概述">第一章 Java程序设计概述</h1>
<hr>
<h2 id="11-java-白皮书的关键术语">1.1 Java “白皮书”的关键术语</h2>
<ul>
<li>简答性</li>
<li>面向对象</li>
<li>分布式</li>
<li>健壮性</li>
<li>安全性</li>
<li>体系结构中立</li>
<li>可移植性</li>
<li>解释性</li>
<li>高性能</li>
<li>多线程</li>
<li>动态性</li>
</ul>
<hr>
<h2 id="12-java-applet-与-internet">1.2 Java applet 与 Internet</h2>
<ul>
<li>用户从Internet下载Java字节码，并在自己的机器上运行。在网页中运行的Java程序称为applet。要使用applet，需要启动Java的Web浏览器执行字节码。不需要安装任何软件。</li>
</ul>
<hr>
<h2 id="13-java发展简史">1.3 Java发展简史</h2>
<ul>
<li>1991年，由Patrick Naughton和James Gosling带领的Sun（Stanford University Network）公司研发</li>
<li>1996年，java的第一个版本</li>
<li>1998年，java 1.2版本</li>
<li>2014年，java 1.8版本，提供了lambda表达式，“函数式”编程</li>
</ul>
<hr>
<h1 id="第二章-java程序设计环境">第二章 Java程序设计环境</h1>
<h2 id="21-安装java开发工具包">2.1 安装Java开发工具包</h2>
<ul>
<li>由于官网下载实在太慢，我们使用华为的镜像文件
<!-- raw HTML omitted --> <a href="https://repo.huaweicloud.com/java/jdk/">https://repo.huaweicloud.com/java/jdk/</a></li>
<li>JVM的兼容性做得非常好，低版本的Java字节码完全可以正常运行在高版本的JVM上。</li>
<li>随着Java的发展，SUN给Java又分出了三个不同版本：</li>
<li>Java SE：Standard Edition</li>
<li>Java EE：Enterprise Edition</li>
<li>Java ME：Micro Edition</li>
<li>这三者之间有啥关系呢？</li>
</ul>
<pre><code> ┌───────────────────────────┐
 │Java EE                    │
 │    ┌────────────────────┐ │
 │    │Java SE             │ │
 │    │    ┌─────────────┐ │ │
 │    │    │   Java ME   │ │ │
 │    │    └─────────────┘ │ │
 │    └────────────────────┘ │
 └───────────────────────────┘
</code></pre><ul>
<li>简单来说，Java SE就是标准版，包含标准的JVM和标准库，而Java EE是企业版，它只是在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等，Java EE的应用使用的虚拟机和Java SE完全相同。</li>
<li>Java ME就和Java SE不同，它是一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用，Java ME的虚拟机也是“瘦身版”。</li>
<li>毫无疑问，Java SE是整个Java平台的核心，而Java EE是进一步学习Web应用所必须的。我们熟悉的Spring等框架都是Java EE开源生态系统的一部分。不幸的是，Java ME从来没有真正流行起来，反而是Android开发成为了移动平台的标准之一，因此，没有特殊需求，不建议学习Java ME。</li>
<li>因此我们推荐的Java学习路线图如下：
首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用；
如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的；
如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发；
如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。
无论怎么选择，Java SE的核心技术是基础，这个教程的目的就是让你完全精通Java SE！</li>
<li>名词解释</li>
<li>初学者学Java，经常听到JDK、JRE这些名词，它们到底是啥？</li>
<li>JDK：Java Development Kit</li>
<li>JRE：Java Runtime Environment</li>
<li>简单地说，JRE就是运行Java字节码的虚拟机。但是，如果只有Java源码，要编译成Java字节码，就需要JDK，因为JDK除了包含JRE，还提供了编译器、调试器等开发工具。
二者关系如下：</li>
</ul>
<pre><code>  ┌─    ┌──────────────────────────────────┐
  │     │     Compiler, debugger, etc.     |
  │     └──────────────────────────────────┘
 JDK ┌─ ┌──────────────────────────────────┐
  │  │  │                                  |
  │ JRE │      JVM + Runtime Library       | 
  │  │  │                                  | 
  └─ └─ └──────────────────────────────────┘
        ┌───────┐┌───────┐┌───────┐┌───────┐
        │Windows││ Linux ││ macOS ││others │
        └───────┘└───────┘└───────┘└───────┘
</code></pre><ul>
<li>要学习Java开发，当然需要安装JDK了。
那JSR、JCP……又是啥？</li>
<li>JSR规范：Java Specification Request</li>
<li>JCP组织：Java Community Process</li>
<li>为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。</li>
<li>所以JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。</li>
</ul>
<hr>
<h1 id="第三章-java的基本程序设计结构">第三章 Java的基本程序设计结构</h1>
<h2 id="31-一个简单的java应用程序">3.1 一个简单的Java应用程序</h2>
<pre><code>public class FirstSample {
    public static void main(String[] args) {
        System.out.println(&quot;We will not use 'Hello , World!&quot;);
    }
}
</code></pre><ul>
<li>Java区分大小写</li>
<li>关键字public称为访问修饰符</li>
<li>关键字class后面紧跟类名</li>
</ul>
<hr>
<h2 id="32-注释">3.2 注释</h2>
<ul>
<li>常用的： //</li>
<li>然后是： /* 和 */括起来</li>
<li>最后是：</li>
</ul>
<pre><code>/**
 * This is the first sample program in Core Java Chapter3
 * @version 1.01 1997-03-22
 * @author qq_lin
 */
</code></pre><hr>
<h2 id="33-数据类型">3.3 数据类型</h2>
<h3 id="331-整数">3.3.1 整数</h3>
<ul>
<li>int 4字节码</li>
<li>short 2字节码</li>
<li>long 8字节码</li>
<li>byte 1字节码</li>
</ul>
<h3 id="332-浮点数">3.3.2 浮点数</h3>
<ul>
<li>float 4字节码</li>
<li>double 8字节码</li>
</ul>
<h3 id="333-char类型">3.3.3 char类型</h3>
<ul>
<li>用于表示单个字符，如单个中文字 ‘它’</li>
</ul>
<h3 id="334-unicode-和char类型">3.3.4 Unicode 和char类型</h3>
<h3 id="335-boolean类型">3.3.5 boolean类型</h3>
<ul>
<li>Boolean（布尔）类型由两个值：false和true</li>
</ul>
<hr>
<h2 id="34-变量">3.4 变量</h2>
<h3 id="341-变量初始化">3.4.1 变量初始化</h3>
<ul>
<li>每个变量都有一个类型（type），声明变量时，变量的类型位于变量名之前；</li>
</ul>
<h3 id="342-常量">3.4.2 常量</h3>
<ul>
<li>在Java中，利用关键字final</li>
</ul>
<pre><code>public class Constants {
    public static void main(String[] args) {
        final double CM_PER_INCH = 2.54；
        double paperWidth = 8.5;
        double paperHeight = 11;
        System.out.println(&quot;Paper size in centimeters: &quot;
        + paperWidth * CM_PER_INCH +&quot; by &quot; + paperHeight * CM_PER_INCH);
    }
}
</code></pre><ul>
<li>关键字final表示这个变量只能被赋值一次。常量名一般使用全大写</li>
</ul>
<hr>
<h2 id="35-运算符">3.5 运算符</h2>
<ul>
<li>使用算术运算符 + - * / %</li>
</ul>
<h3 id="351-数学函数与常量">3.5.1 数学函数与常量</h3>
<h3 id="352-数值类型之间的转换">3.5.2 数值类型之间的转换</h3>
<h3 id="353-强制类型转换">3.5.3 强制类型转换</h3>
<h3 id="354-结合赋值和运算符">3.5.4 结合赋值和运算符</h3>
<h3 id="355-自增与自减运算符">3.5.5 自增与自减运算符</h3>
<h3 id="356-关系和boolean运算符">3.5.6 关系和boolean运算符</h3>
<ul>
<li>逻辑与和逻辑或：</li>
<li>逻辑与&amp;&amp; 第一个为false时，第二个不需要计算；</li>
<li>逻辑或|| 第一个为 ture时，第二个不需要计算；</li>
<li>三目操作符</li>
<li>：condition ？ expression1 ：expression2</li>
</ul>
<pre><code>public class HelloWorld {
    public static void main(String[] args) {
 
        int i = 5;
        int j = 6;
 
        int k = i &lt; j ? 99 : 88;
 
        // 相当于
        if (i &lt; j) {
            k = 99;
        } else {
            k = 88;
        }
 
        System.out.println(k);
 
    }
}
</code></pre><h3 id="357-位运算符">3.5.7 位运算符</h3>
<ul>
<li>一个整数的二进制表达
位操作都是对二进制而言的，但是我们平常使用的都是十进制比如5。</li>
</ul>
<p>而5的二进制是101。</p>
<p>所以在开始学习之前，需要掌握一个整数的二进制表达是多少。</p>
<p>通过Integer.toBinaryString() 方法，将一个十进制整数转换为一个二进制字符串</p>
<pre><code>public class HelloWorld {
    public static void main(String[] args) {
        int i = 5;
        String b = (Integer.toBinaryString(i)); // 5的二进制的表达101
        System.out.println(i+&quot; 的二进制表达是: &quot;+b);
    }
}
</code></pre><ul>
<li>按位与运算符（&amp;）
参加运算的两个数，按二进制位进行“与”运算。</li>
</ul>
<p>运算规则：只有两个数的二进制同时为1，结果才为1，否则为0。（负数按补码形式参加按位与运算）</p>
<p>即 0 &amp; 0= 0 ，0 &amp; 1= 0，1 &amp; 0= 0， 1 &amp; 1= 1。</p>
<p>例：3 &amp; 5 即 00000011 &amp; 00000101 = 00000001 ，所以 3 &amp; 5的值为1。</p>
<pre><code>public class HelloWorld {
    public static void main(String[] args) {
         
        int i  =5;
        int j = 6;
         
        System.out.println(Integer.toBinaryString(i)); //5的二进制是101
         
        System.out.println(Integer.toBinaryString(j)); //6的二进制是110
         
        System.out.println(i&amp;j); //所以 5&amp;6 对每一位进行与运算，得到 100-&gt;4
 
    }
}
</code></pre><ul>
<li>按位或运算符（|）
参加运算的两个数，按二进制位进行“或”运算。</li>
</ul>
<p>运算规则：参加运算的两个数只要两个数中的一个为1，结果就为1。</p>
<p>即  0 | 0= 0 ,  1 | 0= 1  ， 0 | 1= 1  ,  1 | 1= 1 。</p>
<p>例：2 | 4 即 00000010 | 00000100 = 00000110 ，所以2 | 4的值为 6 。</p>
<pre><code>public class HelloWorld {
    public static void main(String[] args) {
         
        int i  =5;
        int j = 6;
         
        System.out.println(Integer.toBinaryString(i)); //5的二进制是101
         
        System.out.println(Integer.toBinaryString(j)); //6的二进制是110
         
        System.out.println(i|j); //所以 5|6 对每一位进行或运算，得到 111-&gt;7
 
    }
}
</code></pre><ul>
<li>异或运算符（^）
参加运算的两个数，按二进制位进行“异或”运算。</li>
</ul>
<p>运算规则：参加运算的两个数，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。</p>
<p>即 0 ^ 0=0  ， 0 ^ 1= 1  ， 1 ^ 0= 1  ， 1 ^ 1= 0 。</p>
<p>例： 2 ^ 4 即 00000010 ^ 00000100 =00000110 ，所以 2 ^ 4 的值为6 。</p>
<pre><code>public class HelloWorld {
    public static void main(String[] args) {
        int i  =5;
        int j = 6;
        System.out.println(Integer.toBinaryString(i)); //5的二进制是 101
        System.out.println(Integer.toBinaryString(j)); //6的二进制是110
        System.out.println(i^j); //所以 5^6 对每一位进行或运算，得到 011-&gt;3
         
        System.out.println(i^0);
        System.out.println(i^i);
    }
}
</code></pre><ul>
<li>取非运算符（~）
参加运算的数，按二进制位进行“取非”运算。</li>
</ul>
<p>运算规则：参加运算的数，如果该位结果为1，取非为0；如果该位结果位0，取非位1.</p>
<p>5 的二进制是 00000101
所以取反即为 11111010
这个二进制换算成十进制即为-6</p>
<pre><code>public class HelloWorld {
    public static void main(String[] args) {
        byte i  =5;
         
        System.out.println(Integer.toBinaryString(i)); //5的二进制是00000101,所以取非即为11111010,即为-6
         
        System.out.println(~i);
         
    }
     
}
</code></pre><ul>
<li>左移 右移</li>
</ul>
<p>左移：根据一个整数的二进制表达，将其每一位都向左移动，最右边一位补0
<!-- raw HTML omitted --> 右移：根据一个整数的二进制表达，将其每一位都向右移动</p>
<pre><code>public class HelloWorld {
    public static void main(String[] args) {
        byte i  =6;
         
        //6的二进制是110
        System.out.println(Integer.toBinaryString(i));
        //6向左移1位后，变成1100，对应的10进制是12
        System.out.println(i&lt;&lt;1);
        //6向右移1位后，变成11，对应的10进制是3
        System.out.println(i&gt;&gt;1);
    }
     
}
</code></pre><ul>
<li>带符号右移 与 无符号右移</li>
</ul>
<p>左移：根据一个整数的二进制表达，将其每一位都向左移动，最右边一位补0
<!-- raw HTML omitted --> 右移：根据一个整数的二进制表达，将其每一位都向右移动</p>
<p><!-- raw HTML omitted --> 带符号右移 &raquo;
<!-- raw HTML omitted --> 对于正数， 带符号右移 &raquo; 会把所有的位右移，并在最前面补0
<!-- raw HTML omitted --> 对于负数， 带符号右移 &raquo; 会把所有的位右移，并在最前面补1
<!-- raw HTML omitted --> 无符号右移&raquo;&gt;
<!-- raw HTML omitted --> 如果是一个负数，那么对应的二进制的第一位是1
<!-- raw HTML omitted --> 无符号右移&raquo;&gt;会把第一位的1也向右移动，导致移动后，第一位变成0
<!-- raw HTML omitted --> 这样就会使得负数在无符号右移后，得到一个正数</p>
<pre><code>
// 带符号右移 &gt;&gt; 移动后正的还是正的，负的还是负的,符号不变
无符号右移&gt;&gt;&gt;移动后，变正的了

public class HelloWorld {
    public static void main(String[] args) {
        int i  =-10;
         
        //-10的二进制是11111111111111111111111111110110
        //第一位是1，即符号位，代表这是一个负数
        System.out.println(Integer.toBinaryString(i));
         
        //对于正数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补0
        //对于负数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补1
         
        //-10带符号右移1位，移动后前面补齐1
        //得到11111111111111111111111111111011
        //因为第一位是1，所以依然是一个负数，对应的十进制是-5
        int j = i&gt;&gt;1;
        System.out.println(Integer.toBinaryString(j));
        System.out.println(j);
         
        //-10无符号向右移1位，符号位也会向右移，第一位就变成了0
        //得到01111111111111111111111111111011，对应的十进制是2147483643
        int k = i&gt;&gt;&gt;1;
        System.out.println(Integer.toBinaryString(k));     
         
        System.out.println(k);
    }
     
}
</code></pre><h3 id="358-括号与运算符级别">3.5.8 括号与运算符级别</h3>
<h3 id="359-枚举类型">3.5.9 枚举类型</h3>
<hr>
<h2 id="36-字符串">3.6 字符串</h2>
<ul>
<li>String类 ：String e = &ldquo;&quot;;</li>
</ul>
<h3 id="361-子串">3.6.1 子串</h3>
<ul>
<li>String类的substring方法可以从一个较大的字符串提取出一个子串</li>
</ul>
<pre><code>String greeting = &quot;Hello&quot;;
String s = greeting.substring(0, 3);
// 输出 s = &quot;hel&quot;
</code></pre><h3 id="362-拼接">3.6.2 拼接</h3>
<ul>
<li>Java可以使用 + 号连接两个字符串</li>
</ul>
<h3 id="363-不可变字符串">3.6.3 不可变字符串</h3>
<ul>
<li>String类没有提供用于修改字符串的方法，这样做的优点：编译器可以让字符串共享</li>
<li>如果真的需要修改,只能重新声明,用substring提取并用 + 拼接：</li>
</ul>
<pre><code>gteeting = greeting.substring(0, 3) + &quot;p!&quot;;
</code></pre><h3 id="364-检测字符串是否相等">3.6.4 检测字符串是否相等</h3>
<ul>
<li>可以使用equals方法检测两个字符串是否相等</li>
</ul>
<h3 id="365-字串与null串">3.6.5 字串与Null串</h3>
<h3 id="366-码点与代码单元">3.6.6 码点与代码单元</h3>
<h3 id="367-string-api">3.6.7 String API</h3>
<h3 id="368-阅读联机api文档">3.6.8 阅读联机API文档</h3>
<h3 id="369-构建字符串">3.6.9 构建字符串</h3>
<ul>
<li>使用StringBuilder类</li>
<li></li>
</ul>
<pre><code>// 首先构建一个空的字符串构建器：
StringBuilder builder = new StringBuilder();

//当每次需要添加一部分内容时，就调用append方法。
builder.append(ch);
builder.append(str);

//需要构建字符串时就调用toString方法，将可以得到一个String对象
String completedString = builder.toString();
</code></pre><hr>
<h2 id="37-输入输出">3.7 输入输出</h2>
<h3 id="371-读取输入">3.7.1 读取输入</h3>
<ul>
<li>读取“标准输入流”，首先需要构建一个Scanner对象，并与“标准输入流”System.in关联</li>
</ul>
<pre><code>import java.util.*;

Scanner in = new Scanner(System.in);
System.out.print(&quot;What is your name?&quot;);
String name = in.nextLine();
</code></pre><pre><code>import java.util.*;

/**
* This program demonstrates console input.
* @version 1.10 2004-02-10
* @author Cay Horstmann
*/
public class InputTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        
        //get first input
        System.out.print(&quot;What is your name? &quot;);
        String name = in.nextLine();
        
        //get second input
        System.out.print(&quot;How old are you? &quot;);
        int age = in.nextInt();
        
        //diaplay output on console
        System.out.println(&quot;Hello, &quot; + name + &quot;.Next year, you'll be &quot; + (age + 1));
    }
}
</code></pre><ul>
<li>Scanner (InputStream in)
<!-- raw HTML omitted --> 用给定的输入流创建一个Scanner对象。</li>
<li>String nextLine()
<!-- raw HTML omitted --> 读取输入的下一行内容</li>
<li>String next()
<!-- raw HTML omitted --> 读取输入的下一个单词（以空格作为分隔符）</li>
<li>int nextInt()</li>
<li>double nextDouble()
<!-- raw HTML omitted --> 读取并转换下一个表示整数或浮点数的字符序列</li>
<li>boolean hasNext()
<!-- raw HTML omitted --> 检测输入中是否还有其他单词</li>
<li>boolean hasNextInt()</li>
<li>boolean hasNextDouble()
<!-- raw HTML omitted --> 检测是否还有表示整数或浮点数的下一个字符序列</li>
</ul>
<h3 id="372-格式化输出">3.7.2 格式化输出</h3>
<ul>
<li>沿用C语言库函数中的printf方法</li>
</ul>
<pre><code>double x = 1000.0 / 3.0;
System.out.print(x);
//输出:3333.3333333333335

System.out.printf(&quot;%8.2f&quot;, x);
//用8个字符的宽度和小数点后两个字符的精度打印X
//输出：3333.33
</code></pre><h3 id="373-文件输入与输出">3.7.3 文件输入与输出</h3>
<ul>
<li>要想对文件进行读取，就需要一个用File对象构造一个Scanner对象</li>
</ul>
<pre><code>Scanner in = new Scanner(Paths.get(&quot;myflie.txt&quot;), &quot;UTF-8&quot;);
//如果文件名中包含反斜杠符号，就要记住在每个反斜杠之前再加入一个额外的反斜：
//&quot;C:\\mydirectory\\myfile.txt&quot;。
</code></pre><ul>
<li>要写入文件，需要构造一个PrintWrite对象</li>
</ul>
<pre><code>PrintWrite out = new PrintWrite(&quot;myfile.txt&quot;, &quot;UTF-8&quot;);
</code></pre><hr>
<h2 id="38-控制流">3.8 控制流</h2>
<h3 id="381-块控制域">3.8.1 块控制域</h3>
<ul>
<li>在深入了解控制结构前，需要了解块（block）的概念</li>
<li>块（即复合语句）是指由一对大括号括起来的若干挑简单的Java语句。块确定了变量的作用域。一个块可以嵌套在另一个块中</li>
</ul>
<pre><code>public static void main(String[] args) {
    int n;
    ...
    {
        int k;
        ...
    }// k is only defined up to here
}
</code></pre><h3 id="382-条件语句">3.8.2 条件语句</h3>
<ul>
<li>if (condition) statement1 else statement2</li>
</ul>
<pre><code>    if (yourSales &gt;= target) {
        performance = &quot;Staisfactory&quot;;
        bonus = 100 + 0.01 (yourSales - target);
    } else {
        performance = &quot;Unsatisfactory&quot;;
        bonus = 0;
    }
</code></pre><ul>
<li>if (condition) statement1 else if statement2 else if statement3 else statement4</li>
</ul>
<pre><code>    if (yourSales &gt;= 2 * target) {
        performance = &quot;Excellent&quot;;
        bonus = 1000;
    } else if (yourSales &gt;= 1.5 * target) {
        performance = &quot;File&quot;;
        bonus = 500;
    } else if (yourSales &gt;= target) {
        performance = &quot;Satisfactory&quot;;
        bonus = 100;
    } else {
        System.out.println(&quot;You're fired.&quot;);
    }
</code></pre><h3 id="383-循环">3.8.3 循环</h3>
<ul>
<li>while (condition) statement</li>
</ul>
<pre><code>import java.util.*;

/**
 * This program demonstrates a &lt;code&gt;while&lt;/code&gt; loop.
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */

public class Retirement {
	public static void main(String[] args) {
		/* read inputs */
		Scanner in = new Scanner(System.in);
		
		System.out.print(&quot;How much money do you need to retire? &quot;);
		double goal = in.nextDouble();
		
		System.out.print(&quot;How much money will you contribute every year? &quot;);
		double payment = in.nextDouble();
		
		System.out.print(&quot;Interest rate in %: &quot;);
		double interestRate = in.nextDouble();
		
		double balance = 0;
		int years = 0;
		
		/* update account balance while goal isn't reached */
		while (balance &lt; goal) {
			// add this year's payment and interest
			balance += payment;
			double interest = balance * interestRate /100;
			balance += interest;
			years++;
		}
		System.out.println(&quot;You can retire in &quot; + years + &quot; years.&quot;);
	}
}
</code></pre><ul>
<li>do statement while (condition);</li>
</ul>
<pre><code>do {
    balance += payment;
    double interest = balance * interestRate / 100;
    balance += interest;
    year++;
    // print current balance
    ...
    // ask if ready to retire and get input
    ..
} while (input.eauals(&quot;N&quot;);
</code></pre><h3 id="384-确定循环">3.8.4 确定循环</h3>
<ul>
<li>计数器</li>
</ul>
<pre><code>    for (int i = 1; i &lt;= 10; i++) {
        ...
    }
    System.out.println(i);
</code></pre><pre><code>import java.util.*;

/**
 * This program demonstrates a &lt;code&gt;for&lt;/code&gt; loop.
 * @version 1.20 2004-02-10
 * @author Cay Horstman
 */

public class LotteryOdds {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		System.out.print(&quot;How many numbers do you need to draw? &quot;);
		int k = in.nextInt();

		System.out.print(&quot;What is the highest number you can draw? &quot;);
		int n = in.nextInt();

		/*
		 * compute binomial coefficient n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k)
		 */

		int lotteryOdds = 1;
		for (int i = 1; i &lt;= k; i++) {
			lotteryOdds = lotteryOdds * (n - i +1) / i;
		}
		System.out.println(&quot;Your odds are 1 in &quot; lotteryOdds + &quot;. Good luck!&quot;);
	}
}
</code></pre><h3 id="385-多重选择switch-语句">3.8.5 多重选择：switch 语句</h3>
<pre><code>    Scanner in = new Scanner(System.in);
    System.out.print(&quot;Select an option (1, 2, 3, 4)&quot;);
    int choice = in.nextInt();
    switch (choice) {
        case 1:
            ...
            break;
        case 2:
            ...
            break;
        case 3:
            ...
            break;
        case 4:
            ...
            break;
        default:
            // bad input
            ...
            break;
    }
</code></pre><h3 id="386-中断控制流程语句">3.8.6 中断控制流程语句</h3>
<ul>
<li>break 语句可以跳出当前循环；</li>
<li>break 语句通常配合 if， 在满足条件时提前结束整个循环；</li>
<li>break 语句总是跳出最近的一层循环；</li>
<li>continue 语句可以提前结束本次循环；</li>
<li>continue 语句通常配合 if， 在满足条件时提前结束本次循环。</li>
</ul>
<hr>
<h2 id="39-大数值">3.9 大数值</h2>
<ul>
<li>如果基本的整数和浮点数精度不能满足需求，那么可以使用java.math包中的两个有用的类：BigInteger 和 BigDecimal</li>
</ul>
<pre><code>import java.math.*;
import java.util.*;

/**
 * This program uses big numbers to compute the odds of winning the grand prize in a lottery.
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */

public class BigIntegerTest {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);
		
		System.out.print(&quot;How many number do you need to draw? &quot;);
		int k = in.nextInt();
		
		System.out.print(&quot;What is the highest number you can draw? &quot;);
		int n = in.nextInt();
		/*
		 * compute binomial coefficient n*(n - 1) * (n - 2) * ...*(n - k + 1）/（1*2*3*。。。*k)
		 */

		BigInteger lotteryOdds = BigInteger.valueOf(1);
		
		for (int i = 1; i &lt;= k; i++) {
			lotteryOdds = lotteryOdds.multiply(BigInteger.valueOf(n - i + 1).divide(BigInteger.valueOf(i)));
		}
		
		System.out.println(&quot;Your odds are 1 in &quot; + lotteryOdds + &quot;.Good luck!&quot;);
	}
}
</code></pre><hr>
<h2 id="310-数组">3.10 数组</h2>
<ul>
<li>数组是一种数据结构，用来存储同意类型值的集合。通过一个整型下标可以访问数组中的每个值。例如，如果a是一个整型数组，a[i]就是数组中下标为i的整数。</li>
<li>在声明数组变量时，需要指出数组类型（数据元素类型紧跟[]）和数组变量的名字。</li>
</ul>
<pre><code>    int[] = a;
    int[] a = new int[100];
    //这是一个可以存储100个整数的数组
    
    int[] a = new int[100];
    for (int i = 0; i &lt; 100; i++ ){
        a[i] = i;
    }
</code></pre><h3 id="3101-for-each-循环">3.10.1 for each 循环</h3>
<ul>
<li>for (variable : collection) statement</li>
<li>Arrays.toString(a) , 可以返回一个包含数组元素的字符串</li>
</ul>
<h3 id="3102-数组初始化以及匿名数组">3.10.2 数组初始化以及匿名数组</h3>
<ul>
<li>提供了一种创建数组对象并同时赋予初始值的简化书写形式。</li>
</ul>
<pre><code>    int[] smallPrimes = { 2, 3, 5, 7, 11, 13 };
</code></pre><ul>
<li>还可以初始化一个匿名的数组；</li>
</ul>
<pre><code>    new int[] = { 17, 19, 23, 29, 31, 37 };
</code></pre><ul>
<li>这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数。使用这种语法形式可以在不创建新变量的情况下重新初始化一个数组。</li>
</ul>
<pre><code>    smallPrint = new int[] {17, 19, 23, 29, 31, 37 };
</code></pre><h3 id="3103-数组拷贝">3.10.3 数组拷贝</h3>
<ul>
<li>允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组；</li>
</ul>
<pre><code>    int [] luckyNumber = samllPrimes;
    luckyNuber[5] = 12;
    //now smallPrimes[5] is also 12
</code></pre><ul>
<li>可以使用Arrays类的copyOf方法，将一个数组的所有值拷贝到一个新的数组中去</li>
</ul>
<pre><code>     int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckNumbers.length)
     //声明需要拷贝的数组名，以及数据的长度
</code></pre><h3 id="3104-命令行参数">3.10.4 命令行参数</h3>
<h3 id="3105-数组排序">3.10.5 数组排序</h3>
<ul>
<li>要想对数值型数值进行排序，可以使用Arrays类中的sort方法：</li>
</ul>
<pre><code>int[] a = new int[10000];
...
Arrays.sort(a);
</code></pre><pre><code>import java.util.*;

/**
 * This program demonstrates array manipulation.
 * @version 1.20 2004/02/10
 * @author Cay Horstman
 */

public class LotteryDrawing {
	public static void main(String[] args) {
		Scanner in = new Scanner(System.in);

		System.out.print(&quot;How many numbers do you need to draw? &quot;);
		int k = in.nextInt();

		System.out.print(&quot;What is the highest number you can draw? &quot;);
		int n = in.nextInt();

		// fill an array with numbrs 1 2 3...n
		int[] numbers = new int[n];
		for (int i =  0; i &lt; numbers.length; i++) {
			numbers[i] = i + 1;
		}

		//draw k numbers and put them into a second array
		int[] result = new int[k];
		for (int i = 0; i &lt; result.length; i++) {
			//make a random index between 0 and n - 1
			int r = (int) (Math.random() * n);

			//pick the elenment at the random location
			result[i] = numbers[r];

			//move the last element into the random location
			numbers[r] = numbers[n - 1];
			n--;
		}

		//print the sorted array
		Arrays.sort(result);
		System.out.println(&quot;Bet the following combination.It'll make you rich!&quot;);
		for (int r : result) {
			System.out.println(r);
		}
	}
}
</code></pre><h3 id="3106-多维数组">3.10.6 多维数组</h3>
<ul>
<li>多为数组将使用多个下标访问数组元素，它适用于表示表格或更加复杂的排列形式。</li>
</ul>
<pre><code>/**
 * This program shows how to store tabular data in a 20 array.
 * @version 1.40 2004-02-10
 * @author Cay Horstmann
 */

public class CompoundInterest {
    public static void main(String[] args) {
        final double STARTRATE = 10;
        final int NRATES = 6;
        final int NYEARS = 10;

        // set interest rates to 10 ... 15%
        double[] interestRate = new double[NRATES];
        for (int j = 0; j &lt; interestRate.length; j++) {
            interestRate[j] = (STARTRATE + j) /100.0;
        }

        double[][] balances = new double[NYEARS][NYEARS];

        // set initial balances to 10000
        for (int j = 0; j &lt; balances[0].length; j++) {
            balances[0][j] = 10000;
        }

        // compute interest for future years
        for (int i = 1; i &lt; balances.length; i++) {
            for (int j = 0; j &lt; balances[i].length; j++) {
                // get last year's balances from previous row
                double oldBalance = balances[i - 1][j];

                // compute interest
                double interest = oldBalance * interestRate[j];

                // compute this year's balances
                balances[j][j] = oldBalance + interest;
            }
        }

        // print one row of interest rates
        for (int j = 0; j &lt; interestRate.length; j++) {
            System.out.printf(&quot;%9.0f%%&quot;, 100 * interestRate[j]);
        }

        System.out.println();

        //print balance table
        for (double[] row : balances) {
            // printtable row
            for (double b : row) {
                System.out.printf(&quot;%10.2f&quot;, b);
            }
            System.out.println();
        }

    }
}

</code></pre><h3 id="3107-不规则数组">3.10.7 不规则数组</h3>
<pre><code>/**
 * This program demonstrates a triangular array;
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */

public class LotteryArray {
    public static void main(String[] args) {
        final int NMAX = 10;

        // allocate triangular array
        int[][] odds = new int[NMAX + 1][];
        for (int n = 0; n &lt; odds.length; n++) {
            odds[n] = new int[n + 1];
        }

        //fill triangular array
        for (int n = 0; n &lt; odds.length; n++) {
            for (int k = 0; k &lt; odds[n].length; k++) {
                /*
                 * compute binomial corefficient n*(n -1)*(n - 2)*...*(n-k+1)/(1*2*3*..*k)
                 */
                int lotteryOdds = 1;
                for (int i = 1; i &lt;= k; i++) {
                    lotteryOdds = lotteryOdds * (n - i + 1);
                }
                odds[n][k] = lotteryOdds;
            }
        }
        // print trigangular array
        for (int[] row : odds) {
            for (int odd : row) {
                System.out.printf(&quot;%4d&quot;, odd);
            }
            System.out.println();
        }
    }
}

</code></pre><h1 id="第四章-对象与类">第四章 对象与类</h1>
<h2 id="41-面向对象程序设计概述">4.1 面向对象程序设计概述</h2>
<h3 id="411-类">4.1.1 类</h3>
<ul>
<li>类（class）是构造对象的模板或蓝图。</li>
<li>由类构造（construct）对象的过程称为创建类的实例（instance）。</li>
<li>封装（encapsulated，有时候称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数组的实现方式，对象中的数据称为实例域（instance field）,操作数据的过程称为方法（method）。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态（state）。无论何时，只要向对象发送一个消息，它的状态就有可能发生改变。</li>
</ul>
<h3 id="412-对象">4.1.2 对象</h3>
<ul>
<li>对象的行为（behavior）————可以对对象施加哪些操作，或可以对对象施加哪些方法？</li>
<li>对象的状态（state）————当施加那些方法时，对象如何响应？</li>
<li>对象的标识（identity）————如何辨别具有相同行为与状态的不同对象？</li>
</ul>
<h3 id="413-识别类">4.1.3 识别类</h3>
<ul>
<li>传统的过程化程序设计，必须从顶部的main函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。对于学习OOP的初学者来说常常感觉无从下手。答案是：首先从设计类开始，然后再往每个类中添加方法。</li>
<li>识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。</li>
<li>例如，在订单处理系统中，由这样一些名词：
<!-- raw HTML omitted --> - 商品（Item）
<!-- raw HTML omitted --> - 订单（Order）
<!-- raw HTML omitted --> - 送货地址（Shipping address）
<!-- raw HTML omitted --> - 付款（Payment）
<!-- raw HTML omitted --> - 账户（Account）</li>
<li>接下来，查看动词：商品被添加到订单中，订单被发送或取消，订单货款被支付。对于每一个动词如：“添加”、“发送”、“取消”以及“支付”，都要标识出主要负责完成相应动作的对象。例如，当一个新的商品添加到订单中，那个订单对象就是被指定的对象，因为它知道如何存储商品以及如何对商品进行排序。</li>
<li>当然所谓“找名词与动词”原则只是一种经验，在创建类的时候，哪些名词和动词是重要的完全取决于个人的开发经验。</li>
</ul>
<h3 id="414-类">4.1.4 类</h3>
<ul>
<li>在类之间，最常见的关系由
<!-- raw HTML omitted --> - 依赖（“uses-a”）
<!-- raw HTML omitted --> - 聚合（“has-a”）
<!-- raw HTML omitted --> - 继承（“is-a”）</li>
<li>依赖（dependence），即“uses-a”关系，是一种最明显的、最常见的关系。如果，一个类的方法操控着另一个类的对象，我们就说一个类依赖于另一个类。实际上，需要尽可能地将相互依赖的类减至最少，就是需要将类之间的耦合度最小。</li>
<li>聚合（aggregation），即“has-a”关系，是一种具体且易于理解的关系。例如，一个oeder对象包含一些Item对象。聚合关系意味着类A的对象包含类B的对象。</li>
<li>继承（inheritance），即“is-a”关系，是一种用于表示特殊与一般关系的。例如，RushOreder类由Order类继承而来。在具有特殊性的RushOreder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法；而其他的方法，如添加商品、生成账单等都是从Order类继承来的。</li>
<li>很多程序员采用UML（Unified Modeling Language, 统一建模语言）绘制类图，用来描述类之间的关系。类用矩阵表示，类之间的关系用带有各种修饰的箭头表示。</li>
</ul>
<hr>
<h2 id="42-使用预定义类">4.2 使用预定义类</h2>
<h3 id="421-对象与对象变量">4.2.1 对象与对象变量</h3>
<ul>
<li>要使用对象，就必须首先构造对象，并指定其初始状态。然后，对对象应用方法。
<!-- raw HTML omitted --> 在Java程序设计语言中，使用构造器（constructor）构造新实例。构造器是一种特殊的方法，用于构造并初始化对象。</li>
</ul>
<h3 id="422-java类库中的localdate类">4.2.2 Java类库中的LocalDate类</h3>
<ul>
<li>类库设计者决定将保存时机与给时间点命名分开。所以标准Java类库分别包含了两个类：一个是用来表示时间点的Date类，另一个是用来表示大家熟悉的日历表示法的LocalDate类</li>
</ul>
<pre><code>LocalDate.now();
LocalDate.of(2020, 02, 28);
LocalDate newYearsEve = LocalDate.of(2019, 12, 31);
</code></pre><ul>
<li>一旦有了一个LocalDate对象，可以使用方法getYear、getMonthValue和getDayOfMonth得到年、月和日；</li>
</ul>
<pre><code>int year = newYearsEve.getYear();
int month = newYearsEve.getMonthValue();
int day = newYearsEve.getDayOfMonth();
</code></pre><h3 id="423-更改器方法与访问器方法">4.2.3 更改器方法与访问器方法</h3>
<ul>
<li>更改器方法————改变对象的状态</li>
<li>访问器方法————不修改对象的状态，只访问</li>
</ul>
<pre><code>import java.time.*;

/**
 * @version 1.5 2015-05-08
 * @author Cay Horstmann
 */

public class CalendarTest {
    public static void main(String[] args) {
        LocalDate date = LocalDate.now();
        int month = date.getMonthValue();
        int today = date.getDayOfMonth();

        date = date.minusDays(today - 1);
        // Set to start of month
        DayOfWeek weekday = date.getDayOfWeek();
        int value = weekday.getValue();
        // 1 = Monday,...7 = Sunday

        System.out.println(&quot;Mon Tue Wed Thu Fri Sat Sun&quot;);
        for (int i = 1; i &lt; value; i++) {
            System.out.print(&quot;    &quot;);
        }
        while (date.getMonthValue() == month) {
            System.out.printf(&quot;%3d&quot;, date.getDayOfMonth());
            if (date.getDayOfMonth() == today) {
                System.out.print(&quot;*&quot;);
            } else {
                System.out.print(&quot; &quot;);
            }
            date = date.plusDays(1);
            if (date.getDayOfWeek().getValue() == 1) {
                System.out.println();
            }
        }
        if (date.getDayOfWeek().getValue() != 1) {
            System.out.println();
        }
    }
}

</code></pre><hr>
<h2 id="43-用户自定义类">4.3 用户自定义类</h2>
<h3 id="431-employee类">4.3.1 Employee类</h3>
<ul>
<li>下面是一个简单的Employee类，编写薪金管理系统时可能会用到。</li>
</ul>
<pre><code>import java.time.*;

/**
 * This program tests the Employee class
 * @version 1.12 2015-05-08
 * @author Cay Horstmann
 */
public class EmployeeTest {
    public static void main(String[] args) {
        // fill the staff array with three Employee objects
        Employee[] staff = new Employee[3];

        staff[0] = new Employee(&quot;Carl Cracker&quot;, 75000, 1987, 12, 15);
        staff[1] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);
        staff[2] = new Employee(&quot;Tony Tester&quot;, 40000, 1990, 3, 15);

        // raise everyone's salary by 5%
        for (Employee e : staff) {
            e.raiseSalary(5);
        }

        // print out information about all Employee objects
        for (Employee e : staff) {
            System.out.println(&quot;name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary() + &quot;,hireDay=&quot; + e.getHireDay());
        }
    }
}

class Employee {
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee(String n, double s, int year, int month, int day) {
        name = n;
        salary = s;
        hireDay = LocalDate.of(year, month, day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }
    
}

</code></pre><h3 id="432-多个源文件的使用">4.3.2 多个源文件的使用</h3>
<ul>
<li>上例中，一个源文件包含了两个类。许多人还是习惯于将每一个类存在一个单独的源文件中</li>
</ul>
<h3 id="433-剖析employee类">4.3.3 剖析Employee类</h3>
<ul>
<li>通过查看源代码会发现，这个类包含了一个构造器和4个方法</li>
</ul>
<pre><code>    public Empliyee(String n, double s, int year, int month, int day)
    public String getName()
    public double getSalary()
    public LocalDate getHireDay()
    public void raiseSalary(double byPercent)
</code></pre><ul>
<li>这个类的所有方法都被标志为public。关键字public意味着任何类的任何方法都可以调用这些方法（共有4种访问级别）</li>
</ul>
<pre><code>    private String name;
    private double salary;
    private LocalDate hireDay;
</code></pre><h3 id="434-从构造器开始">4.3.4 从构造器开始</h3>
<pre><code>    public Employee(String n, double s, int year, int month, int day) {
        name = n;
        salary = s;
        LocalDate hireDay = LocalDate.of(year, month, day);
    }
</code></pre><ul>
<li>构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用，而不能对一个已存在的对象调用构造器来达到重新设置实例域的目的。例如：</li>
</ul>
<pre><code>    new Employee(&quot;James Bond&quot;, 100000, 1950, 1, 1);
    
    //将会把实例设置为
    name = &quot;James Bond&quot;;
    salary = 100000;
    hireDay = LocalDate.of(1950, 1, 1);
    
    //假设需要重定义“James Bond”的信息
    james.Employee(&quot;James Bond&quot;, 250000, 1950, 1, 1)
    // ERROR
</code></pre><ul>
<li>构造器与类同名</li>
<li>每个类可以有一个以上的构造器</li>
<li>构造器可以有0个、1个或多个参数</li>
<li>构造器没有返回值</li>
<li>构造器总是伴随着new操作一起调用</li>
</ul>
<h3 id="435-隐式参数与显式参数">4.3.5 隐式参数与显式参数</h3>
<h3 id="436-封装的优点">4.3.6 封装的优点</h3>
<ul>
<li>需要获得或设置实例域的值，需要提供下面三项内容；
<!-- raw HTML omitted --> - 一个私有的数据域；
<!-- raw HTML omitted --> - 一个公有的域访问器方法；
<!-- raw HTML omitted --> - 一个公有的域更改器方法；</li>
<li>可以内部实现，处理该类的方法外，不会影响到其他代码</li>
<li>更改器方法可以执行错误检查</li>
</ul>
<h3 id="437-基于类的访问权限">4.3.7 基于类的访问权限</h3>
<ul>
<li>方法可以访问所属类的私有特性</li>
</ul>
<h3 id="438-私有方法">4.3.8 私有方法</h3>
<h3 id="439-final实例域">4.3.9 final实例域</h3>
<ul>
<li>final修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类）</li>
</ul>
<hr>
<h2 id="44-静态域与静态方法">4.4 静态域与静态方法</h2>
<h3 id="441-静态域">4.4.1 静态域</h3>
<ul>
<li>如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</li>
</ul>
<h3 id="442-静态常量">4.4.2 静态常量</h3>
<h3 id="443-静态方法">4.4.3 静态方法</h3>
<h3 id="444-工厂方法">4.4.4 工厂方法</h3>
<h3 id="445-main方法">4.4.5 main方法</h3>
<hr>
<h2 id="45-方法参数">4.5 方法参数</h2>
<ul>
<li>
<p>方法参数共有两种类型
<!-- raw HTML omitted --> - 基本数据类型（数字、布尔值）
<!-- raw HTML omitted --> - 对象引用</p>
</li>
<li>
<p>Java 中方法参数的使用情况
<!-- raw HTML omitted --> - 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）
<!-- raw HTML omitted --> - 一个方法可以改变一个对象参数的状态
<!-- raw HTML omitted --> - 一个方法不能让对象参数引用一个新的对象</p>
</li>
</ul>
<pre><code>/**
 * This program demonstrates parameter passing in Java
 * @version 1.00 2000-01-27
 * @author Cay Horstmann
 */
public class ParamTest {
    public static void main(String[] args) {
        /*
         * Test 1: Methods can't modify numeric parameters
         */
        System.out.println(&quot;Testing tripleValue:&quot;);
        double percent = 10;
        System.out.println(&quot;Before: percent= &quot; + percent);
        tripleValue(percent);
        System.out.println(&quot;After: percent= &quot; + percent);

        /*
         * Test 2: Methods can change the state of object parameters
         */
        System.out.println(&quot;\nTesting tripleSalary:&quot;);
        Employee harry = new Employee(&quot;Harry&quot;, 50000);
        System.out.println(&quot;Before: salary= &quot; + harry.getSalary());
        tripleSalary(harry);
        System.out.println(&quot;After: salary= &quot; + harry.getSalary());

        /*
         * Test 3: Methods can't attach new object to object parameters
         */
        System.out.println(&quot;\nTesting swap: &quot;);
        Employee a = new Employee(&quot;Alice&quot;, 70000);
        Employee b = new Employee(&quot;Bob&quot;, 60000);
        System.out.println(&quot;Before: a= &quot; + a.getName());
        System.out.println(&quot;Before: b= &quot; + b.getName());
        swap(a, b);
        System.out.println(&quot;After: a= &quot; + a.getName());
        System.out.println(&quot;After: b= &quot; + b.getName());
    }

    // doesn't work
    public static void tripleValue(double x) {
        x = 3 * x;
        System.out.println(&quot;End of method: x= &quot; + x);
    }

    // works
    public static void tripleSalary(Employee x) {
        x.raiseSalary(200);
        System.out.println(&quot;End of method: salary=&quot; + x.getSalary());
    }

    public static void swap(Employee x, Employee y) {
        Employee temp = x;
        x = y;
        y = temp;
        System.out.println(&quot;End of method: x=&quot; + x.getName());
        System.out.println(&quot;End of method：y=&quot; + y.getName());
    }
}

class Employee {
    private String name;
    private double salary;

    public Employee(String n, double s) {
        name = n;
        salary = s;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }
}
</code></pre><hr>
<h2 id="46-对象构造">4.6 对象构造</h2>
<h3 id="461-重载">4.6.1 重载</h3>
<ul>
<li>有些类有多个构造器。例如，可以如下构造一个空的StringBuilder对象：</li>
</ul>
<pre><code>    StringBuilder messages = new StringBuilder();
</code></pre><ul>
<li>或者，可以指定一个初始字符串：</li>
</ul>
<pre><code>    StringBuilder messages = new StringBuilder(&quot;To do:\n&quot;);
</code></pre><ul>
<li>这种特征叫做重载（overloading）。如果多个方法（比如，StringBuilder构造器方法）有相同的名字、不同的参数，便产生了重载。编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法。如果编译器找不到匹配的参数，就会产生编译时错误，因为根本不存在匹配，或者没有一个比其他的更好。（这个过程被称为重载解析（overloading resolution）。）</li>
</ul>
<h3 id="462-默认域初始化">4.6.2 默认域初始化</h3>
<h3 id="463-无参数的构造器">4.6.3 无参数的构造器</h3>
<h3 id="464-显式域初始化">4.6.4 显式域初始化</h3>
<h3 id="465-参数名">4.6.5 参数名</h3>
<ul>
<li>参数变量用同样的名字将实例域屏蔽起来。例如，如果将参数命名为salary，salary将引用这个参数，而不是实例域。但是，可以采用this.salary的形式访问实例域。</li>
</ul>
<pre><code>    public Employee(String name, double salary) {
        this.name = naem;
        this.salary = salary;
    }
</code></pre><h3 id="466-调用另一个构造器">4.6.6 调用另一个构造器</h3>
<h3 id="467-初始化块">4.6.7 初始化块</h3>
<ul>
<li>两种初始化数据域的方法
<!-- raw HTML omitted --> - 在构造器中设置值
<!-- raw HTML omitted --> - 在声明中赋值
<!-- raw HTML omitted --> - 初始化块（initialization block）</li>
</ul>
<pre><code>import java.util.*;

/**
 * This program demonstrates object construction.
 * @version 1.01 2004-02-19
 * @author Cay Horstmann
 */

public class ConstructorTest {
    public static void main(String[] args) {
        // fill the staff array with three Employee objects
        Employee[] staff = new Employee[3];

        staff[0] = new Employee(&quot;Harry&quot;, 40000);
        staff[1] = new Employee(60000);
        staff[2] = new Employee();

        // print out information about all Employee objects
        for (Employee e : staff) {
            System.out.println(&quot;name=&quot; + e.getName() + &quot;,id=&quot; + e.getId() + &quot;,salary=&quot; + e.getSalary());
        }
    }
}

class Employee {
    private static int nextId;

    private int id;
    private String name = &quot;&quot;;
    private double salary;

    // static initialization block
    static {
        Random generator = new Random();
        // set nextId to a random number between 0 and 9999
        nextId = generator.nextInt(10000);
    }

    // object initialization block
    {
        id = nextId;
        nextId++;
    }

    // three overloaded constructors
    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public Employee(double s) {
        // calls the Employee(String, double) constructor
        this(&quot;Employee #&quot; + nextId, s);
    }

    // the default constructor
    public Employee() {
        // name initialized to &quot;&quot;--see above
        // salary not explicitly set--initialized to 0
        // id initialized in initialization block
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public int getId() {
        return id;
    }
}
</code></pre><h3 id="468-对象析构与finalize方法">4.6.8 对象析构与finalize方法</h3>
<hr>
<h2 id="47-包">4.7 包</h2>
<h3 id="471-类的导入">4.7.1 类的导入</h3>
<h3 id="472-静态导入">4.7.2 静态导入</h3>
<h3 id="473-将类放入包中">4.7.3 将类放入包中</h3>
<ul>
<li>要将一个类放入包中，就必须将包的名字放入源文件的开头，包中定义类的代码之前。例如：</li>
</ul>
<pre><code>package com.horstamann.corejava;

public class Emlpoyee {
    ...
}
</code></pre><pre><code>import com.horstmann.corejava.*;
// the Employee class is defined in that package

import static java.lang.System.*;

/**
 * This program demonstrates the use of packages.
 * @version 1.11 2004-02-19
 * @author Cay Horstmann
 */
public class PackageTest {
    public static void main(String[] args) {
        // because of the import statement, we don't have to use
        // com.horstmann.corejava.Employee here
        Employee harry = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1 );

        harry.raiseSalary(5);

        // because of the static import statement, we don't have to use System.out here
        out.println(&quot;name=&quot; + harry.getName() + &quot;,salary&quot; + harry.getSalary());
    }
}
</code></pre><pre><code>package com.horstmann.corejava;

// the classes in this file are part of this package

import java.time.*;

// import statements come after the package statement

/**
 * @version 1.11 2015-05-08
 * @author Cay Horstmann
 */
public class Emplyoee {
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee(String name, double salary, int year, int month, int day) {
        this.name = name;
        this.salary = salary;
        hireDay = LocalDate.of(year, month, day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }
}
</code></pre><ul>
<li>如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包（default package）中。默认包是一个没有名字的包。</li>
</ul>
<h3 id="474-包作用域">4.7.4 包作用域</h3>
<hr>
<h2 id="48-类路径">4.8 类路径</h2>
<h3 id="481-设置类路径">4.8.1 设置类路径</h3>
<ul>
<li>最好采用-classpath（或 -cp）选项指定类路径：</li>
</ul>
<pre><code>    java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg
    // 或者
    java -classpath c:\classdir;.;c:\archives\archive.jar MyProg
</code></pre><ul>
<li>在Bourne Again shell (bash)中，命令行：</li>
</ul>
<pre><code>    export CLASSPATH=/home/user/classdir:.:/home/user/archives/archive.jar
</code></pre><ul>
<li>在Windows shell中，命令行：</li>
</ul>
<pre><code>    set CLASSPATH=c:\classdir;.;c:\archives\archive.jar
</code></pre><ul>
<li>警告：有人建议将CLASSPATH环境变量设置为永久不变的值。总的来说这是一个很糟糕的主意。人们有可能会忘记全局环境，因此，当使用的类没有正确地加载进来时，会感到很奇怪。</li>
<li>警告：有人建议绕开类路径，将所有的文件放在jre/lib/ext路径。</li>
</ul>
<hr>
<h2 id="49-文档注释">4.9 文档注释</h2>
<ul>
<li>JDK包含了一个很有用的工具，叫做javadoc，它可以由源文件生成一个HTML文档。事实上，在第3章讲述的联机API文档就是通过对标准Java类库的源代码运行javadoc生成的。</li>
</ul>
<h3 id="491-注释的插入">4.9.1 注释的插入</h3>
<ul>
<li>jacadoc实用程序（utility）从下面几个特性中抽取信息：
<!-- raw HTML omitted --> - 包
<!-- raw HTML omitted --> - 公有类与接口
<!-- raw HTML omitted --> - 公有的和受保护的构造器及方法
<!-- raw HTML omitted --> - 公有的和受保护的域</li>
</ul>
<h3 id="492-类注释">4.9.2 类注释</h3>
<ul>
<li>类注释必须放在import语句之后，类定义之前</li>
<li>下面是一个类注释的例子：</li>
</ul>
<pre><code>/**
 *  A {@code Card} object represents a playing card, such
 *  as &quot;Queen of Hearts&quot;. A card has a suit (Diamond, Heart,
 *  Spade or Club) and a value (1 = Ace, 2...10, 11 = Jack,
 *  12 = Queen, 13 = King)
 */

public  class Card {
    ...
}
</code></pre><h3 id="493-方法注释">4.9.3 方法注释</h3>
<ul>
<li>@param 变量描述</li>
<li>@return 描述</li>
<li>@throws 类描述</li>
</ul>
<pre><code>/**
 * Raises the salary of an employee.
 * @param byPercent the percentage by which to raise the salary (e.g. 10 means 10%)
 * @return the amount of the raise
 */
public double raiseSalary(double byPercent) {
    double raise = salary * byPercent / 100;
    salary += raise;
    return raise;
}
</code></pre><h3 id="494-域注释">4.9.4 域注释</h3>
<ul>
<li>只需要对公有域（通常指的是静态常量）建立文档。例如：</li>
</ul>
<pre><code>/**
 * The &quot;Hearts&quot; card suit
 */
 public static final int HEARTS = 1;
</code></pre><h3 id="495-通用注释">4.9.5 通用注释</h3>
<ul>
<li>@author 姓名</li>
<li>@version 文本</li>
<li>@since 文本</li>
<li>@deprecated 文本</li>
<li>@deprecated Use <!-- raw HTML omitted --> setVisible(true) <!-- raw HTML omitted --> instead</li>
<li>@see 引用</li>
<li>如果愿意的话，还可以在注释中的任何位置放置指向其他类或方法的超级链接，以及插入一个专用的标记，例如：</li>
</ul>
<pre><code>    {@link package.class#feature label}
</code></pre><h3 id="496-包与概述注释">4.9.6 包与概述注释</h3>
<h3 id="497-注释的抽取">4.9.7 注释的抽取</h3>
<hr>
<h2 id="410-类设计技巧">4.10 类设计技巧</h2>
<ul>
<li>1、一定要保证数据私有</li>
<li>2、一定要对数据初始化</li>
<li>3、不要在类中使用过多的基本类型</li>
<li>4、不是所有的域都需要独立的域访问器和域更改器</li>
<li>5、将职责过多的类进行分解</li>
<li>6、类名和方法名要能够体现它们的职责</li>
<li>7、优先使用不可变的类</li>
</ul>
<hr>
<h1 id="第五章-继承">第五章 继承</h1>
<h2 id="51-类超类和子类">5.1 类、超类和子类</h2>
<h3 id="511-定义子类">5.1.1 定义子类</h3>
<ul>
<li>下面是由继承Employee类来定义Manager类的格式，关键字extends表示继承。</li>
</ul>
<pre><code>public class Manager extends Employee {
    添加方法和域
}
</code></pre><ul>
<li>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。超类和子类是Java程序员最常用的两个术语，而了解其他语言的程序员可能更加偏爱使用父类和孩子类，这些都是继承时使用的术语。</li>
<li>尽管Employee类时一个超类，但并不是因为它优于子类或者拥有比子类更多的功能。实际上恰恰相反，子类比超类拥有的功能更加丰富。</li>
</ul>
<h3 id="512-覆盖方法">5.1.2 覆盖方法</h3>
<ul>
<li>然而，超类中的有些方法对子类Manager并不一定适用。具体来说，Manager类中的getSalary方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来覆盖（override）超类中的这个方法。</li>
</ul>
<pre><code>public class Manager extends Employee {
    ...
    public double getSalary() {
        ...
        return salary + bonus; // won't work
        
        double baseSalary = getSalary(); // still won't work
        return baseSalary + bonus;
        
        // 调用超类Employee中的getSalary方法，而不是当前类的这个方法。
        // 为此，可以使用特定的关键字super解决这个问题
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
    }
    ...
}
</code></pre><h3 id="513-子类构造器">5.1.3 子类构造器</h3>
<pre><code>public Manager(String name, double salry, int year, int month, int day) {
    super(name, salary, year, month, day);
    bonus = 0;
}
</code></pre><ul>
<li>以下语句,是“调用超类Employee中含有n、s、year、month和day参数的构造器”的简写形式；</li>
</ul>
<pre><code>    super(name, salary, year, month, day); 
</code></pre><pre><code>package inheritance;

/**
 * This program demonstrates inheritance.
 * @version 1.21 2004-02-21
 * @author Cay Horstmann
 */
public class ManagerTest {
    public static void mian(String[] args) {
        // construct a Manager object
        Manager boss = new Manager(&quot;Carl Cracker&quot;, 80000, 1987, 12, 15);
        boss.setBonus(500);

        Employee[] staff = new Employee[3];

        // fill the staff array with Manager and Employee objects

        staff[0] = boss;
        staff[1] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);
        staff[2] = new Employee(&quot;Tommy Tester&quot;, 40000, 1990, 3, 15);

        // print out information about all Employee objects
        for (Employee e : staff) {
            System.out.println(&quot;name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary());
        }

    }
}
</code></pre><pre><code>package inheritance;

import java.time.*;

public class Employee {
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee(String name, double salary, int year, int month, int day) {
        this.name = name;
        this.salary = salary;
        hireDay = LocalDate.of(year, month, day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }
}
</code></pre><pre><code>package inheritance;

public class Manager extends Employee {
    private double bonus;

    /**
     * @param name the employee's name
     * @param salary the salary
     * @param year the hire year
     * @param month teh hire month
     * @param day the hire day
     */
    public Manager(String name, double salary, int year, int month, int day) {
        super(name, salary, year, month, day);
        bonus = 0;
    }

    @Override
    public double getSalary() {
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
    }

    public void setBonus(double b) {
        bonus = b;
    }
}
</code></pre><h3 id="514-继承层次">5.1.4 继承层次</h3>
<ul>
<li>继承并不仅限于一个层次。例如，可以由Manager类派生Executive类。由一个公共超类派生处理的所有类派生出来的所有类的集合被称为继承层次（inheritance hierarchy），在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链（inheritance chain）。</li>
</ul>
<h3 id="515-多态">5.1.5 多态</h3>
<h3 id="516-理解方法调用">5.1.6 理解方法调用</h3>
<h3 id="517-阻止继承final类和方法">5.1.7 阻止继承：final类和方法</h3>
<h3 id="518-强制类型转换">5.1.8 强制类型转换</h3>
<h3 id="519-抽象类">5.1.9 抽象类</h3>
<pre><code>package abstractClasses;

/**
 * This program demonstrates abstract classes.
 * @version 1.01 2004-02-21
 * @author Cay Horstmann
 */
public class PersonTest {
    public static void main(String[] args) {
        Person[] people = new Person[2];

        // fill the people array with Student and Employee objects
        people[0] = new Employee(&quot;Harry Hacker&quot;, 50000, 1989, 10, 1);
        people[1] = new Student(&quot;Maria Morris&quot;, &quot;computer science&quot;);

        // print out names and descriptions of all Person objects
        for (Person p : people) {
            System.out.println(p.getName() + &quot;,&quot; + p.getDescription());
        }
    }
}
</code></pre><pre><code>package abstractClasses;

public abstract class Person {
    public abstract String getDescription();
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}
</code></pre><pre><code>package abstractClasses;

import java.time.*;

public class Employee extends Person {
    private double salary;
    private LocalDate hireDay;

    public Employee(String name, double salary, int year, int month, int day) {
        super(name);
        this.salary = salary;
        hireDay = LocalDate.of(year, month, day);
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    @Override
    public String getDescription() {
        return String.format(&quot;an employee with a salary of $%.2f&quot;, salary);
    }

    public void raiseSalry(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }
}
</code></pre><pre><code>package abstractClasses;

public class Student extends Person {
    private String major;

    /**
     * @param name the student's name;
     * @param major the student's major
     */
    public Student(String name, String major) {
        // pass n to superclass constructor

        super(name);
        this.major = major;
    }

    @Override
    public String getDescription() {
        return &quot;a student majoring in &quot; + major;
    }
}
</code></pre><h3 id="511-受保护访问">5.1.1 受保护访问</h3>
<ul>
<li>如果需要限制某个方法的使用，就可以将它申明为protected。这表明子类（可能很熟悉祖先类）得到信任，可以正确地使用这个方法，而其他类则不行。</li>
<li>下面归纳一下Java用于控制可见性的4个访问修饰符：
<!-- raw HTML omitted --> - 1、仅对本类可见——private
<!-- raw HTML omitted --> - 2、对所有类可见——public
<!-- raw HTML omitted --> - 3、对本包和所有子类可见——protected
<!-- raw HTML omitted --> - 4、对本包可见——默认，不需要修饰符</li>
</ul>
<hr>
<h2 id="52-object所有类的超类">5.2 Object：所有类的超类</h2>
<h3 id="521-equals方法">5.2.1 equals方法</h3>
<h3 id="522-相等测试与继承">5.2.2 相等测试与继承</h3>
<h3 id="523-hashcode方法">5.2.3 hashCode方法</h3>
<h3 id="524-tostring方法">5.2.4 toString方法</h3>
<ul>
<li>toString方法，可以返回表示对象值的字符串。下面是一个典型的例子：</li>
</ul>
<pre><code>public String toString() {
    return &quot;Employee[name=&quot; + name
    + &quot;,salary=&quot; + salary
    + &quot;,hireDay=&quot; + hireDay
    + &quot;]&quot;
    
    return getClass().getName()
    + &quot;[name=&quot; + name
    + &quot;,salary=&quot; + salary
    + &quot;,hiteDay=&quot; + hireDay
    + &quot;]&quot;;
}
</code></pre><pre><code>public class Manager extends Employee {
    ...
    public String toString() {
        return super.toString()
        + &quot;[bonus=&quot; + bonus
        + &quot;]&quot;;
    }
}
</code></pre><p>以下为测试代码：</p>
<pre><code>package equals;

/**
 * This program demonstrates the equals method.
 * @version 1.12 2012-01-26
 * @author Cay Horstmann
 */
public class EqualsTest {
    public static void main(String[] args) {
        Employee alicel = new Employee(&quot;Alice Adams&quot;, 75000, 1987, 12, 15);
        Employee alice2 = alicel;
        Employee alice3 = new Employee(&quot;Alice Adams&quot;, 75000, 1987, 12, 15);
        Employee bob = new Employee(&quot;Bob brandson&quot;, 5000, 1090, 10, 1);

        System.out.println(&quot;alicel == alice2: &quot; + (alicel = alice2));

        System.out.println(&quot;alice1 == alice3: &quot; + (alicel == alice3));

        System.out.println(&quot;alice1.equals(alice3): &quot; + alicel.equals(alice3));

        System.out.println(&quot;alice1.equals(bob): &quot; + alicel.equals(bob));

        System.out.println(&quot;bob.toString(): &quot; + bob);

        Manager carl = new Manager(&quot;Caral Cracker&quot;, 80000, 1987, 12, 15);
        Manager boss = new Manager(&quot;Caral Cracker&quot;, 80000, 1987, 12, 15);
        boss.setBonus(5000);
        System.out.println(&quot;boss.toString():&quot; + boss);
        System.out.println(&quot;carl.equals(boss):&quot; + carl.equals(boss));
        System.out.println(&quot;alicel.hashCode():&quot; + alicel.hashCode());
        System.out.println(&quot;alice3.hashCode()&quot; + alice3.hashCode());
        System.out.println(&quot;bob.hashCode():&quot; + bob.hashCode());
        System.out.println(&quot;carl.hashCode(): &quot; + carl.hashCode());
    }
}
</code></pre><pre><code>package equals;

import java.time.*;
import java.util.Objects;

public class Employee {
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee(String name, double salary, int year, int month, int day) {
        this.name = name;
        this.salary = salary;
        hireDay = LocalDate.of(year, month, day);
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary += raise;
    }

    @Override
    public boolean equals(Object otherObject) {
        // a quick test to see if objects are identical
        if (this == otherObject) {
            return true;
        }

        // must return false if the explicit parameter is null
        if (otherObject == null) {
            return false;
        }

        // if the classes don't match, they can't be equal
        if (getClass() != otherObject.getClass()) {
            return false;
        }

        // now we know otherObject is a non-null Employee
        Employee other = (Employee) otherObject;

        // test whether the fields have identical values
        return Objects.equals(name, other.name) &amp;&amp; salary == other.salary
                &amp;&amp; Objects.equals(hireDay, other.hireDay);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, salary, hireDay);
    }

    @Override
    public String toString() {
        return getClass().getName() + &quot;[name=&quot; + name + &quot;,salary=&quot; + salary +
                &quot;.hireDay=&quot; + hireDay + &quot;]&quot;;
    }
}
</code></pre><pre><code>package equals;

public class Manager extends Employee {
    private double bonus;

    public Manager(String name, double salary, int year, int month, int day) {
        super(name, salary, year, month, day);
        bonus = 0;
    }

    @Override
    public double getSalary() {
        double baseSalary = super.getSalary();
        return baseSalary + bonus;
    }

    public void setBonus(double bonus) {
        this.bonus = bonus;
    }

    @Override
    public boolean equals(Object otherObject) {
        if (!super.equals(otherObject)) return false;
        Manager other = (Manager) otherObject;
        // super.equals checked that this and other belong to the same class
        return bonus == other.bonus;
    }

    @Override
    public int hashCode() {
        return super.hashCode() + 17 * new Double(bonus).hashCode();
    }

    @Override
    public String toString() {
        return super.toString() + &quot;[bonus=&quot; + bonus + &quot;]&quot;;
    }

    public double getBonus() {
        return bonus;
    }
}
</code></pre><hr>
<h2 id="53-泛型数组列表">5.3 泛型数组列表</h2>
<ul>
<li>在许多程序设计语言中，特别是在C++语言中，必须 在编译时就确定整个数组的大小。程序元对此十分反感，因为这样做将迫使程序员做出一些不情愿的折中，例如，在一个部门中，有多少雇员？肯定不会超过100人。一旦出现一个拥有150名雇员的大型部门呢？愿意为那些仅有10名雇员的部门浪费90名雇员占据的存储空间吗？</li>
</ul>
<h3 id="531-访问数组列表元素">5.3.1 访问数组列表元素</h3>
<pre><code>package arraryList;

import equals.Employee;

import  java.util.*;

/**
 * This program demonstrates the ArrayList class.
 * @version 1.11 2012-01-26
 * @author Cay Horstmann
 */
public class ArrayListTest {
    public static void main(String[] args) {
        // fill the staff array list with three Employee objects
        ArrayList&lt;Employee&gt; staff = new ArrayList&lt;&gt;();

        staff.add(new Employee(&quot;Carl Cracker&quot;, 7500, 1987, 12, 15));
        staff.add(new Employee(&quot;Harry Hacker&quot;, 5000, 1989, 10, 1));
        staff.add(new Employee(&quot;Tony Tester&quot;, 40000, 1990,3, 15));

        // raise everyone's salary by 5%
        for (Employee e : staff) {
            e.raiseSalary(5);
        }

        // print out information about all Employee obhects
        for (Employee e : staff) {
            System.out.println(&quot;name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary() + &quot;,hireDay=&quot;
            + e.getHireDay());
        }
    }
}
</code></pre><h3 id="532-类型化与原始数组列表的兼容性">5.3.2 类型化与原始数组列表的兼容性</h3>
<h3 id="533-对象包装器与自动装箱">5.3.3 对象包装器与自动装箱</h3>
<h3 id="534-参数数量可变的方法">5.3.4 参数数量可变的方法</h3>
<hr>
<h2 id="54-对象包装器与自动装箱">5.4 对象包装器与自动装箱</h2>
<hr>
<h2 id="55-参数数量可变的方法">5.5 参数数量可变的方法</h2>
<hr>
<h2 id="56-枚举类">5.6 枚举类</h2>
<pre><code>package enums;

import java.net.StandardSocketOptions;
import java.util.*;

/**
 * This program demonstrates enumerated types.
 * @version 1.0 2004-05-24
 * @author Cay Horstmann
 */
public class EnumTest {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println(&quot;Enter a size: (SMALL, MEDIUM, LARGE, EXTRA_LARGE) &quot;);
        String input = in.next().toUpperCase();
        Size size = Enum.valueOf(Size.class, input);
        System.out.println(&quot;size=&quot; + size);
        System.out.println(&quot;abbreviation=&quot; + size.getAbbreviation());
        if (size == Size.EXTRA_LARGE) {
            System.out.println(&quot;Good job--you paid attention to the _.&quot;);
        }
    }
}

enum Size {
    SMALL(&quot;S&quot;), MEDIUM(&quot;M&quot;), LARGE(&quot;L&quot;),EXTRA_LARGE(&quot;XL&quot;);

    private Size(String abbreviation) {
        this.abbreviation = abbreviation;
    }

    public String getAbbreviation() {
        return abbreviation;
    }

    private String abbreviation;
}
</code></pre><hr>
<h2 id="57-反射">5.7 反射</h2>
<ul>
<li>能够分析类能力的程序称为反射（reflective），以下为反射的具体作用：
<!-- raw HTML omitted --> - 在运行时分析类的的能力；
<!-- raw HTML omitted --> - 在运行时查看对象，例如，编写一个toString方法供所有类使用；
<!-- raw HTML omitted --> - 实现通用的数组操作代码
<!-- raw HTML omitted --> - 利用Method对象，这个对象很像C++中的函数指针</li>
</ul>
<h3 id="571-class类">5.7.1 Class类</h3>
<ul>
<li>
<p>除了int等基本类型外，Java的其他类型全部都是class（包括interface）。</p>
</li>
<li>
<p>而class是由JVM在执行过程中动态加载的。JVM在第一次读取到一种class类型时，将其加载进内存。</p>
</li>
<li>
<p>每加载一种class，JVM就为其创建一个Class类型的实例，并关联起来。注意：这里的Class类型是一个名叫Class的class。</p>
</li>
</ul>
<pre><code>public final class Class {
    private Class() {}
}
</code></pre><ul>
<li>
<p>由于JVM为每个加载的class创建了对应的Class实例，并在实例中保存了该class的所有信息，包括类名、包名、父类、实现的接口、所有方法、字段等，因此，如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息。</p>
</li>
<li>
<p>这种通过Class实例获取class信息的方法称为反射（Reflection）。</p>
</li>
</ul>
<pre><code>public class Main {
    public static void main(String[] args) {
        printClassInfo(&quot;&quot;.getClass());
        printClassInfo(Runnable.class);
        printClassInfo(java.time.Month.class);
        printClassInfo(String[].class);
        printClassInfo(int.class);
    }

    static void printClassInfo(Class cls) {
        System.out.println(&quot;Class name: &quot; + cls.getName());
        System.out.println(&quot;Simple name: &quot; + cls.getSimpleName());
        if (cls.getPackage() != null) {
            System.out.println(&quot;Package name: &quot; + cls.getPackage().getName());
        }
        System.out.println(&quot;is interface: &quot; + cls.isInterface());
        System.out.println(&quot;is enum: &quot; + cls.isEnum());
        System.out.println(&quot;is array: &quot; + cls.isArray());
        System.out.println(&quot;is primitive: &quot; + cls.isPrimitive());
    }
}
</code></pre><h3 id="572-捕获异常">5.7.2 捕获异常</h3>
<ul>
<li>异常有两种类型：未检查异常和已检查异常。对于已检查异常，编译器将会检查是否提供了处理器。以下为最简单的处理器：</li>
<li>将可能抛出已检查异常的一个或多个方法调用代码放在try中，然后在catch子句中提供处理器代码。</li>
</ul>
<pre><code>try {
    statements that might throw exceptions
}
catch (Exception e) {
    handler action
}

// 实例
try {
    String name = ...; //get class name
    Class cl = class.forName(name); // might throw exception
    do something with cl
}
catch (Exception e) {
    e.printStackTrace();
}
</code></pre><ul>
<li>如果类名不存在，则跳过try块中的剩余代码，程序直接进入catch子句（这里，利用Throwwable类的printStackTrace方法打印出栈的轨迹。Throwale是Exception类的超类）。如果try块中没有抛出任何异常，那么会跳过catch子句的处理器代码。</li>
</ul>
<h3 id="573-利用反射分析类的能力">5.7.3 利用反射分析类的能力</h3>
<ul>
<li>在java.lang.reflect包中有三个类Field、Method和Constructor分别用于描述类的域、方法和构造器。</li>
<li>Class类中的getFields、getMethods和getConstructors方法将分别返回类提供的public域、方法和构造器，其中包括超类的公有成员。Class类的getDeclareFields、getDeclareMethods和getDeclaredContructors方法将分别返回类中声明的全部域、方法和构造器，其中包括私有和受保护成员，但不包括超类的成员。</li>
</ul>
<pre><code>package reflection;

import java.util.*;
import java.lang.reflect.*;

/**
 * This program uses reflection to print all features of a class.
 * @version 1.1 2004-02-21;
 * @author Cay Horstmann
 */
public class ReflectionTest {
    public static void main(String[] args) {
        // read class name from command line args or user input
        String name;
        if (args.length &gt; 0) {
            name = args[0];
        } else {
            Scanner in = new Scanner(System.in);
            System.out.println(&quot;Enter class name (e.g. java.util.Date): &quot;);
            name = in.next();
        }

        try {
            // print class name and superclass name (if != Object)
            Class cl = Class.forName(name);
            Class supercl = cl.getSuperclass();
            String modifiers = Modifier.toString(cl.getModifiers());
            if (modifiers.length() &gt; 0) {
                System.out.print(modifiers + &quot; &quot;);
            }
            System.out.print(&quot;class &quot; + name);
            if (supercl != null &amp;&amp; supercl != Object.class) {
                System.out.print(&quot; extends &quot; + supercl.getName());
            }
            System.out.print(&quot;\n{\n&quot;);
            printConstructors(cl);
            System.out.println();
            printMethods(cl);
            System.out.println();
            printFields(cl);
            System.out.println(&quot;}&quot;);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.exit(0);
    }

    /**
     * Prints all constructors of a class
     * @param cl a class
     */
    public static void printConstructors(Class cl) {
        Constructor[] constructors = cl.getDeclaredConstructors();

        for (Constructor c : constructors) {
            String name = c.getName();
            System.out.print(&quot;  &quot;);
            String modifiers = Modifier.toString(c.getModifiers());
            if (modifiers.length() &gt; 0) {
                System.out.print(modifiers + &quot; &quot;);
            }
            System.out.print(name + &quot;(&quot;);
            // print parameter types
            Class[] paramTypes = c.getParameterTypes();
            for (int j = 0; j &lt; paramTypes.length; j++) {
                if (j &gt; 0) {
                    System.out.print(&quot;, &quot;);
                }
                System.out.print(paramTypes[j].getName());
            }
            System.out.println(&quot;);&quot;);
        }
    }

    /**
     * Prints all methods of a class
     * @param cl a class
     */
    public static void printMethods(Class cl) {
        Method[] methods = cl.getDeclaredMethods();

        for (Method m : methods) {
            Class retType = m.getReturnType();
            String name = m.getName();

            System.out.print(&quot;  &quot;);
            // print modifiers, return type and method name
            String modifiers = Modifier.toString(m.getModifiers());
            if (modifiers.length() &gt; 0) {
                System.out.print(modifiers + &quot; &quot;);
            }
            System.out.print(retType.getName() + &quot; &quot; + name + &quot;(&quot;);
            // print parameter types
            Class[] paramTypes = m.getParameterTypes();
            for (int j = 0; j &lt; paramTypes.length; j++) {
                if (j &gt; 0) {
                    System.out.print(&quot;, &quot;);
                }
                System.out.print(paramTypes[j].getName());
            }
            System.out.println(&quot;);&quot;);
        }
    }

    /**
     * Prints all fields of a class
     * @param cl a class
     */
    public static void printFields(Class cl) {
        Field[] fields = cl.getDeclaredFields();

        for (Field f : fields) {
            Class type = f.getType();
            String name = f.getName();
            System.out.print(&quot;  &quot;);
            String modifiers = Modifier.toString(f.getModifiers());
            if (modifiers.length() &gt; 0) {
                System.out.print(modifiers + &quot; &quot;);
            }
            System.out.println(type.getName() + &quot; &quot; + name + &quot;;&quot;);
        }
    }
}
</code></pre><h3 id="574-在运行时使用反射分析对象">5.7.4 在运行时使用反射分析对象</h3>
<pre><code>package objectAnalyzer;

import java.util.ArrayList;

/**
 * This program uses reflection to spy on objects.
 * @version 1.12 2012-01-26;
 * @author Cay Horstmann
 */
public class ObjectAnalyzerTest {
    public static void main(String[] args) {
        ArrayList&lt;Integer&gt; squares = new ArrayList&lt;&gt;();
        for (int i = 1; i &lt;= 5; i++) {
            squares.add(i * i);
            System.out.println(new ObjectAnalyzer().toString(squares));
        }
    }
}
</code></pre><pre><code>package objectAnalyzer;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;

/**
 * @author qq_lin
 */
public class ObjectAnalyzer {
    private ArrayList&lt;Object&gt; visited = new ArrayList&lt;&gt;();
    /**
     * Converts an object to a string representation that lists all fields.
     * @param obj an object
     * @retrun a string with the object's class name and field names and values
     */
    public String toString(Object obj) {
        if (obj == null){
            return &quot;null&quot;;
        }
        if (visited.contains(obj)) {
            return &quot;...&quot;;
        }
        visited.add(obj);
        Class cl = obj.getClass();
        if (cl == String.class) {
            return (String) obj;
        }
        if (cl.isArray()) {
            String r = cl.getComponentType() + &quot;[]{&quot;;
            for (int i = 0; i &lt; Array.getLength(obj); i++) {
                if (i &gt; 0) {
                    r = r + &quot;,&quot;;
                }
                Object val = Array.get(obj, i);
                if (cl.getComponentType().isPrimitive()) {
                    r = (String) (r + val);
                } else {
                    r = r + toString(val);
                }
            }
            return r + &quot;}&quot;;
        }

        String r = cl.getName();
        // inspect the fields of this class and all superclasses
        do {
            r = r + &quot;[&quot;;
            Field[] fields = cl.getDeclaredFields();
            AccessibleObject.setAccessible(fields, true);
            // get the names and values of all fields
            for (Field f : fields) {
                if (!Modifier.isStatic(f.getModifiers())){
                    if (!r.endsWith(&quot;[&quot;)) {
                        r = r + &quot;,&quot;;
                    }
                    r = r + (f.getName() + &quot;=&quot;);
                    try {
                        Class t = f.getType();
                        Object val = f.get(obj);
                        if (t.isPrimitive()) {
                            r += val;
                        } else {
                            r += toString(val);
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                }
            }
            r = r + &quot;]&quot;;
            cl = cl.getSuperclass();
        }
        while (cl != null) ;
        return r;
    }
}
</code></pre><h3 id="575-使用反射编写泛型数组代码">5.7.5 使用反射编写泛型数组代码</h3>
<h3 id="576-调用任何方法">5.7.6 调用任何方法</h3>
<h2 id="58-继承的设计技巧">5.8 继承的设计技巧</h2>
<hr>
<h1 id="第6章-接口lambda表达式与内部类">第6章 接口、lambda表达式与内部类</h1>
<ul>
<li>接口（interface）技术，这种技术主要用来描述类具有什么功能，而不给出每个功能的具体实现。一个类可以实现（implement）一个或多个接口，并在需要接口的地方，随时使用实现了相应接口的对象。了解接口以后，再继续介绍lambda表达式，可以用一种精巧而简洁的方式表示使用回调或变量行为的代码。</li>
<li>接下来，讨论内部类（inner class）机制。内部类定义在另一个类的内部，其中的方法可以访问包含他们的外部类的域。内部类技术主要用于设计具体有相互协作关系的类集合。</li>
<li>最后，是代理（proxy），这是一种实现任意接口的对象。代理是一种非常专业的构造工具，它可以用来构建系统级的工具。</li>
</ul>
<h2 id="61-接口">6.1 接口</h2>
<h3 id="611-接口概念">6.1.1 接口概念</h3>
<ul>
<li>在Java程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。</li>
<li>下面为Comparable接口的代码：</li>
</ul>
<pre><code>public interface Comparable {
    int compareTo(Object other);
}
</code></pre><ul>
<li>为了让类实现一个接口，通常需要下面两个步骤：
<!-- raw HTML omitted --> 1）将类声明为实现给定的接口
<!-- raw HTML omitted --> 2) 对接口中的所有方法进行定义</li>
<li>要将类申明为实现某个接口，需要使用关键字implements</li>
</ul>
<pre><code>class Employee implements Comparable&lt;Employee&gt; {
    public int compareTo(Employee other) {
        return Double.compare(Salary, other.salary);
        ...
    }
}
</code></pre><pre><code>package interfaces;

import equals.Employee;

import java.util.*;

/**
 * This program demonstrates the use of the Comparable interface.
 * @version 1.30 2004-02-27
 * @author Cay Horstmann
 */
public class EmployeeSortTest {
    public static void main(String[] args) {
        Employee[] staff = new Employee[3];

        staff[0] = new Employee(&quot;Harry Hacker&quot;, 35000);
        staff[1] = new Employee(&quot;Carl Craker&quot;, 75000);
        staff[2] = new Employee(&quot;Tony Tester&quot;, 38000);

        Arrays.sort(staff);

        // print out information about all Employee objects
        for (Employee e : staff) {
            System.out.println(&quot;name=&quot; + e.getName() + &quot;,salary=&quot; + e.getSalary());
        }
    }
}
</code></pre><pre><code>package interfaces;

public class Employee implements Comparable&lt;Employee&gt; {
    private String name;
    private double salary;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
    }

    public String getName() {
        return name;
    }

    public double getSalary() {
        return salary;
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary = salary + raise;
    }

    /**
     * Compare employees by salary
     * @param other another Employee object
     * @return a negative value if this employee has a lower salary than
     * otherObject, 0 if the salaries are the same, a positive value otherwise
     */
    @Override
    public int compareTo(Employee other) {
        return Double.compare(salary, other.salary);
    }
}
</code></pre><h3 id="612-接口的特性">6.1.2 接口的特性</h3>
<ul>
<li>接口不是类，尤其不能使用new运算符实例化一个接口</li>
<li>接口变量必须引用实现了接口的类对象</li>
<li>虽然在接口不能包含实例域或静态方法，但却可以包含常量。例如</li>
</ul>
<pre><code>    public interface Powered extends Moveable {
        double milesPerGallon();
        double SPEED_LIMIT = 95;// apublic static final costant
    }
</code></pre><h3 id="613-接口与抽象类">6.1.3 接口与抽象类</h3>
<ul>
<li>使用抽象类表示通用属性存在着这样的问题：每个类只能扩展于一个类。假设Employee类已经扩展于一个类，例如Person,它就不能再像下面这样扩展第二个类了。</li>
</ul>
<pre><code>    class Employee extends Person, Comparable // Error
</code></pre><ul>
<li>但每个类可以像下面这样实现多个接口：</li>
</ul>
<pre><code>    class Employee extends Person implements Comparable // OK
</code></pre><h3 id="614-静态方法">6.1.4 静态方法</h3>
<h3 id="615-默认方法">6.1.5 默认方法</h3>
<h3 id="616-解决默认方法冲突">6.1.6 解决默认方法冲突</h3>
<ul>
<li>如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法，会发生申明情况？规则如下：
<!-- raw HTML omitted --> 1) 超类优先。如果超类提供另一个具体方法，同名而且有相同参数类型的默认方法会被葫芦
<!-- raw HTML omitted --> 2) 接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数）相同的方法，必须覆盖这个方法来解决冲突。</li>
</ul>
<hr>
<h2 id="62-接口示例">6.2 接口示例</h2>
<h3 id="621-接口与回调">6.2.1 接口与回调</h3>
<ul>
<li>回调（callback）是一种常见的程序设计模式。在这种模式下，可以指出某个特定事件发生时应该采取的动作。例如，可以指出在按下鼠标或选择某个菜单项时应该采取什么行动。</li>
</ul>
<pre><code>package timer;

/**
 * @version 1.01 2015-05-12
 * @author Cay Horsmann
 */

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;
// to resolve conflict with java.util.Timer

public class TimerTest {
    public static void main(String[] args) {
        ActionListener listener = new TimePrinter();

        // construct a timer that calls the listener
        // once every 10 seconds
        Timer t = new Timer(10000, listener);
        t.start();
        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);
        System.exit(0);
    }
}

class TimePrinter implements ActionListener {
    @Override
    public void actionPerformed(ActionEvent event) {
        System.out.println(&quot;At the tone, the time is &quot; + new Date());
        Toolkit.getDefaultToolkit().beep();
    }
}
</code></pre><h3 id="622-comparator-接口">6.2.2 Comparator 接口</h3>
<h3 id="623-对象克隆">6.2.3 对象克隆</h3>
<pre><code>package clone;

/**
 * This program demonstrates cloning.
 * @version 1.10 2002-07-01
 * @author Cay Horstmann
 */
public class CloneTest {
    public static void main(String[] args) {
        try {
            Employee original = new Employee(&quot;John Q.Public&quot;, 50000);
            original.setHireDay(2000, 1, 1);
            Employee copy = original.clone();
            copy.raiseSalary(10);
            System.out.println(&quot;original=&quot; + original);
            System.out.println(&quot;copy=&quot; + copy);
        }
        catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><pre><code>package clone;

import java.util.Date;
import java.util.GregorianCalendar;

public class Employee implements Cloneable {
    private String name;
    private double salary;
    private Date hireDay;

    public Employee(String name, double salary) {
        this.name = name;
        this.salary = salary;
        hireDay = new Date();
    }

    @Override
    public Employee clone() throws CloneNotSupportedException {
        // call Object.clone()
        Employee cloned = (Employee) super.clone();

        // clone mutable fields
        cloned.hireDay = (Date) hireDay.clone();

        return cloned;
    }

    /**
     * Set the hire day to a given date.
     * @param year the year of the hire day
     * @param month the month if the hire day
     * @param day the day of the hire day
     */
    public void setHireDay(int year, int month, int day) {
        Date newHireDay = new GregorianCalendar(year, month - 1, day).getTime();
        // Example of instance field mutation
        hireDay.setTime(newHireDay.getTime());
    }

    public void raiseSalary(double byPercent) {
        double raise = salary * byPercent / 100;
        salary = salary + raise;
    }

    @Override
    public String toString() {
        return &quot;Employee[name=&quot;  + name + &quot;,salary=&quot; + salary + &quot;,hireDay=&quot; + hireDay + &quot;]&quot;;
    }
}
</code></pre><hr>
<h2 id="63-lambda表达式">6.3 lambda表达式</h2>
<h3 id="631-为什么引入lambda表达式">6.3.1 为什么引入lambda表达式</h3>
<ul>
<li>lambda表达式是一个可传递的代码块，可以在以后执行一次或多次。</li>
</ul>
<h3 id="632-lambda表达式的语法">6.3.2 lambda表达式的语法</h3>
<ul>
<li>lambda表达式形式：参数，箭头（-&gt;）以及一个表达式。</li>
</ul>
<pre><code>(String first, String second) -&gt;
    first.length() - second.length;
</code></pre><ul>
<li>如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在{}中，并包含显式的return语句。</li>
</ul>
<pre><code>(String first, String second) -&gt; {
        if (first.length() &lt; second.length()) {
            return -1;
        } else if (first.length() &gt; second.length()){
            return 1;
        } else {
            return 0;
        }
    }
</code></pre><ul>
<li>即使lambda表达式没有参数，仍然需要提供空括号，就像无参数方法一样；</li>
</ul>
<pre><code>() -&gt; { for (int i = 100; i &gt;= 0; i--);}
</code></pre><ul>
<li>如果可以推到出一个lambda表达式的参数类型，则可以忽略其类型。例如：</li>
</ul>
<pre><code>Comparator&lt;String&gt; comp
    = (first, second) // Same as (String first, String second)
        -&gt; first.length() - second.length();
</code></pre><ul>
<li>以下程序显示了如何在一个比较器和一个动作监听器中使用lambda表达式</li>
</ul>
<pre><code>package lambda;

import java.awt.*;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;

/**
 * This program demonstrates the use of lambda expressions.
 * @version 1.0 2015-05-12
 * @author Cay Horstmann
 */
public class LambdaTest {
    public static void main(String[] args) {
        String[] planets = new String[] { &quot;Mercury&quot;, &quot;venus&quot;, &quot;Earth&quot;, &quot;Mars&quot;,
            &quot;Jupiter&quot;, &quot;Saturn&quot;, &quot;Uranus&quot;, &quot;Neptune&quot; };
        System.out.println(Arrays.toString(planets));
        System.out.println(&quot;Sorted in dictionary order:&quot;);
        Arrays.sort(planets);
        System.out.println(&quot;Sorted by length:&quot;);
        Arrays.sort(planets, (first, second) -&gt; first.length() - second.length());
        System.out.println(Arrays.toString(planets));

        Timer t = new Timer(1000, event -&gt;
                System.out.println(&quot;The time is &quot; + new Date()));
        t.start();

        // keep program running until user selects &quot;OK&quot;
        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);
        System.exit(0);
    }
}
</code></pre><h3 id="633-函数式接口">6.3.3 函数式接口</h3>
<h3 id="634-方法引用">6.3.4 方法引用</h3>
<pre><code>    Timer t = new Timer(1000, event -&gt; System.out.println(event));
    
    // 使用 :: 操作符分隔方法名与对象或类名
    Timer t = new Timer(1000, System.out::println);
</code></pre><h3 id="635-构造器引用">6.3.5 构造器引用</h3>
<h3 id="636-变量作用域">6.3.6 变量作用域</h3>
<h3 id="637-处理lambda表达式">6.3.7 处理lambda表达式</h3>
<ul>
<li>使用lambda表达式的重点是延迟执行（deferred execution）。毕竟，如果想要立即执行代码，完全可以直接执行，而无需吧它包装在一个lambda表达式中，之所以希望以后再执行代码，有很多原因，如：
<!-- raw HTML omitted --> 1）在一个单独的线程中运行代码；
<!-- raw HTML omitted --> 2）多次运行代码
<!-- raw HTML omitted --> 3）在算法的适当位置运行代码（例如，排序中的比较操作）；
<!-- raw HTML omitted --> 4）发生某种情况时执行代码（如，点击一个按钮，数据到达，等等）；
<!-- raw HTML omitted --> 5）旨在必要时才运行代码</li>
</ul>
<h3 id="638-再谈comparator">6.3.8 再谈Comparator</h3>
<hr>
<h2 id="64-内部类">6.4 内部类</h2>
<ul>
<li>内部类（inner class）是定义在另一个类中的类。为什么需要使用内部类呢?其主要原因有以下三点：
<!-- raw HTML omitted --> 1）内部类方法可以访问该类定义所在的作用域中的数据，包含私有的数据。
<!-- raw HTML omitted --> 2）内部类可以对同一个包中的其他类隐藏起来
<!-- raw HTML omitted --> 3）当想要定义一个回调函数且不想编写大量代码时，使用匿名（annoymous）内部类比较便捷</li>
</ul>
<h3 id="641-使用内部类访问对象状态">6.4.1 使用内部类访问对象状态</h3>
<ul>
<li>以TimerTest为例，并抽象出一个TalkingClock类。构造一个语音时钟需要提供两个参数：发布通告的间隔和开关铃声的标志。</li>
</ul>
<pre><code>public class TalkingClock {
    private int interval;
    private boolean beep;

    public TalkingClock(int interval, boolean beep) {...}
    public void start() {...}

    public class TimePrinter implements ActionListener
        // an inner class
    {
        ...
    }
}
</code></pre><ul>
<li>以下为TimePrinter类的详细内容。需要注意一点，actionPerformed方法在发出铃声之前检查了beep标志。</li>
</ul>
<pre><code>public class TimerPrinter implements ActionListener {
    public void actionPerformed(ActionEvent event) {
        System.out.println(&quot;At the tone, the time is &quot; + new Date());
        if (beep) Toolkit.getDefaultToolkit().beep();
    }
}
</code></pre><pre><code>package innerclass;



import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;

/**
 * Tis program demonstrates the use of inner classes.
 * @version 1.11 2015-05-12
 * @author Cay Horstmann
 */
public class InnerClassTest {
    public static void main(String[] args) {
        TalkingClock clock = new TalkingClock(1000, true);
        clock.start();

        // keep program running until user selects &quot;ok&quot;
        JOptionPane.showMessageDialog(null, &quot;Qui program?&quot;);
        System.exit(0);
    }
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClock {
    private int interval;
    private boolean beep;

    /**
     * Constructs a talking clock
     * @param interval the interval between messages (in milliseconds)
     * @param beep true if the clock should beep
     */
    public TalkingClock(int interval, boolean beep) {
        this.interval = interval;
        this.beep = beep;
    }

    /**
     * Starts the clock.
     */
    public void start() {
        ActionListener listener = new TimePrinter();
        Timer t = new Timer(interval, listener);
        t.start();
    }


    public class TimePrinter implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent event){
            System.out.println(&quot;At the tone, the time is &quot; + new Date());
            if (beep) {
                Toolkit.getDefaultToolkit().beep();
            }
        }
    }
}
</code></pre><h3 id="642-内部类的特殊语法规则">6.4.2 内部类的特殊语法规则</h3>
<h3 id="643-内部类是否有用必要和安全">6.4.3 内部类是否有用、必要和安全</h3>
<h3 id="644-局部内部类">6.4.4 局部内部类</h3>
<pre><code>public void start() {
    class TimePrinter implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println(&quot;At the tone, the time is &quot; + new Date());
            if (beep) {
                Toolkit.getDefaultToolkit().beep();
            }
        }
    }

    ActionListener listener = new TimePrinter();
    Timer t = new Timer(interval, listener);
    t.start();
}
</code></pre><ul>
<li>内部类有个优势，即对外部世界可以完全地隐藏起来。即使TalkingClock类中的其他代码也不能访问它。除start方法外，没有任何方法知道TimePrinter类的存在。</li>
</ul>
<h3 id="645-由外部方法访问变量">6.4.5 由外部方法访问变量</h3>
<pre><code>public void start(int interval, boolean beep) {
    class TimerPrinter implements ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println(&quot;At the tone, the time is &quot; + new Date());
                if (beep) {
                    Toolkit.getDafaultToolkit().beep();
                }
        }
    }

    ActionListener listener = new TimerPrinter();
    Timer t = new Timer(interval, listener);
    t.start();
}
</code></pre><h3 id="646-匿名内部类">6.4.6 匿名内部类</h3>
<ul>
<li>将局部内部类的使用再深入一步。假如只创建这个类的一个对象，就不必命名了，这种类被称为匿名内部类（anonymous inner class）。</li>
</ul>
<pre><code>public void start(int interval, boolean beep) {
    ActionListener listener = new ActionListener {
        public void actionPerformed(ActionEvent event) {
            System.out.println(&quot;At the tone, the time is &quot; + new Date());
            if (beep) {
                Toolkit.getDefaultToolkit().beep();
            }
        }
    };

    Timer t = new Timer(interval, beep);
    t.start();
}
</code></pre><ul>
<li>其实，目前最好用lambda表达式。例如，这一节前面给出的start方法用lambda表达式来写会简洁很多，如下：</li>
</ul>
<pre><code>public void start(int interval, boolean beep) {
    Timer t = new Timer(interval, event -&gt; {
        System.out.println(&quot;At the tone, the time is &quot; + new Date());
        if (beep) {
            Toolkit.getDefaultToolkit().beep();
        }
    });
    t.start();
}
</code></pre><ul>
<li>以下程序包含了用匿名内部类实现语音时钟程序的全部源代码。这种更加简洁，更切实际，更易于理解。</li>
</ul>
<pre><code>package annoymousinnerclass;

import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.Timer;

/**
 * This program demonstrates anoymous inner classes
 * @version 1.11 2015-05-12
 * @author Cay Horstmann
 */
public class AnonymousInnerClassTest {
    public static void main(String[] args) {
        TalkingClock clock = new TalkingClock();
        clock.start(1000, true);

        // keep program running until user selects &quot;ok&quot;
        JOptionPane.showMessageDialog(null, &quot;Quit program?&quot;);
        System.exit(0);
    }
}

/**
 * A clock that prints the time in regular intervals.
 */
class TalkingClock {
    /**
     * Starts the clock
     * @param interval the interval between messages (in millisconds)
     * @param beep true if the clock should beep
     */
    public void start(int interval, boolean beep) {
        ActionListener listener = new ActionListener(){
            @Override
            public void actionPerformed(ActionEvent event){
                System.out.println(&quot;At the tone, the time is &quot; + new Date());
                if (beep) {
                    Toolkit.getDefaultToolkit().beep();
                }
            }
        };

        Timer t = new Timer(interval, listener);
        t.start();
    }
}
</code></pre><h3 id="647-静态内部类">6.4.7 静态内部类</h3>
<hr>
<h2 id="65-代理">6.5 代理</h2>
<ul>
<li>利用代理（proxy）可以再运行时创建一个实现了一组给定接口的新类。这种功能只有在编译时无法确定需要实现哪个接口时才有必要使用。</li>
</ul>
<h3 id="651-何时使用代理">6.5.1 何时使用代理</h3>
<ul>
<li>假设由一个表示接口的Class对象（有可能只包含一个接口），它的确切类型在编译时无法知道。而代理机制则是一种更好的解决方案。代理类可以在运行时创建全新的类。这样的代理类能够实现指定的接口。尤其是，它具有以下的方法：
<!-- raw HTML omitted --> 1）指定接口所需要的全部方法。
<!-- raw HTML omitted --> 2）Object类中的全部方法，例如，toString、equals等</li>
</ul>
<h3 id="652-创建代理对象">6.5.2 创建代理对象</h3>
<ul>
<li>需要使用Proxy类的newProxyInstance方法。这个方法有三个参数：
<!-- raw HTML omitted --> 1）一个类加载器（class loader）。作为Java安全模型的一部分，对于系统类和从英特网上下载的类，可以使用不同的类加载器。有关类加载器的详细内容将在卷Ⅱ第九章讨论。目前，使用null表示使用默认的类加载器
<!-- raw HTML omitted --> 2）一个Class对象数组，每个元素都是需要实现的接口
<!-- raw HTML omitted --> 3）一个调用处理器</li>
</ul>
<pre><code>package proxy;

import java.lang.reflect.*;
import java.util.*;

/**
 * This program demonstrates the use of proxies.
 * @version 1.00 2000-04-13
 * @author Cay Horstmann
 */
public class ProxyTest {
    public static void main(String[] args) {
        Object[] elements = new Object[1000];

        // fill elements with proxies for the integers 1 ... 1000
        for (int i = 0; i &lt; elements.length; i++) {
            Integer value = i + 1;
            InvocationHandler handler = new TraceHandler(value);
            Object proxy = Proxy.newProxyInstance(null,
                    new Class[]{Comparable.class }, handler);
            elements[i] = proxy;
        }

        // construct a random integer
        Integer key = new Random().nextInt(elements.length) + 1;

        // search for the key
        int result = Arrays.binarySearch(elements, key);

        // print match if found
        if (result &gt;= 0) {
            System.out.println(elements[result]);
        }
    }
}

/**
 * An invocation handle that prints out the method name and parameters, then
 * invokes the original method
 */
class TraceHandler implements InvocationHandler {
    private Object target;

    /**
     * Construts a TraceHandler
     * @param t the implicit parameter of the method call
     */
    public TraceHandler(Object t) {
        target = t;
    }


    @Override
    public Object invoke(Object proxy, Method m, Object[] args) throws Throwable {
        // print implicit argument
        System.out.println(target);
        // print explicit arguments
        if (args != null) {
            for (int i = 0; i &lt; args.length; i++) {
                System.out.println(args[i]);
                if (i &lt; args.length - 1) {
                    System.out.println(&quot;, &quot;);
                }
            }
        }
        System.out.println(&quot;)&quot;);

        // invoke actual method
        return m.invoke(target, args);
    }
}
</code></pre><h3 id="653-代理类的特性">6.5.3 代理类的特性</h3>
<hr>
<h1 id="第7章-异常断言和日志">第7章 异常、断言和日志</h1>
<ul>
<li>如果一个用户在运行程序期间，由于程序的错误或一些外部环境的影响造成用户数据的丢失，用户就有可能不再使用这个程序。为了避免这类事情的发生，至少需要做到以下：
<!-- raw HTML omitted --> 1）向用户通告错误；
<!-- raw HTML omitted --> 2）保存所有的工作结果；
<!-- raw HTML omitted --> 3）允许用户以妥善的形式退出程序</li>
</ul>
<h2 id="71-处理错误">7.1 处理错误</h2>
<ul>
<li>假设在一个Java程序进行期间出现了一个错误。这个错误可能是由于文件包含了错误信息，或者网络连接出现问题造成，也可能是由于使用无效的数组下标，或者试图使用一个没有被赋值的对象引用而造成。用户期望在出现错误时，程序能够采用一些理智的行为。如果由于出现错误而使得某些操作没有完成，程序应该：
<!-- raw HTML omitted --> 1）返回到一种安全状态，并能够让用户执行一些其他的命令；
<!-- raw HTML omitted --> 2）允许用户保存所有操作的结果，并以妥善的方式终止程序</li>
</ul>
<h3 id="711-异常分类">7.1.1 异常分类</h3>
<ul>
<li>所有的异常都是由Throwable继承而来，但是在下一层立即分解为两个分支：Error和Exception。</li>
<li>Error类层次结构描述了Java允许时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使用程序安全地终止之外，再也无能为力了。</li>
<li>Exception层次结构。分解为两个分支：一个分支派生于RuntimeException；另一个分支包含其他异常。划分为两个分支的规则是：由于程序错误导致的异常，术语RuntimeException；而程序本身没有问题，但由于像I/O错误这类问题导致的异常属于其他异常。</li>
<li>Java语言规范将派生于Error类或RuntimeException类的所有异常称为非受查(unchecked)异常，所有其他的异常称为受查（checked）异常。</li>
</ul>
<h3 id="712-声明受查异常">7.1.2 声明受查异常</h3>
<h3 id="713-如何抛出异常">7.1.3 如何抛出异常</h3>
<h3 id="714-创建异常类">7.1.4 创建异常类</h3>
<ul>
<li>提供两个构造方法</li>
</ul>
<ol>
<li>无参的构造方法</li>
<li>带参的构造方法，并调用父类的对应的构造方法</li>
</ol>
<pre><code>    class FileFormatException extends IOexception {
        public FileFormatException() {}
        public FileFormatException(String gripe){
            super(gripe);
        }
    }
</code></pre><pre><code>package lol.hero.charactor;

public class Hero {
    public String name;
    protected float hp;

    public void attackHero(Hero h) throws EnemyHeroIsDeadException {
        if (h.hp == 0) {
            throw new EnemyHeroIsDeadException(h.name + &quot; 已经挂了，不需要施放技能 &quot;);
        }
    }

    @Override
    public String toString() {
        return name;
    }
    class EnemyHeroIsDeadException extends Exception {
        public EnemyHeroIsDeadException(){
        }
        public EnemyHeroIsDeadException(String msg) {
            super(msg);
        }
    }

    public static void main(String[] args) {

        Hero garen = new Hero();
        garen.name = &quot;盖伦&quot;;
        garen.hp = 616;

        Hero teemo = new Hero();
        teemo.name = &quot;提莫&quot;;
        teemo.hp = 0;

        try {
            garen.attackHero(teemo);
        }
        catch (EnemyHeroIsDeadException e) {
            // TODO Auto-generated catch block
            System.out.println(&quot;异常的具体原因：&quot; + e.getMessage());
            e.printStackTrace();
        }
    }
}
</code></pre><hr>
<h2 id="72-捕获异常">7.2 捕获异常</h2>
<h3 id="721-捕获异常">7.2.1 捕获异常</h3>
<pre><code>public void read(String filename) {
    try {
        InputStream in = new FileInputStream(filename);
        int b;
        while ((b = in.read()) != -1) {
            process input
        }
    }
    catch (IOExcption exception) {
        exception.printStackTrace();
    }
}
</code></pre><h3 id="722-捕获多个异常">7.2.2 捕获多个异常</h3>
<ul>
<li>在一个try语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。可以 按照以下方式为每个异常类型使用一个单独的catch子句：</li>
</ul>
<pre><code>try {
    code that might throw exceptions
} catch (FileNotFoundException e) {
    emergency action for missing files
} catch (UnknownHostException e) {
    emergency action for unknown hosts
} catch (IOException e) {
    emergency action for all other I/O problems
}
</code></pre><h3 id="723-再次抛出异常与异常链">7.2.3 再次抛出异常与异常链</h3>
<ul>
<li>在catch子句中可以抛出一个异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用的子系统，那么，用于表示子系统故障的异常类型可能会产生多种解释。ServletException就是这样一个异常类型的例子。执行servlet的代码可能不想知道发生错误的细节原因，但希望明确地知道servlet是否有问题。</li>
</ul>
<pre><code>try {
    access the database
} catch (SQLExcepton e) {
    throw new ServletException(&quot;database error:&quot; + e.getMessage());
}
</code></pre><ul>
<li>这里，ServleException用带有异常信息文本的构造器来构造。</li>
</ul>
<pre><code>try {
    access the database
} catch (SQLException e) {
    Throwable se = new ServletException(&quot;database error&quot;);
    se.initCause(e);
    throw se;
}
</code></pre><h3 id="724-finally-子句">7.2.4 finally 子句</h3>
<h3 id="725-带资源的try语句">7.2.5 带资源的try语句</h3>
<h3 id="726-分析堆栈轨迹元素">7.2.6 分析堆栈轨迹元素</h3>
<ul>
<li>堆栈轨迹（stack trace）是一个方法调用过程的列表，它包含了程序执行过程中方法调用的特定位置。可以调用Throwable类的printStackTrace方法访问堆栈轨迹的文本描述信息。</li>
</ul>
<pre><code>    Throwable t = new Throwable();
    StringWriter out = new StringWriter();
    t.printStackTrace(new PrintWrinter(out));
    String descriprion = out.toString();
</code></pre><pre><code>package stacktrace;

import com.sun.tracing.dtrace.ArgsAttributes;
import jdk.management.resource.internal.inst.FileOutputStreamRMHooks;
import org.omg.PortableInterceptor.SYSTEM_EXCEPTION;

import java.util.*;

/**
 * A program that displays a trace feature of a resursive method call.
 * @version 1.01 2004-05-10
 * @author Cay Horstmann
 */
public class StackTraceTest {
    /**
     * Computes the factorial of a number
     * @param n a non-negative integer
     * @rerurn n! = 1 * 2 * ... *n
     */
    public static int factorial(int n) {
        System.out.println(&quot;factorial(&quot; + n + &quot;):&quot;);
        Throwable t = new Throwable();
        StackTraceElement[] frames = t.getStackTrace();
        for (StackTraceElement f : frames) {
            System.out.println(f);
        }
        int r;
        if (n &lt;= 1) {
            r = 1;
        } else {
            r = n * factorial(n - 1);
        }
        System.out.println(&quot;return &quot; + r);
        return r;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.print(&quot;Enter n: &quot;);
        int n = in.nextInt();
        factorial(n);
    }
}
</code></pre><hr>
<h2 id="73-使用异常机制的技巧">7.3 使用异常机制的技巧</h2>
<ol>
<li>异常处理不能代替简单的测试</li>
<li>不要过分地细化异常</li>
<li>利用异常层次结构</li>
<li>不要压制异常</li>
<li>在检测错误时，“苛刻”要比放任更好</li>
<li>不要羞于传递异常</li>
</ol>
<hr>
<h2 id="74-使用断言">7.4 使用断言</h2>
<h3 id="741-断言的概念">7.4.1 断言的概念</h3>
<ul>
<li>断言机制允许在测试期间向代码中插入一些检查语句。当代码发布时，这些插入的检测语句会被自动地移除。Java语言中引入关键字assert。这个关键字有两种形式：</li>
<li>assert 条件 ；</li>
<li>assert 条件 ：(表达式) ；</li>
</ul>
<h3 id="742-启动和禁用断言">7.4.2 启动和禁用断言</h3>
<ul>
<li>默认情况下，断言被禁用。可以在运行程序时用-enableassertions或 -ea选项启用：</li>
</ul>
<pre><code>    java - enableassertions MyApp
</code></pre><ul>
<li>也可以在某个类或者整个包中使用断言，例如：</li>
</ul>
<pre><code>    java -ea:MyClass -ea:com.mysompany.mylib...MyApp
</code></pre><h3 id="743-使用断言完成参数检查">7.4.3 使用断言完成参数检查</h3>
<h3 id="744-为文档假设使用断言">7.4.4 为文档假设使用断言</h3>
<hr>
<h2 id="75-记录日志">7.5 记录日志</h2>
<h3 id="751-基本日志">7.5.1 基本日志</h3>
<ul>
<li>要生成简单的日志记录，可以使用全局日志记录器(global logger) 并调用其info方法；</li>
</ul>
<pre><code>    Logger.getGlobal().info(&quot;File-&gt;Open menu item selected&quot;);

</code></pre><ul>
<li>默认情况下，这条记录将会显示以下内容</li>
</ul>
<pre><code>    三月 25, 2020 3:47:00 下午 stacktrace.StackTraceTest main
    信息: File-&gt;Open menu item selected

</code></pre><ul>
<li>但是，如果在适当的地方（如main开始）调用，将取消所有日志</li>
</ul>
<pre><code>    Logger.getGlobal().setLevel(level.OFF);
</code></pre><h3 id="752-高级日志">7.5.2 高级日志</h3>
<ul>
<li>从前面已经看到“虚拟日志”，下面继续看一下企业级（industrial-strength）日志。在一个专业的应用程序中，不要将所有的日志都记录到一个全局日志记录器中，而是可以自定义日志记录器。</li>
<li>可以调用getLogger方法创建或获取记录器：</li>
</ul>
<pre><code>private static final Logger myLogger = Logger.getLogger(&quot;com.mycompany.myapp&quot;);
</code></pre><ul>
<li>通常由7个日志记录器级别：</li>
</ul>
<ol>
<li>SEVERE</li>
<li>WARNING</li>
<li>INFO</li>
<li>CONFIG</li>
<li>FINE</li>
<li>FINER</li>
<li>FINEST</li>
</ol>
<ul>
<li>对于所有的级别有以下几种记录方法：</li>
</ul>
<pre><code>    logger.warning(meaasge);
    logger.fine(message);
</code></pre><h3 id="753-修改日志管理器配置">7.5.3 修改日志管理器配置</h3>
<h3 id="754-本地化">7.5.4 本地化</h3>
<h3 id="755-处理器">7.5.5 处理器</h3>
<h3 id="756-过滤器">7.5.6 过滤器</h3>
<h3 id="757-格式化器">7.5.7 格式化器</h3>
<h3 id="758-日志记录说明">7.5.8 日志记录说明</h3>
<pre><code>package logging;

import com.sun.javafx.stage.WindowCloseRequestHandler;
import com.sun.org.apache.xerces.internal.impl.dv.xs.AbstractDateTimeDV;
import jdk.internal.org.objectweb.asm.Handle;

import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.util.logging.*;
import javax.swing.*;

/**
 * A modification of the image viewer program that logs various events.
 * @version 1.03 2015-08-20
 * @author Cay Horstmann
 */
public class LoggingImageViewer {
    public static void main(String[] args) {
        if (System.getProperty(&quot;java.util.logging.config.class&quot;) == null
                &amp;&amp; System.getProperty(&quot;java.util.logging.config.file&quot;) == null) {
            try {
                Logger.getLogger(&quot;com.horstmann.corejava&quot;).setLevel(Level.ALL);
                final int LOG_ROTATION_COUNT = 10;
                Handler handler = new FileHandler(&quot;%h/LoggingImageViewer.log&quot;, 0, LOG_ROTATION_COUNT);
                Logger.getLogger(&quot;com.horstmann.corejava&quot;).addHandler(handler);
            } catch (IOException e) {
                Logger.getLogger(&quot;com.horstmann.corejava&quot;).log(Level.SEVERE,
                        &quot;Can't create log file handler&quot;, e);
            }
        }
        EventQueue.invokeLater(() -&gt; {
            Handler windowHandler = new WindowHandler();
            windowHandler.setLevel(Level.ALL);
            Logger.getLogger(&quot;com.horstmann.corejava&quot;).addHandler(windowHandler);

            JFrame frame = new ImageViewerFrame();
            frame.setTitle(&quot;LoggingImageViewer&quot;);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

            Logger.getLogger(&quot;com.horstmann.corejava&quot;).fine(&quot;Showing frame&quot;);
            frame.setVisible(true);
        });
    }
}

/**
 * The frame that shows the image.
 */
class ImageViewerFrame extends JFrame {
    private static final int DEFAULT_WIDTH = 300;
    private static final int DEFAULT_HEIGHT = 400;

    private JLabel label;
    private static Logger logger = Logger.getLogger(&quot;com.horstmann.corejava&quot;);

    public ImageViewerFrame() {
        logger.entering(&quot;ImageViewerFrame&quot;, &quot;&lt;init&gt;&quot;);
        setSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);

        // set up menu bar
        JMenuBar menuBar = new JMenuBar();
        setJMenuBar(menuBar);

        JMenu menu = new JMenu(&quot;File&quot;);
        menuBar.add(menu);

        JMenuItem openItem = new JMenuItem(&quot;Open&quot;);
        menu.add(openItem);
        openItem.addActionListener(new FileOpenListener());

        JMenuItem exitItem = new JMenuItem(&quot;Exit&quot;);
        menu.add(exitItem);
        exitItem.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent event) {
                logger.fine(&quot;Exiting.&quot;);
                System.exit(0);
            }
        });
        // use a label to display the images
        label = new JLabel();
        add(label);
        logger.exiting(&quot;ImageViewerFrame&quot;, &quot;&lt;init&gt;&quot;);
    }

    private class FileOpenListener  implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent event) {
            logger.entering(&quot;ImageViewerFrame.FileOpenListener&quot;, &quot;actionPerformed&quot;, event);

            // set up file chooser
            JFileChooser chooser = new JFileChooser();
            chooser.setCurrentDirectory(new File(&quot;.&quot;));

            // accept all files ending with .gif
            chooser.setFileFilter(new javax.swing.filechooser.FileFilter() {
                @Override
                public boolean accept(File f) {
                    return f.getName().toLowerCase().endsWith(&quot;.gif&quot;) || f.isDirectory();
                }

                @Override
                public String getDescription() {
                    return &quot;CIF Images&quot;;
                }
            });

            // show file chooser dialog
            int r = chooser.showOpenDialog(ImageViewerFrame.this);

            // if image file accepted, set it as icon of the label
            if (r == JFileChooser.APPROVE_OPTION) {
                String name = chooser.getSelectedFile().getPath();
                logger.log(Level.FINE, &quot;Reading file {0}&quot;, name);
                label.setIcon(new ImageIcon(name));
            } else {
                logger.fine(&quot;File open dialog canceled.&quot;);
            }
            logger.exiting(&quot;ImageViewerFrame.FileOpenListener&quot;, &quot;actionPerformed&quot;);
        }
    }
}

/**
 * A handler for displaying log records in a window.
 */
class WindowHandler extends StreamHandler {
    private JFrame frame;

    public WindowHandler() {
        frame = new JFrame();
        final JTextArea output = new JTextArea();
        output.setEditable(false);
        frame.setSize(200, 200);
        frame.add(new JScrollPane(output));
        frame.setFocusableWindowState(false);
        frame.setVisible(true);
        setOutputStream(new OutputStream() {
            @Override
            public void write(int b) {
            } // not called

            @Override
            public void write(byte[] b, int off, int len) {
                output.append(new String(b, off, len));
            }
        });
    }

    @Override
    public void publish(LogRecord record) {
        if (!frame.isVisible()) {
            return ;
        }
        super.publish(record);
        flush();
    }
}
</code></pre><hr>
<h2 id="76-调试技巧">7.6 调试技巧</h2>
<ul>
<li>1）可以使用下面的方法打印或记录任何变量的值：</li>
</ul>
<pre><code>    System.out.println(&quot;x=&quot; + x);
    // 或者
    Logger.getGlobal().info(&quot;x=&quot; + x);
    // 获取隐形参数对象的状态
    Logger.getGlobal().info(&quot;this=&quot; + this);
</code></pre><ul>
<li>2）一个有效的方法，在每个类中放置一个单独的main方法</li>
</ul>
<pre><code>    public class MyClass {
        methods and fields
        ...
        public static void main(String[] args) {
            test code
        }
    }
</code></pre><ul>
<li>
<ol start="3">
<li>在http://junit.org 网站中可以查看JUnit。它是一个单元测试框架</li>
</ol>
</li>
<li>4）日志代理(logging proxy)是一个子类的对象，它可以截获方法调用，并进行日志记录，然后调用超类中的方法。例如，如果在调用Random类的nextDouble方法时出现问题，以匿名子类实例的形式创建一个代理对象：</li>
</ul>
<pre><code>    Random generator = new
        Random() {
            public double nextDouble() {
                double result = super.nextDouble();
                Logger.getGlobal().info(&quot;nextDouble: &quot; + result);
                return result;
            }
        }
</code></pre><ul>
<li>
<ol start="5">
<li>利用Throwable 类提供的printStackTrace方法，可以从任何一个异常对象中获得堆栈情况。下面的代码将捕获任何异常，打印异常对象和堆栈轨迹，然后，重新抛出异常，以便能够找到相应的处理器。</li>
</ol>
</li>
</ul>
<pre><code>    try {
        ...
    } catch (Throwable t) {
        t.prinStackTrace();
        throw t;
    }
</code></pre><p><!-- raw HTML omitted --> 不一定要通过捕获异常来生成堆栈轨迹。只要在代码的任何位置插入下面语句，既可获得</p>
<pre><code>   Thread.dumpStack();
</code></pre><ul>
<li>
<ol start="6">
<li>一般来说，堆栈堆积显示在System.err上，也可以利用printStackTrace（PrintWriter s）方法将它发送到一个文件中，另外，如果想记录或显示堆栈轨迹，可以采用以下方法：</li>
</ol>
</li>
</ul>
<pre><code>    StringWriter out = new StringWriter();
    new Throwable().printStackTrace(new PrintWrinter(out));
    String description = out.toString();
</code></pre><ul>
<li>
<ol start="7">
<li>通常，将一个程序中的错误信息保存在一个文件中是非常有用的。然而，错误信息被发送到System.err中，而不是System.out中。因此，不能通过运行下面的语句获取它们：</li>
</ol>
</li>
</ul>
<pre><code>    java MyProgram &gt; errors.txt
</code></pre><p><!-- raw HTML omitted --> 而是采用下面的方法捕获错误流：</p>
<pre><code>    java MyProgram 2&gt; errors.txt
</code></pre><p><!-- raw HTML omitted --> 想要在同一个文件中同时捕获System.err和System.out,需要使用下面这条命令</p>
<pre><code>    java MyProgram 1&gt; errors.txt 2&gt;&amp;1
</code></pre><ul>
<li>
<ol start="8">
<li>可以调用静态的Thread.setDefaultUncaughtExceptionHandler方法改变非捕获异常的处理器：</li>
</ol>
</li>
</ul>
<pre><code>    Thread.setDefaultUncaughtExceptionHandler(
        new Thread.UncaughtExceptionHandler() {
            public void uncaughtException(Thread t, Throwable e) {
                save information in log file
            };
        }
    );
</code></pre><ul>
<li>
<ol start="9">
<li>想要观察类的加载过程，可以使用 -verbose标志启动java虚拟机</li>
</ol>
</li>
<li>
<ol start="10">
<li>-Xlint选项告诉编译器对一些普通容易出现的代码问题进行检查。</li>
</ol>
</li>
</ul>
<pre><code>    javac -Xlint:fallthrogh
</code></pre><ul>
<li>
<ol start="11">
<li>Java虚拟机增加了对Java应用程序进行监控（monitoring）和管理（management）的支持。</li>
</ol>
</li>
</ul>
<pre><code>    jconsole processID
</code></pre><ul>
<li>12）可以使用jmap实用工具获得一个堆的转储，其中显示了堆中的每个对象。使用命令如下：</li>
</ul>
<pre><code>    jmap -dump:format=b, file=dumpFileName processID
    jhat dumFileName
</code></pre><p><!-- raw HTML omitted --> 然后，通过浏览器进入localhost：7000，将会运行一个网络应用程序，借此探查转储对象时堆的内容。</p>
<ul>
<li>13）如果使用-Xprof标志运行Java虚拟机，就会运行一个基本的剖析器来跟踪哪些代码中经常被调用的方法。剖析信息将发送给System.out。输出结果中还会显示哪些方法是有即使编译器编译的。</li>
</ul>
<hr>
<h1 id="第8章-泛型程序设计">第8章 泛型程序设计</h1>
<h2 id="81-为什么要使用泛型程序设计">8.1 为什么要使用泛型程序设计</h2>
<ul>
<li>泛型程序设计（Generic programming）意味着编写的代码可以被很多不同类型的对象所重用。</li>
</ul>
<h3 id="811-类型参数的好处">8.1.1 类型参数的好处</h3>
<ul>
<li>在java中增加范型类之前，泛型程序设计是用来继承实现的。ArrayList类只维护一个Object引用的数组：</li>
</ul>
<pre><code>    // before generic classes
    public class ArrayList {
        ...
        public Object get(int i) {...}
        public void add(Object o) {...}
    }
</code></pre><ul>
<li>泛型提供了一个更好的解决方案：类型参数（type parameters）。ArrayList类有一个类型参数用来指示元素的类型：</li>
</ul>
<pre><code>    ArrayList&lt;String&gt; files = new ArrayList&lt;String&gt;();
</code></pre><ul>
<li>类型参数的魅力在于：使得程序具有更好的可读性和安全性。</li>
</ul>
<h3 id="812-谁想成为泛型程序员">8.1.2 谁想成为泛型程序员</h3>
<hr>
<h2 id="82-定义简单泛型类">8.2 定义简单泛型类</h2>
<ul>
<li>一个泛型类（generic class）就是具有一个或多个类型变量的类。</li>
</ul>
<pre><code>    public class Pair&lt;T&gt; {
        private T first;
        private T second;

        public Pair() { 
            first = null;
            second = null;
        }
        public Pair(T first, T second) {
            this.first = first;
            this.second = second;
        }

        public T getFirst() {
            return first;
        }
        public T getSecond() {
            return second;
        }

        public void setFirst(T newValue) {
            first = newValue;
        }
        public void setSecond(T newValue) {
            second = newValue;
        }
    }
</code></pre><ul>
<li>类型便使用大写形式，且比较短，这很常见。在Java库中，使用变量E表示集合的元素类型，K和V分别表示表的关键字与值的类型。T（需要时还可以使用临近的字幕U和S）表示“任何类型”</li>
</ul>
<hr>
<pre><code>package pair1;

/**
 * @version 1.01 2012-01-26
 * @author Cay Horstmann
 */
public class PairTest1 {
    public static void main(String[] args) {
        String[] words = { &quot;Mary&quot;, &quot;had&quot;, &quot;a&quot;, &quot;little&quot;, &quot;lamb&quot;};
         Pair&lt;String&gt; mm = ArrayAlg.minmax(words);
        System.out.println(&quot;min = &quot; + mm.getFirst());
        System.out.println(&quot;max = &quot; + mm.getSecond());
    }
}

class ArrayAlg {
    /**
     * Gets the minimun and maximum of an array of strings
     * @param a an array of strings
     * @return a pair with the min and max value, or null if a is null or empty
     */
    public static Pair&lt;String&gt; minmax(String[] a) {
        if (a == null || a.length == 0) {
            return null;
        }
        String min = a[0];
        String max = a[0];
        for (int i = 1; i &lt; a.length;i++) {
            if (min.compareTo(a[i]) &gt; 0) {
                min = a[i];
            }
            if (max.compareTo(a[i]) &lt; 0) {
                max = a[i];
            }
        }
        return new Pair&lt;&gt;(min, max);
    }
}
</code></pre><h2 id="83-泛型方法">8.3 泛型方法</h2>
<ul>
<li>实际上，还可以定义一个带有类型参数的简单方法。</li>
</ul>
<pre><code>class ArrayAlg {
    public static &lt;T&gt; T getMiddle(T...a) {
        return a[a.length / 2];
    }
}
</code></pre><hr>
<h2 id="84-类型变量的限定">8.4 类型变量的限定</h2>
<ul>
<li>有时，类或方法需要对类型变量加以约束。</li>
</ul>
<pre><code>    class ArrayAlg {
        public staic &lt;T&gt; T min(T[] a) {
            if (a == null || a.length == 0) {
                return null;
            }
            T smallest = a[0];
            for (int i = 1; i &lt; a.length; i++) {
                if (smallest.compareTo(a[i]) &gt; 0) {
                    smallest = a[i];
                }
            }
            return smallest;
        }
    }
</code></pre><ul>
<li>变量smallest类型为T，这意味着它可以时任何一个类的对象。怎样才能确信T所属的类有compareTo方法？</li>
<li>解决这个问题的方案是将T限制为实现了Comparable接口（只含一个方法comparaTo的标准接口）的类。可以通过对类型变量设置限定实现这一点。</li>
</ul>
<pre><code>    public statci &lt;T extends Comparable&gt; T min(T[] a)...
</code></pre><pre><code>package pair2;


import pair1.Pair;

import java.time.*;

/**
 * @version 1.02 2015-06-21
 * @author Cay Horstmann
 */
public class PairTest2 {
    public static void main(String[] args) {
        LocalDate[] birthdays =
                {
                        // G. Hopper
                        LocalDate.of(1906, 12, 9),
                        // A. Lovelace
                        LocalDate.of(1815, 12, 10),
                        // J. von Neumann
                        LocalDate.of(1903, 12, 3),
                        // K. Zuse
                        LocalDate.of(1910, 6, 22)
                };
        Pair&lt;LocalDate&gt; mm = ArrayAlg.minmax(birthdays);
        System.out.println(&quot;min = &quot; + mm.getFirst());
        System.out.println(&quot;max = &quot; + mm.getSecond());
    }
}

class ArrayAlg {
    /**
     Gets the minimum and maximum of an array of objects of type T.
     * @param a an array of objects of type T
     * @param a pair with the min and max value, or null if a is null or empty
     */
    public static &lt;T extends Comparable&gt; Pair&lt;T&gt; minmax(T[] a) {
        if (a == null || a.length == 0) {
            return null;
        }
        T min = a[0];
        T max = a[0];
        for (int i = 1; i &lt; a.length; i++) {
            if (min.compareTo(a[i]) &gt; 0) {
                min = a[i];
            }
            if (max.compareTo(a[i]) &lt; 0) {
                max = a[i];
            }
        }
        return new Pair&lt;&gt;(min, max);
    }
}
</code></pre><hr>
<h2 id="85-泛型代码和虚拟机">8.5 泛型代码和虚拟机</h2>
<h3 id="851-类型擦除">8.5.1 类型擦除</h3>
<h3 id="852-翻译泛型表达式">8.5.2 翻译泛型表达式</h3>
<h3 id="853-翻译泛型方法">8.5.3 翻译泛型方法</h3>
<h3 id="854-调用遗留代码">8.5.4 调用遗留代码</h3>
<hr>
<h2 id="86-约束与局限性">8.6 约束与局限性</h2>
<h3 id="861-不能用基本类型实例化类型参数">8.6.1 不能用基本类型实例化类型参数</h3>
<h3 id="862-运行时类型查询只适用于原始类型">8.6.2 运行时类型查询只适用于原始类型</h3>
<h3 id="863-不能创建参数化类型的数组">8.6.3 不能创建参数化类型的数组</h3>
<h3 id="864-varargs警告">8.6.4 Varargs警告</h3>
<h3 id="865-不能实例化类型变量">8.6.5 不能实例化类型变量</h3>
<h3 id="866-不能构造泛型数组">8.6.6 不能构造泛型数组</h3>
<h3 id="867-泛型类的静态上下文中类型变量无效">8.6.7 泛型类的静态上下文中类型变量无效</h3>
<h3 id="868-不能抛出或捕获泛型类的实例">8.6.8 不能抛出或捕获泛型类的实例</h3>
<h3 id="869-可以消除对受查异常的检查">8.6.9 可以消除对受查异常的检查</h3>
<h3 id="8610-注意擦除后的冲突">8.6.10 注意擦除后的冲突</h3>
<hr>
<h2 id="87-泛型类型的继承规则">8.7 泛型类型的继承规则</h2>
<hr>
<h2 id="88-通配符类型">8.8 通配符类型</h2>
<pre><code>package pair3;

import pair1.Pair;
import equals.Employee;
import equals.Manager;

/**
 * @version 1.01 2012-01-26
 * @author Cay Horstmann
 */
public class PairTest3 {
    public static void main(String[] args) {
        Manager ceo = new Manager(&quot;Gus Greedy&quot;, 800000, 2003, 12, 15);
        Manager cfo = new Manager(&quot;Sid Sneaky&quot;, 600000, 2003, 12, 15);
        Pair&lt;Manager&gt; buddies = new Pair&lt;&gt;(ceo, cfo);
        printBuddies(buddies);

        ceo.setBonus(1000000);
        cfo.setBonus(500000);
        Manager[] managers = { ceo, cfo };

        Pair&lt;Employee&gt; result = new Pair&lt;&gt;();
        minmaxBonus(managers, result);
        System.out.println(&quot;first: &quot; + result.getFirst().getName()
                + &quot;, second: &quot; + result.getSecond().getName());
    }

    public static void printBuddies(Pair&lt;? extends Employee&gt; p) {
        Employee first = p.getFirst();
        Employee second = p.getSecond();
        System.out.println(first.getName() + &quot; and &quot; + second.getName() + &quot; are buddies.&quot;);
    }

    public static void minmaxBonus(Manager[] a, Pair&lt;? super Manager&gt; result) {
        if (a.length == 0) {
            return;
        }
        Manager min = a[0];
        Manager max = a[0];
        for (int i = 1; i &lt; a.length; i++) {
            if (min.getBonus() &gt; a[i].getBonus()) {
                min = a[i];
            }
            if (max.getBonus() &lt; a[i].getBonus()) {
                max = a[i];
            }
        }
        result.setFirst(min);
        result.setSecond(max);
    }

    public static void maxminBonus(Manager[] a, Pair&lt;? super Manager&gt; result) {
        minmaxBonus(a, result);
        PairAlg.swapHelper(result); // OK--wapHelper caputes wildcard type
    }
}

class PairAlg {
    public static boolean hasNulls(Pair&lt;?&gt; p) {
        return p.getFirst() == null || p.getSecond() == null;
    }

    public static void swap(Pair&lt;?&gt; p) {
        swapHelper(p);
    }

    public static &lt;T&gt; void swapHelper(Pair&lt;T&gt; p) {
        T t = p.getFirst();
        p.setFirst(p.getSecond());
        p.setSecond(t);
    }
}
</code></pre><hr>
<h2 id="89-反射和泛型">8.9 反射和泛型</h2>
<h3 id="891-泛型class类">8.9.1 泛型Class类</h3>
<h3 id="892-使用classt参数进行类型匹配">8.9.2 使用Class<!-- raw HTML omitted -->参数进行类型匹配</h3>
<h3 id="893-虚拟机中的泛型类型信息">8.9.3 虚拟机中的泛型类型信息</h3>
<hr>
<h1 id="第9章-集合">第9章 集合</h1>
<h2 id="91-java集合框架">9.1 Java集合框架</h2>
<h3 id="911-将集合的接口与实现分离">9.1.1 将集合的接口与实现分离</h3>
<h3 id="912-collection接口">9.1.2 Collection接口</h3>
<ul>
<li>在Java类库中，集合类的基本接口是Collection接口。这个接口有两个基本方法：</li>
</ul>
<pre><code>    public interface Collection&lt;E&gt; {
        boolean add(E element);
        Iterator&lt;E&gt; interator();
        ...
    }
</code></pre><h3 id="913-迭代器">9.1.3 迭代器</h3>
<ul>
<li>Iterator接口包含了4个方法：</li>
</ul>
<pre><code>    public interface Iterator&lt;E&gt; {
        E next();
        boolean hasNext();
        void remove();
        default void forEachRemaining(Consumer&lt;? super E&gt; action);
    }
</code></pre><h3 id="914-泛型实用方法">9.1.4 泛型实用方法</h3>
<ul>
<li>由于Collection和Iterator都是泛型接口，可以编写操作任何集合类型的实用方法。例如，下面是一个检测任意集合是否包含指定元素的泛型方法：</li>
</ul>
<pre><code>    public static &lt;E&gt; boolean contains(Collection&lt;E&gt; c, Object obj) {
        for (E element : c) {
            if (element.equals(obj)) {
                return true;
            }
        }
        return false;
    }
</code></pre><h3 id="915-集合框架中的接口">9.1.5 集合框架中的接口</h3>
<ul>
<li>集合中有两个基本接口：Collection和Map。</li>
<li>List：一种有序列表的集合，例如，按索引排列的Student的List；</li>
<li>Set：一种保证没有重复元素的集合，例如，所有无重复名称的Student的Set；</li>
<li>Map：一种通过键值（key-value）查找的映射表集合，例如，根据Student的name查找对应Student的Map。</li>
</ul>
<hr>
<h2 id="92-具体的集合">9.2 具体的集合</h2>
<h3 id="921-链表">9.2.1 链表</h3>
<ul>
<li>有数组以及动态的ArrayList类的情况下，为何还要引入链表（linked list）。因为，数组和数组列表都有一个重大的缺陷。就是从数组的中间位置删除一个元素需要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前端移动。</li>
<li>数组在连续的存储位置上存放对象应用，但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java程序设计语言中，所有链表实际上都是双向链接的（doubly linked）&ndash;即每个结点都存放着指向前驱结点的引用。</li>
<li>ListIterator接口有两个方法，可以用来反向遍历链表</li>
</ul>
<pre><code>    E previous()
    boolean hasPrevious()
</code></pre><h3 id="922-数组列表">9.2.2 数组列表</h3>
<ul>
<li>List接口用于描述一个有序集合，并且集合中每个元素的位置十分重要。有两种访问元素的协议：一种是用迭代器，另一种是用get和set方法随机地访问每个元素。后者不适合用于链表，但对数组却很有用。集合类库提供了一种大家熟悉的ArrayList类，这个类也实现了List接口。ArrayList封装了一个动态再分配的对象数组。</li>
</ul>
<h3 id="923-散装集">9.2.3 散装集</h3>
<ul>
<li>有一种众所周知的数据结构，可以快速地查找所需的对象，这就是散列表（hash table）。散列表为每个对象计算一个整数，称为散列码（hash code）。散列码是由对象的实例域产生的一个整数。更为准确地说，具有不同数据域的对象将产生不同的散装码。</li>
</ul>
<h3 id="924-树集">9.2.4 树集</h3>
<ul>
<li>TreeSet类与散列集十分相似，不过，它比散列集有所改进，树集是一个有序集合（sorted collection）。可以以任意顺序将元素插入到集合中。在对集合遍历时，每个值将自动地按照排序后的顺序呈现。</li>
</ul>
<pre><code>    SortedSet&lt;String&gt; sorter = new TreeSet&lt;&gt;();
    sorter.add(&quot;Bob&quot;);
    sorter.add(&quot;Amy&quot;);
    sorter.add(&quot;Carl&quot;);
    for (String s : sorter) {
        System.out.println(s);
    }
</code></pre><pre><code>package treeSet;

import java.util.*;

/**
 * This program sorts a set of item by comparing their descriptions.
 * @version 1.12 2015-06-21
 * @author Cay Horstmann
 */
public class TreeSetTest {
    public static void main(String[] args) {
        SortedSet&lt;Item&gt; parts = new TreeSet&lt;&gt;();
        parts.add(new Item(&quot;Toaster&quot;, 1234));
        parts.add(new Item(&quot;Widget&quot;, 4562));
        parts.add(new Item(&quot;Modem&quot;, 9912));
        System.out.println(parts);

        NavigableSet&lt;Item&gt; sortByDescription = new TreeSet&lt;&gt;(
                Comparator.comparing(Item::getDescription)
        );
        sortByDescription.addAll(parts);
        System.out.println(sortByDescription);
    }
}
</code></pre><pre><code>package treeSet;

import java.util.Objects;

/**
 * An item with a description and a part number.
 */
public class Item implements Comparable&lt;Item&gt;{
    private String description;
    private int partNumber;

    /**
     * Constructs an item.
     *
     * @param aDescription
     *          the item's description
     * @param aPartNumber
     *          the item's part number
     */
    public Item(String aDescription, int aPartNumber) {
        description = aDescription;
        partNumber = aPartNumber;
    }

    /**
     * Gets the description of this item.
     *
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    @Override
    public String toString() {
        return &quot;[description=&quot; + description + &quot;. partNumber=&quot; + partNumber + &quot;]&quot;;
    }

    @Override
    public boolean equals(Object otherObject) {
        if (this == otherObject) {
            return true;
        }
        if (otherObject == null) {
            return false;
        }
        if (getClass() != otherObject.getClass()) {
            return false;
        }
        Item other = (Item) otherObject;
        return Objects.equals(description, other.description)
                &amp;&amp; partNumber == other.partNumber;
    }

    @Override
    public int compareTo(Item other) {
        int diff = Integer.compare(partNumber, other.partNumber);
        return diff != 0 ? diff : description.compareTo(other.description);
    }
}
</code></pre><h3 id="925-队列与双端队列">9.2.5 队列与双端队列</h3>
<ul>
<li>队列可以让人们有效地在尾部添加一个元素，在头部删除一个元素。由两个端头的队列，即双端队列，可以让人们有效地在头部和尾部同时添加或删除元素。不支持在队列中间添加元素。在Java SE 6中引入了Deque接口，并由ArrayDeque和Linkedlist类实现。</li>
</ul>
<h3 id="926-优先级队列">9.2.6 优先级队列</h3>
<ul>
<li>优先级队列（priority queue）中的元素可以按照任意的顺序插入，却总是按照排序的顺序进行检索。也就是说，无论何时调用remove方法，总会获得当前优先级队列中最小的元素。然而，优先级队列并没有对所有的元素进行排序。如果用迭代的方法处理这些元素，并不需要对它们进行排序。优先级队列使用了一个优雅且搞笑的数据结构，称为堆（heap）。堆时一个可以自我调整的二叉树，对树执行添加（add）和删除（remove）操作，可以让最小的元素移动到根，而不必花费时间对元素进行排序。</li>
<li>与TreeSet一样，一个优先级队列既可以保存实现了Comparable接口的类对象，也可以保存在构造器中提供的Comparator对象</li>
</ul>
<pre><code>package prioritQueue;

import java.time.LocalDate;
import java.util.PriorityQueue;

/**
 * This program demonstrates the use of a priority queue.
 * @version 1.01 2012-01-26
 * @author Cay Horstmann
 */
public class PriorityQueueTest {
    public static void main(String[] args) {
        PriorityQueue&lt;LocalDate&gt; pq = new PriorityQueue&lt;&gt;();
        pq.add(LocalDate.of(1906, 12, 9));
        // G. Hopper
        pq.add(LocalDate.of(1815, 12, 10));
        // A. Lovelace
        pq.add(LocalDate.of(1903, 12, 3));
        // J. von Neumann
        pq.add(LocalDate.of(1910, 6, 32));
        // K. Zuse

        System.out.println(&quot;Iterating over elements...&quot;);
        for (LocalDate date : pq) {
            System.out.println(date);
        }
        System.out.println(&quot;Removing elements...&quot;);
        while (!pq.isEmpty()) {
            System.out.println(pq.remove());
        }
    }
}

</code></pre><hr>
<h2 id="93-映射">9.3 映射</h2>
<h3 id="931-基本映射操作">9.3.1 基本映射操作</h3>
<ul>
<li>Java类库为映射提供了两个通用的实现：HashMap和TreeMap。这两个类都实现了Map接口。</li>
<li>散列映射对键进行散列，树映射用键的整体顺序对元素进行排序，并将其组织成搜索树。散列或比较函数只能作用于键。与键关联的值不能进行散列或比较。</li>
<li>下面代码将为存储的员工信息建立一个散列映射：</li>
</ul>
<pre><code>    Map&lt;String, Employee&gt; staff = new HashMap&lt;&gt;(); //HashMap implements Map 
    Employee harry = new Employee(&quot;Harry Hacker&quot;);
    staff.put(&quot;987-98-9996&quot;, harry);
</code></pre><ul>
<li>要迭代处理映射的键和值，最容易的方法时使用forEach方法。可以提供一个接受键和值的lambda表达式。映射中的每一项会依序调用这个表达式 。</li>
</ul>
<pre><code>    scores.forEach(K, v) -&gt;
        System.out.println(&quot;key=&quot; + k + &quot;, value=&quot; + v);
</code></pre><pre><code>package map;

import java.util.HashMap;
import java.util.Map;

/**
 * This program demonstrates the use of a map with key type String and value type Employee.
 * @version 1.11 2013-02-26
 * @author Cay Horstmann
 */
public class MapTest {
    public static void main(String[] args) {
        Map&lt;String, Employee&gt; staff = new HashMap&lt;&gt;();
        staff.put(&quot;144-25-5464&quot;, new Employee(&quot;Amy Lee&quot;));
        staff.put(&quot;567-24-2546&quot;, new Employee(&quot;Hary Hacker&quot;));
        staff.put(&quot;157-92-7935&quot;, new Employee(&quot;Gary Cooper&quot;));
        staff.put(&quot;456-62-5527&quot;, new Employee(&quot;Francesca Cruz&quot;));

        // print all entries

        System.out.println(staff);

        // remove an entry

        staff.remove(&quot;567-24-2546&quot;);

        // replace an entry

        staff.put(&quot;456-62-5527&quot;, new Employee(&quot;Francesca Miller&quot;));

        // look up a value

        System.out.println(staff.get(&quot;157-62-7935&quot;));

        // iterate through all entries

        staff.forEach((k, v) -&gt;
            System.out.println(&quot;key= &quot; + k + &quot;, value=&quot; + v));
    }
}

class Employee {
    private String name;

    public  Employee(String name) {
        this.name = name;
    }
}
</code></pre><h3 id="932-更新映射项">9.3.2 更新映射项</h3>
<h3 id="933-映射视图">9.3.3 映射视图</h3>
<ul>
<li>集合框架不认为映射本身时一个集合。（其他数据结构框架认为映射时一个键/值对集合，或者时由键索引的值集合。）不过，可以得到映射的视图（view）&ndash;这是实现了Collection接口或某个子接口的对象。</li>
<li>有三种视图：键集、值集合（不是一个集）以及键/值对集。键和键/值对可以构造成一个集，因为映射中一个键只能由一个副本。下面的方法：</li>
</ul>
<pre><code>    Set&lt;k&gt; keySet()
    Collection&lt;v&gt; values()
    Set&lt;Map.Entry&lt;k, v&gt;&gt; entrySet()
</code></pre><ul>
<li>例如，需要枚举一个映射的所有键：</li>
</ul>
<pre><code>    Set&lt;String&gt; keys = map.keySet();
    for (String key : keys) {
        do something with key
    }
</code></pre><ul>
<li>如果同时查看键和值，可以通过枚举条目来避免查找值。使用以下代码：</li>
</ul>
<pre><code>    for (Map.Entry&lt;String, Employee&gt; entry : staff.entrySet()) {
        String k = entry.getKey();
        Employee v = entry.getValue();
        do something  with k, v
    }
</code></pre><ul>
<li>以上是以前的，现在只需要用forEach方法：</li>
</ul>
<pre><code>    count.forEach((k, v) -&gt; {
        do something with k, v
    } );
</code></pre><h3 id="934-弱散列映射-weakhashmap">9.3.4 弱散列映射 WeakHashMap</h3>
<h3 id="935-链接散列集与映射-linkedhashset和linkedhashmap">9.3.5 链接散列集与映射 LinkedHashSet和LinkedHashMap</h3>
<h3 id="936-枚举集与映射">9.3.6 枚举集与映射</h3>
<h3 id="937-标识散列映射">9.3.7 标识散列映射</h3>
<hr>
<h2 id="94-视图与包装器">9.4 视图与包装器</h2>
<hr>
<h2 id="95-算法">9.5 算法</h2>
<hr>
<h2 id="96-遗留的集合">9.6 遗留的集合</h2>
<hr>
<h1 id="第10章-注解">第10章 注解</h1>
<hr>
<h2 id="101-使用注解">10.1 使用注解</h2>
<ul>
<li>什么是注解（Annotation）？注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”：</li>
</ul>
<pre><code>    // this is a component:
    @Resource(&quot;hello&quot;)
    public class Hello {
        @Inject
        int n;

        @PostConstruct
        public void hello(@Param String name) {
            System.out.println(name);
        }

        @Override
        public String toString() {
            return &quot;Hello&quot;;
        }
    }
</code></pre><p><!-- raw HTML omitted --> 注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。
注解的作用</p>
<ul>
<li>
<p>注解的作用
<!-- raw HTML omitted --> 从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
</li>
<li>
<p>Java的注解可以分为三类：
<!-- raw HTML omitted --> 1. 第一类是由编译器使用的注解，例如：
<!-- raw HTML omitted --> @Override:让编译器检查该方法是否正确地实现了覆写；
<!-- raw HTML omitted --> @SuppressWarnings；告诉编译器忽略此处代码产生的警告。
<!-- raw HTML omitted --> - 这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了。
<!-- raw HTML omitted -->
<!-- raw HTML omitted --> 2. 第二类是由工具处理.class文件使用的注解，比如有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。
<!-- raw HTML omitted -->
<!-- raw HTML omitted --> 3. 第三类是在程序运行期能够读取的注解，它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了@PostConstruct的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
</li>
<li>
<p>定义一个注解时，还可以定义配置参数。配置参数可以包括：
<!-- raw HTML omitted --> - 所有基本类型；
<!-- raw HTML omitted --> - String；
<!-- raw HTML omitted --> - 枚举类型；
<!-- raw HTML omitted --> - 基本类型、String以及枚举的数组。</p>
</li>
<li>
<p>因为配置参数必须是常量，所以，上述限制保证了注解在定义时就已经确定了每个参数的值。</p>
</li>
<li>
<p>注解的配置参数可以有默认值，缺少某个配置参数时将使用默认值。
<!-- raw HTML omitted --> 此外，大部分注解会有一个名为value的配置参数，对此参数赋值，可以只写常量，相当于省略了value参数。
<!-- raw HTML omitted --> 如果只写注解，相当于全部使用默认值。
<!-- raw HTML omitted --> 举个栗子，对以下代码：</p>
</li>
</ul>
<pre><code>    public class Hello {
        @Check(min=0, max=100, value=55)
        public int n;

        @Check(value=99)
        public int p;

        @Check(99) // @Check(value=99)
        public int x;

        @Check
        public int y;
    }  
</code></pre><ul>
<li>@Check就是一个注解。第一个@Check(min=0, max=100, value=55)明确定义了三个参数，第二个@Check(value=99)只定义了一个value参数，它实际上和@Check(99)是完全一样的。最后一个@Check表示所有参数都使用默认值。</li>
</ul>
<h3 id="小结">小结</h3>
<ul>
<li>注解（Annotation）是Java语言用于工具处理的标注：</li>
<li>注解可以配置参数，没有指定配置的参数使用默认值；</li>
<li>如果参数名称是value，且只有一个参数，那么可以省略参数名称</li>
</ul>
<hr>
<h2 id="102-定义注解">10.2 定义注解</h2>
<ul>
<li>Java语言使用@interface语法来定义注解（Annotation），它的格式如下：</li>
</ul>
<pre><code>    public @interface Report {
        int type() default 0;
        String level() default &quot;info&quot;;
        String value() default &quot;&quot;;
    }
</code></pre><ul>
<li>注解的参数类似无参数方法，可以用default设定一个默认值（强烈推荐）。最常用的参数应当命名为value。</li>
</ul>
<h3 id="元注解">元注解</h3>
<ul>
<li>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</li>
</ul>
<h3 id="target">@Target</h3>
<ul>
<li>最常用的元注解是@Target。使用@Target可以定义Annotation能够被应用于源码的哪些位置：
<!-- raw HTML omitted --> 类或接口：ElementType.TYPE；
<!-- raw HTML omitted --> 字段：ElementType.FIELD；
<!-- raw HTML omitted --> 方法：ElementType.METHOD；
<!-- raw HTML omitted --> 构造方法：ElementType.CONSTRUCTOR；
<!-- raw HTML omitted --> 方法参数：ElementType.PARAMETER。</li>
<li>例如，定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)：</li>
</ul>
<pre><code>@Target(ElementType.METHOD)
public @interface Report {
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
}
</code></pre><ul>
<li>定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：</li>
</ul>
<pre><code>@Target({
    ElementType.METHOD,
    ElementType.FIELD
})
public @interface Report {
    ...
}
</code></pre><ul>
<li>实际上@Target定义的value是ElementType[]数组，只有一个元素时，可以省略数组的写法</li>
</ul>
<h3 id="retention">@Retention</h3>
<ul>
<li>
<p>另一个重要的元注解@Retention定义了Annotation的生命周期：</p>
<p><!-- raw HTML omitted --> 仅编译期：RetentionPolicy.SOURCE；
<!-- raw HTML omitted --> 仅class文件：RetentionPolicy.CLASS；
<!-- raw HTML omitted --> 运行期：RetentionPolicy.RUNTIME。</p>
</li>
<li>
<p>如果@Retention不存在，则该Annotation默认为CLASS。因为通常我们自定义的Annotation都是RUNTIME，所以，务必要加上@Retention(RetentionPolicy.RUNTIME)这个元注解：</p>
</li>
</ul>
<pre><code>    @Retention(RetentionPolicy.RUNTIME)
    public @interface Report {
        int type() default 0;
        String level() default &quot;info&quot;;
        String value() default &quot;&quot;;
    }    
</code></pre><h3 id="repeatable">@Repeatable</h3>
<ul>
<li>使用@Repeatable这个元注解可以定义Annotation是否可重复。这个注解应用不是特别广泛。</li>
</ul>
<pre><code>@Repeatable(Reports.class)
@Target(ElementType.TYPE)
public @interface Report {
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
}

@Target(ElementType.TYPE)
public @interface Reports {
    Report[] value();
}
</code></pre><ul>
<li>经过@Repeatable修饰后，在某个类型声明处，就可以添加多个@Report注解：</li>
</ul>
<pre><code>@Report(type=1, level=&quot;debug&quot;)
@Report(type=2, level=&quot;warning&quot;)
public class Hello {
}
</code></pre><h3 id="inherited">@Inherited</h3>
<ul>
<li>使用@Inherited定义子类是否可继承父类定义的Annotation。@Inherited仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效：</li>
</ul>
<pre><code>@Inherited
@Target(ElementType.TYPE)
public @interface Report {
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
}
</code></pre><ul>
<li>在使用的时候，如果一个类用到了@Report：</li>
</ul>
<pre><code>@Report(type=1)
public class Person {
}
</code></pre><ul>
<li>则它的子类默认也定义了该注解：</li>
</ul>
<pre><code>public class Student extends Person {
}
</code></pre><h3 id="如何定义annotation">如何定义Annotation</h3>
<ul>
<li>我们总结一下定义Annotation的步骤：</li>
</ul>
<pre><code>public @interface Report {
}
</code></pre><ul>
<li>第二步，添加参数、默认值：</li>
</ul>
<pre><code>public @interface Report {
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
}

// 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。
</code></pre><ul>
<li>第三步，用元注解配置注解：</li>
</ul>
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Report {
    int type() default 0;
    String level() default &quot;info&quot;;
    String value() default &quot;&quot;;
}
// 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。
</code></pre><h3 id="小结-1">小结</h3>
<ul>
<li>Java使用@interface定义注解：
<!-- raw HTML omitted --> - 可定义多个参数和默认值，核心参数使用value名称；
<!-- raw HTML omitted --> - 必须设置@Target来指定Annotation可以应用的范围；
<!-- raw HTML omitted --> - 应当设置@Retention(RetentionPolicy.RUNTIME)便于运行期读取该Annotation。</li>
</ul>
<hr>
<h2 id="103-处理注解">10.3 处理注解</h2>
<ul>
<li>Java的注解本身对代码逻辑没有任何影响。根据@Retention的配置：
<!-- raw HTML omitted --> - SOURCE类型的注解在编译期就被丢掉了；
<!-- raw HTML omitted --> - CLASS类型的注解仅保存在class文件中，它们不会被加载进JVM；
<!-- raw HTML omitted --> - RUNTIME类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
<li>如何使用注解完全由工具决定。SOURCE类型的注解主要由编译器使用，因此我们一般只使用，不编写。CLASS类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。</li>
<li>只有RUNTIME类型的注解不但要使用，还经常需要编写。</li>
<li>因为注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，因此，读取注解，需要使用反射API。</li>
<li>Java提供的使用反射API读取Annotation的方法包括：
<!-- raw HTML omitted --> - 判断某个注解是否存在于Class、Field、Method或Constructor：
<!-- raw HTML omitted --> - Class.isAnnotationPresent(Class)
<!-- raw HTML omitted --> - Field.isAnnotationPresent(Class)
<!-- raw HTML omitted --> - Method.isAnnotationPresent(Class)
<!-- raw HTML omitted --> -Constructor.isAnnotationPresent(Class)</li>
</ul>
<pre><code>// 判断@Report是否存在于Person类:
Person.class.isAnnotationPresent(Report.class);
</code></pre><ul>
<li>使用反射API读取Annotation：
<!-- raw HTML omitted --> - Class.getAnnotation(Class)
<!-- raw HTML omitted --> - Field.getAnnotation(Class)
<!-- raw HTML omitted --> - Method.getAnnotation(Class)
<!-- raw HTML omitted --> - Constructor.getAnnotation(Class)</li>
</ul>
<pre><code>// 获取Person定义的@Report注解:
Report report = Person.class.getAnnotation(Report.class);
int type = report.type();
String level = report.level();
</code></pre><ul>
<li>使用反射API读取Annotation有两种方法。
<!-- raw HTML omitted --> 方法一是先判断Annotation是否存在，如果存在，就直接读取:</li>
</ul>
<pre><code>Class cls = Person.class;
if (cls.isAnnotationPresent(Report.class)) {
    Report report = cls.getAnnotation(Report.class);
    ...
}
</code></pre><p><!-- raw HTML omitted --> - 第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：</p>
<pre><code>Class cls = Person.class;
Report report = cls.getAnnotation(Report.class);
if (report != null) {
   ...
}
</code></pre><ul>
<li>读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：</li>
</ul>
<pre><code>public void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) {
}
</code></pre><ul>
<li>要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：</li>
</ul>
<pre><code>// 获取Method实例:
Method m = ...
// 获取所有参数的Annotation:
Annotation[][] annos = m.getParameterAnnotations();
// 第一个参数（索引为0）的所有Annotation:
Annotation[] annosOfName = annos[0];
for (Annotation anno : annosOfName) {
    if (anno instanceof Range) { // @Range注解
        Range r = (Range) anno;
    }
    if (anno instanceof NotNull) { // @NotNull注解
        NotNull n = (NotNull) anno;
    }
}
</code></pre><h3 id="使用注解">使用注解</h3>
<ul>
<li>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为@Test的方法。</li>
<li>我们来看一个@Range注解，我们希望用它来定义一个String字段的规则：字段长度满足@Range的参数定义：</li>
</ul>
<pre><code>@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Range {
    int min() default 0;
    int max() default 255;
}
</code></pre><ul>
<li>在某个JavaBean中，我们可以使用该注解：</li>
</ul>
<pre><code>public class Person {
    @Range(min=1, max=20)
    public String name;

    @Range(max=10)
    public String city;
}
</code></pre><ul>
<li>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。这里，我们编写一个Person实例的检查方法，它可以检查Person实例的String字段长度是否满足@Range的定义：</li>
</ul>
<pre><code>void check(Person person) throws IllegalArgumentException, ReflectiveOperationException {
    // 遍历所有Field:
    for (Field field : person.getClass().getFields()) {
        // 获取Field定义的@Range:
        Range range = field.getAnnotation(Range.class);
        // 如果@Range存在:
        if (range != null) {
            // 获取Field的值:
            Object value = field.get(person);
            // 如果值是String:
            if (value instanceof String) {
                String s = (String) value;
                // 判断值是否满足@Range的min/max:
                if (s.length() &lt; range.min() || s.length() &gt; range.max()) {
                    throw new IllegalArgumentException(&quot;Invalid field: &quot; + field.getName());
                }
            }
        }
    }
}
</code></pre><ul>
<li>这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</li>
</ul>
<h3 id="小结-2">小结</h3>
<ul>
<li>可以在运行期通过反射读取RUNTIME类型的注解，注意千万不要漏写@Retention(RetentionPolicy.RUNTIME)，否则运行期无法读取到该注解。</li>
<li>可以通过程序处理注解来实现相应的功能：
<!-- raw HTML omitted --> - 对JavaBean的属性值按规则进行检查；
<!-- raw HTML omitted --> - JUnit会自动运行@Test标记的测试方法。</li>
</ul>
<hr>
<h1 id="第11章-多线程">第11章 多线程</h1>
<hr>
<h2 id="111--多线程基础">11.1  多线程基础</h2>
<ul>
<li>现代操作系统（Windows，macOS，Linux）都可以执行多任务。多任务就是同时运行多个任务。</li>
<li>CPU执行代码都是一条一条顺序执行的，但是，即使是单核cpu，也可以同时运行多个任务。因为操作系统执行多任务实际上就是让CPU对多个任务轮流交替执行。</li>
<li>类似的，操作系统轮流让多个任务交替执行，例如，让浏览器执行0.001秒，让QQ执行0.001秒，再让音乐播放器执行0.001秒，在人看来，CPU就是在同时执行多个任务。</li>
<li>即使是多核CPU，因为通常任务的数量远远多于CPU的核数，所以任务也是交替执行的。</li>
</ul>
<h3 id="进程">进程</h3>
<ul>
<li>
<p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
</li>
<li>
<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>
</li>
<li>
<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>
</li>
</ul>
<pre><code>                        ┌──────────┐
                        │Process   │
                        │┌────────┐│
            ┌──────────┐││ Thread ││┌──────────┐
            │Process   ││└────────┘││Process   │
            │┌────────┐││┌────────┐││┌────────┐│
┌──────────┐││ Thread ││││ Thread ││││ Thread ││
│Process   ││└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘└──────────┘
┌──────────────────────────────────────────────┐
│               Operating System               │
└──────────────────────────────────────────────┘
</code></pre><ul>
<li>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</li>
<li>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</li>
</ul>
<h3 id="线程调度">线程调度：</h3>
<p>线程有两种调度模型：</p>
<ul>
<li>分时调度模型：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li>
<li>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的CPU时间片相对多一些</li>
<li>Java使用的是抢占式调度模型</li>
</ul>
<p>多进程模式（每个进程只有一个线程）：</p>
<pre><code>┌──────────┐ ┌──────────┐ ┌──────────┐
│Process   │ │Process   │ │Process   │
│┌────────┐│ │┌────────┐│ │┌────────┐│
││ Thread ││ ││ Thread ││ ││ Thread ││
│└────────┘│ │└────────┘│ │└────────┘│
└──────────┘ └──────────┘ └──────────┘
</code></pre><p>多线程模式（一个进程有多个线程）：</p>
<pre><code>┌────────────────────┐
│Process             │
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
│┌────────┐┌────────┐│
││ Thread ││ Thread ││
│└────────┘└────────┘│
└────────────────────┘
</code></pre><p>多进程＋多线程模式（复杂度最高）：</p>
<pre><code>┌──────────┐┌──────────┐┌──────────┐
│Process   ││Process   ││Process   │
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
│┌────────┐││┌────────┐││┌────────┐│
││ Thread ││││ Thread ││││ Thread ││
│└────────┘││└────────┘││└────────┘│
└──────────┘└──────────┘└──────────┘
</code></pre><h3 id="进程-vs-线程">进程 vs 线程</h3>
<ul>
<li>
<p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p>
</li>
<li>
<p>具体采用哪种方式，要考虑到进程和线程的特点。</p>
</li>
<li>
<p>和多线程相比，多进程的缺点在于：
<!-- raw HTML omitted --> 创建进程比创建线程开销大，尤其是在Windows系统上；
<!-- raw HTML omitted --> 进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</p>
</li>
<li>
<p>而多进程的优点在于：
<!-- raw HTML omitted --> 多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。</p>
</li>
</ul>
<h3 id="多线程">多线程</h3>
<ul>
<li>
<p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
</li>
<li>
<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>
</li>
<li>
<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>
</li>
<li>
<p>Java多线程编程的特点又在于：
<!-- raw HTML omitted --> 多线程模型是Java程序最基本的并发模型；
<!-- raw HTML omitted --> 后续读写网络、数据库、Web开发等都依赖Java多线程模型。</p>
</li>
</ul>
<hr>
<h2 id="112-创建多线程">11.2 创建多线程</h2>
<ul>
<li>Java语言内置了多线程支持。当Java程序启动的时候，实际上是启动了一个JVM进程，然后，JVM启动主线程来执行main()方法。在main()方法中，我们又可以启动其他线程。</li>
<li>要创建一个新线程非常容易，我们需要实例化一个Thread实例，然后调用它的start()方法：</li>
</ul>
<pre><code>// 多线程
public class Main {
    public static void main(String[] args) {
        Thread t = new Thread();
        t.start(); // 启动新线程
    }
}
</code></pre><h3 id="设置和获取线程名称">设置和获取线程名称：</h3>
<p>Tread类中设置和获取线程的方法：</p>
<ul>
<li>void setName(String name):将此线程的名称更改为等于参数name</li>
<li>Srring getName():返回此线程的名称</li>
<li>通过构造方法也可以设置线程名称</li>
</ul>
<p>如何获取main()方法所在的线程名称？</p>
<ul>
<li>
<p>public static Thread currentThread()：返回对当前正在执行的线程对象的引用</p>
</li>
<li>
<p>但是这个线程启动后实际上什么也不做就立刻结束了。我们希望新线程能执行指定的代码，有以下几种方法：
<!-- raw HTML omitted --> -  方法一：从Thread派生一个自定义类，然后覆写run()方法：</p>
</li>
</ul>
<pre><code>public class Main {
    public static void main(String[] args) {
        Thread t = new MyThread();

        t.setName(&quot;A线程&quot;);

        Thread t = new MyThread(&quot;A线程&quot;);

        // 获取main方法的线程名称
        System.out.println(Thread.currentThread().getName);

        t.start(); // 启动新线程
    }
}

class MyThread extends Thread {
    public MyThread() {}

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        System.out.println(getName()); //获取线程名称
        System.out.println(&quot;start new thread!&quot;);
    }
}

// 执行上述代码，注意到start()方法会在内部自动调用实例的run()方法。
</code></pre><p><!-- raw HTML omitted --> - 方法二：创建Thread实例时，传入一个Runnable实例：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start(); // 启动新线程
    }
}

class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;start new thread!&quot;);
    }
}
</code></pre><p><!-- raw HTML omitted --> - 或者用Java8引入的lambda语法进一步简写为：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Thread t = new Thread(() -&gt; {
            System.out.println(&quot;start new thread!&quot;);
        });
        t.start(); // 启动新线程
    }
}
</code></pre><h3 id="使用线程执行的打印语句和直接在main方法执行有区别吗">使用线程执行的打印语句，和直接在main()方法执行有区别吗？</h3>
<pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;main start...&quot;);
        Thread t = new Thread() {
            public void run() {
                System.out.println(&quot;thread run...&quot;);
                System.out.println(&quot;thread end.&quot;);
            }
        };
        t.start();
        System.out.println(&quot;main end...&quot;);
    }
}
</code></pre><p>我们用蓝色表示主线程，也就是main线程，main线程执行的代码有4行，首先打印main start，然后创建Thread对象，紧接着调用start()启动新线程。当start()方法被调用时，JVM就创建了一个新线程，我们通过实例变量t来表示这个新线程对象，并开始执行。</p>
<p>接着，main线程继续执行打印main end语句，而t线程在main线程执行的同时会并发执行，打印thread run和thread end语句。</p>
<p>当run()方法结束时，新线程就结束了。而main()方法结束时，主线程也结束了。</p>
<p>我们再来看线程的执行顺序：</p>
<ol>
<li>main线程肯定是先打印main start，再打印main end；</li>
<li>t线程肯定是先打印thread run，再打印thread end。</li>
</ol>
<p>但是，除了可以肯定，main start会先打印外，main end打印在thread run之前、thread end之后或者之间，都无法确定。因为从t线程开始运行以后，两个线程就开始同时运行了，并且由操作系统调度，程序本身无法确定线程的调度顺序。</p>
<ul>
<li>要模拟并发执行的效果，我们可以在线程中调用Thread.sleep()，强迫当前线程暂停一段时间：</li>
</ul>
<pre><code>public class Main {
    public static void main(String[] args) {
        System.out.println(&quot;main start...&quot;);
        Thread t = new Thread() {
            public void run() {
                System.out.println(&quot;thread run...&quot;);
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {}
                System.out.println(&quot;thread end.&quot;);
            }
        };
        t.start();
        try {
            Thread.sleep(20);
        } catch (InterruptedException e) {}
        System.out.println(&quot;main end...&quot;);
    }
}
</code></pre><p>sleep()传入的参数是毫秒。调整暂停时间的大小，我们可以看到main线程和t线程执行的先后顺序。</p>
<p>要特别注意：直接调用Thread实例的run()方法是无效的：</p>
<pre><code>public class Main {
    public static void main(String[] args) {
        Thread t = new MyThread();
        t.run();
    }
}

class MyThread extends Thread {
    public void run() {
        System.out.println(&quot;hello&quot;);
    }
}
</code></pre><p>直接调用run()方法，相当于调用了一个普通的Java方法，当前线程并没有任何改变，也不会启动新线程。上述代码实际上是在main()方法内部又调用了run()方法，打印hello语句是在main线程中执行的，没有任何新线程被创建。</p>
<p>必须调用Thread实例的start()方法才能启动新线程，如果我们查看Thread类的源代码，会看到start()方法内部调用了一个private native void start0()方法，native修饰符表示这个方法是由JVM虚拟机内部的C代码实现的，不是由Java代码实现的。</p>
<h3 id="线程的优先级">线程的优先级</h3>
<ul>
<li>可以对线程设定优先级，设定优先级的方法是：</li>
</ul>
<pre><code>Thread.getPriority()
Thread.setPriority(int n) // 1~10, 默认值5
</code></pre><ul>
<li>优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程可能调度更频繁，但我们决不能通过设置优先级来确保高优先级的线程一定会先执行。</li>
</ul>
<h3 id="小结-3">小结</h3>
<p>Java用Thread对象表示一个线程，通过调用start()启动一个新线程；</p>
<p>一个线程对象只能调用一次start()方法；</p>
<p>线程的执行代码写在run()方法中；</p>
<p>线程调度由操作系统决定，程序本身无法决定调度顺序；</p>
<p>Thread.sleep()可以把当前线程暂停一段时间。</p>
<hr>
<h2 id="113-线程的状态">11.3 线程的状态</h2>
<ul>
<li>
<p>在Java程序中，一个线程对象只能调用一次start()方法启动新线程，并在新线程中执行run()方法。一旦run()方法执行完毕，线程就结束了。因此，Java线程的状态有以下几种：</p>
<ul>
<li>New：新创建的线程，尚未执行；</li>
<li>Runnable：运行中的线程，正在执行run()方法的Java代码；</li>
<li>Blocked：运行中的线程，因为某些操作被阻塞而挂起；</li>
<li>Waiting：运行中的线程，因为某些操作在等待中；</li>
<li>Timed Waiting：运行中的线程，因为执行sleep()方法正在计时等待；</li>
<li>Terminated：线程已终止，因为run()方法执行完毕。</li>
</ul>
</li>
<li>
<p>用一个状态转移图表示如下：</p>
</li>
</ul>
<pre><code>         ┌─────────────┐
         │     New     │
         └─────────────┘      
                │
                ▼
┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
 ┌─────────────┐ ┌─────────────┐
││  Runnable   │ │   Blocked   ││
 └─────────────┘ └─────────────┘
│┌─────────────┐ ┌─────────────┐│
 │   Waiting   │ │Timed Waiting│
│└─────────────┘ └─────────────┘│
 ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
                │
                ▼
         ┌─────────────┐
         │ Terminated  │
         └─────────────┘
</code></pre><p>当线程启动后，它可以在Runnable、Blocked、Waiting和Timed Waiting这几个状态之间切换，直到最后变成Terminated状态，线程终止。</p>
<p>线程终止的原因有：
- 线程正常终止：run()方法执行到return语句返回；
- 线程意外终止：run()方法因为未捕获的异常导致线程终止；
- 对某个线程的Thread实例调用stop()方法强制终止（强烈不推荐使用）。</p>
<p>一个线程还可以等待另一个线程直到其运行结束。例如，main线程在启动t线程后，可以通过t.join()等待t线程结束后再继续运行：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new Thread(() -&gt; {
            System.out.println(&quot;hello&quot;);
        });
        System.out.println(&quot;start&quot;);
        t.start();
        t.join();
        System.out.println(&quot;end&quot;);
    }
}
</code></pre><p>当main线程对线程对象t调用join()方法时，主线程将等待变量t表示的线程运行结束，即join就是指等待该线程结束，然后才继续往下执行自身线程。所以，上述代码打印顺序可以肯定是main线程先打印start，t线程再打印hello，main线程最后再打印end。</p>
<p>如果t线程已经结束，对实例t调用join()会立刻返回。此外，join(long)的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p>
<h3 id="小结-4">小结</h3>
<p>Java线程对象Thread的状态包括：New、Runnable、Blocked、Waiting、Timed Waiting和Terminated；</p>
<p>通过对另一个线程对象调用join()方法可以等待其执行结束；</p>
<p>可以指定等待时间，超过等待时间线程仍然没有结束就不再等待；</p>
<p>对已经运行结束的线程调用join()方法会立刻返回。</p>
<hr>
<h2 id="114-中断线程">11.4 中断线程</h2>
<ul>
<li>如果线程需要执行一个长时间任务，就可能需要能中断线程。中断线程就是其他线程给该线程发一个信号，该线程收到信号后结束执行run()方法，使得自身线程能立刻结束运行。</li>
</ul>
<p>我们举个栗子：假设从网络下载一个100M的文件，如果网速很慢，用户等得不耐烦，就可能在下载过程中点“取消”，这时，程序就需要中断下载线程的执行。</p>
<p>中断一个线程非常简单，只需要在其他线程中对目标线程调用interrupt()方法，目标线程需要反复检测自身状态是否是interrupted状态，如果是，就立刻结束运行。</p>
<p>我们还是看示例代码：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new MyThread();
        t.start();
        Thread.sleep(1); // 暂停1毫秒
        t.interrupt(); // 中断t线程
        t.join(); // 等待t线程结束
        System.out.println(&quot;end&quot;);
    }
}

class MyThread extends Thread {
    public void run() {
        int n = 0;
        while (! isInterrupted()) {
            n ++;
            System.out.println(n + &quot; hello!&quot;);
        }
    }
}
</code></pre><p>仔细看上述代码，main线程通过调用t.interrupt()方法中断t线程，但是要注意，interrupt()方法仅仅向t线程发出了“中断请求”，至于t线程是否能立刻响应，要看具体代码。而t线程的while循环会检测isInterrupted()，所以上述代码能正确响应interrupt()请求，使得自身立刻结束运行run()方法。</p>
<p>如果线程处于等待状态，例如，t.join()会让main线程进入等待状态，此时，如果对main线程调用interrupt()，join()方法会立刻抛出InterruptedException，因此，目标线程只要捕获到join()方法抛出的InterruptedException，就说明有其他线程对其调用了interrupt()方法，通常情况下该线程应该立刻结束运行。</p>
<p>我们来看下面的示例代码：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws InterruptedException {
        Thread t = new MyThread();
        t.start();
        Thread.sleep(1000);
        t.interrupt(); // 中断t线程
        t.join(); // 等待t线程结束
        System.out.println(&quot;end&quot;);
    }
}

class MyThread extends Thread {
    public void run() {
        Thread hello = new HelloThread();
        hello.start(); // 启动hello线程
        try {
            hello.join(); // 等待hello线程结束
        } catch (InterruptedException e) {
            System.out.println(&quot;interrupted!&quot;);
        }
        hello.interrupt();
    }
}

class HelloThread extends Thread {
    public void run() {
        int n = 0;
        while (!isInterrupted()) {
            n++;
            System.out.println(n + &quot; hello!&quot;);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
</code></pre><p>main线程通过调用t.interrupt()从而通知t线程中断，而此时t线程正位于hello.join()的等待中，此方法会立刻结束等待并抛出InterruptedException。由于我们在t线程中捕获了InterruptedException，因此，就可以准备结束该线程。在t线程结束前，对hello线程也进行了interrupt()调用通知其中断。如果去掉这一行代码，可以发现hello线程仍然会继续运行，且JVM不会退出。</p>
<ul>
<li>另一个常用的中断线程的方法是设置标志位。我们通常会用一个running标志位来标识线程是否应该继续运行，在外部线程中，通过把HelloThread.running置为false，就可以让线程结束：</li>
</ul>
<pre><code>public class Main {
    public static void main(String[] args)  throws InterruptedException {
        HelloThread t = new HelloThread();
        t.start();
        Thread.sleep(1);
        t.running = false; // 标志位置为false
    }
}

class HelloThread extends Thread {
    public volatile boolean running = true;
    public void run() {
        int n = 0;
        while (running) {
            n ++;
            System.out.println(n + &quot; hello!&quot;);
        }
        System.out.println(&quot;end!&quot;);
    }
}
</code></pre><p>public class Main {
public static void main(String[] args)  throws InterruptedException {
HelloThread t = new HelloThread();
t.start();
Thread.sleep(1);
t.running = false; // 标志位置为false
}
}</p>
<p>class HelloThread extends Thread {
public volatile boolean running = true;
public void run() {
int n = 0;
while (running) {
n ++;
System.out.println(n + &quot; hello!&quot;);
}
System.out.println(&ldquo;end!&quot;);
}
}
注意到HelloThread的标志位boolean running是一个线程间共享的变量。线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。</p>
<p>为什么要对线程间共享的变量用关键字volatile声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p>
<pre><code>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
           Main Memory
│                               │
   ┌───────┐┌───────┐┌───────┐
│  │ var A ││ var B ││ var C │  │
   └───────┘└───────┘└───────┘
│     │ ▲               │ ▲     │
 ─ ─ ─│─│─ ─ ─ ─ ─ ─ ─ ─│─│─ ─ ─
      │ │               │ │
┌ ─ ─ ┼ ┼ ─ ─ ┐   ┌ ─ ─ ┼ ┼ ─ ─ ┐
      ▼ │               ▼ │
│  ┌───────┐  │   │  ┌───────┐  │
   │ var A │         │ var C │
│  └───────┘  │   │  └───────┘  │
   Thread 1          Thread 2
└ ─ ─ ─ ─ ─ ─ ┘   └ ─ ─ ─ ─ ─ ─ ┘
</code></pre><p>这会导致如果一个线程更新了某个变量，另一个线程读取的值可能还是更新前的。例如，主内存的变量a = true，线程1执行a = false时，它在此刻仅仅是把变量a的副本变成了false，主内存的变量a还是true，在JVM把修改后的a回写到主内存之前，其他线程读取到的a的值仍然是true，这就造成了多线程之间共享的变量不一致。</p>
<p>因此，volatile关键字的目的是告诉虚拟机：</p>
<ul>
<li>每次访问变量时，总是获取主内存的最新值</li>
<li>每次修改变量后，立刻回写到主内存。</li>
</ul>
<p>volatile关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p>
<p>如果我们去掉volatile关键字，运行上述程序，发现效果和带volatile差不多，这是因为在x86的架构下，JVM回写主内存的速度非常快，但是，换成ARM的架构，就会有显著的延迟。</p>
<h3 id="小结-5">小结</h3>
<p>对目标线程调用interrupt()方法可以请求中断一个线程，目标线程通过检测isInterrupted()标志获取自身是否已中断。如果目标线程处于等待状态，该线程会捕获到InterruptedException；</p>
<p>目标线程检测到isInterrupted()为true或者捕获了InterruptedException都应该立刻结束自身线程；</p>
<p>通过标志位判断需要正确使用volatile关键字；</p>
<p>volatile关键字解决了共享变量在线程间的可见性问题。</p>
<hr>
<h2 id="115-守护线程">11.5 守护线程</h2>
<p>Java程序入口就是由JVM启动main线程，main线程又可以启动其他线程。当所有线程都运行结束时，JVM退出，进程结束。</p>
<p>如果有一个线程没有退出，JVM进程就不会退出。所以，必须保证所有线程都能及时结束。</p>
<p>但是有一种线程的目的就是无限循环，例如，一个定时触发任务的线程：</p>
<pre><code>class TimerThread extends Thread {
    @Override
    public void run() {
        while (true) {
            System.out.println(LocalTime.now());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
</code></pre><p>如果这个线程不结束，JVM进程就无法结束。问题是，由谁负责结束这个线程？</p>
<p>然而这类线程经常没有负责人来负责结束它们。但是，当其他线程结束时，JVM进程又必须要结束，怎么办？</p>
<p>答案是使用守护线程（Daemon Thread）。</p>
<p>守护线程是指为其他线程服务的线程。在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出。</p>
<p>因此，JVM退出时，不必关心守护线程是否已结束。</p>
<p>如何创建守护线程呢？方法和普通线程一样，只是在调用start()方法前，调用setDaemon(true)把该线程标记为守护线程：</p>
<pre><code>Thread t = new MyThread();
t.setDaemon(true);
t.start();
</code></pre><p>在守护线程中，编写代码要注意：守护线程不能持有任何需要关闭的资源，例如打开文件等，因为虚拟机退出时，守护线程没有任何机会来关闭文件，这会导致数据丢失。</p>
<h3 id="小结-6">小结</h3>
<p>守护线程是为其他线程服务的线程；</p>
<p>所有非守护线程都执行完毕后，虚拟机退出；</p>
<p>守护线程不能持有需要关闭的资源（如打开文件等）。</p>
<hr>
<h2 id="116-线程同步">11.6 线程同步</h2>
<p>当多个线程同时运行时，线程的调度由操作系统决定，程序本身无法决定。因此，任何一个线程都有可能在任何指令处被操作系统暂停，然后在某个时间段后继续执行。</p>
<p>这个时候，有个单线程模型下不存在的问题就来了：如果多个线程同时读写共享变量，会出现数据不一致的问题。</p>
<p>我们来看一个例子：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws Exception {
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    }
}

class Counter {
    public static int count = 0;
}

class AddThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) { Counter.count += 1; }
    }
}

class DecThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) { Counter.count -= 1; }
    }
}
</code></pre><p>上面的代码很简单，两个线程同时对一个int变量进行操作，一个加10000次，一个减10000次，最后结果应该是0，但是，每次运行，结果实际上都是不一样的。</p>
<p>这是因为对变量进行读取和写入时，结果要正确，必须保证是原子操作。原子操作是指不能被中断的一个或一系列操作。</p>
<p>例如，对于语句：</p>
<pre><code>n = n + 1;
</code></pre><p>看上去是一行语句，实际上对应了3条指令：</p>
<pre><code>ILOAD
IADD
ISTORE
</code></pre><p>我们假设n的值是100，如果两个线程同时执行n = n + 1，得到的结果很可能不是102，而是101，原因在于：</p>
<pre><code>┌───────┐    ┌───────┐
│Thread1│    │Thread2│
└───┬───┘    └───┬───┘
    │            │
    │ILOAD (100) │
    │            │ILOAD (100)
    │            │IADD
    │            │ISTORE (101)
    │IADD        │
    │ISTORE (101)│
    ▼            ▼
</code></pre><p>如果线程1在执行ILOAD后被操作系统中断，此刻如果线程2被调度执行，它执行ILOAD后获取的值仍然是100，最终结果被两个线程的ISTORE写入后变成了101，而不是期待的102。</p>
<p>这说明多线程模型下，要保证逻辑正确，对共享变量进行读写时，必须保证一组指令以原子方式执行：即某一个线程执行时，其他线程必须等待：</p>
<pre><code>┌───────┐     ┌───────┐
│Thread1│     │Thread2│
└───┬───┘     └───┬───┘
    │             │
    │-- lock --   │
    │ILOAD (100)  │
    │IADD         │
    │ISTORE (101) │
    │-- unlock -- │
    │             │-- lock --
    │             │ILOAD (101)
    │             │IADD
    │             │ISTORE (102)
    │             │-- unlock --
    ▼             ▼
</code></pre><p>通过加锁和解锁的操作，就能保证3条指令总是在一个线程执行期间，不会有其他线程会进入此指令区间。即使在执行期线程被操作系统中断执行，其他线程也会因为无法获得锁导致无法进入此指令区间。只有执行线程将锁释放后，其他线程才有机会获得锁并执行。这种加锁和解锁之间的代码块我们称之为临界区（Critical Section），任何时候临界区最多只有一个线程能执行。</p>
<p>可见，保证一段代码的原子性就是通过加锁和解锁实现的。Java程序使用synchronized关键字对一个对象进行加锁：</p>
<pre><code>synchronized(lock) {
    n = n + 1;
}
</code></pre><p>synchronized保证了代码块在任意时刻最多只有一个线程能执行。我们把上面的代码用synchronized改写如下：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws Exception {
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    }
}

class Counter {
    public static final Object lock = new Object();
    public static int count = 0;
}

class AddThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock) {
                Counter.count += 1;
            }
        }
    }
}

class DecThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock) {
                Counter.count -= 1;
            }
        }
    }
}
</code></pre><p>注意到代码：</p>
<pre><code>synchronized(Counter.lock) { // 获取锁
    ...
} // 释放锁
</code></pre><p>它表示用Counter.lock实例作为锁，两个线程在执行各自的synchronized(Counter.lock) { &hellip; }代码块时，必须先获得锁，才能进入代码块进行。执行结束后，在synchronized语句块结束会自动释放锁。这样一来，对Counter.count变量进行读写就不可能同时进行。上述代码无论运行多少次，最终结果都是0。</p>
<p>使用synchronized解决了多线程同步访问共享变量的正确性问题。但是，它的缺点是带来了性能下降。因为synchronized代码块无法并发执行。此外，加锁和解锁需要消耗一定的时间，所以，synchronized会降低程序的执行效率。</p>
<p>我们来概括一下如何使用synchronized：</p>
<ul>
<li>找出修改共享变量的线程代码块；</li>
<li>选择一个共享实例作为锁；</li>
<li>使用synchronized(lockObject) { &hellip; }。</li>
</ul>
<p>在使用synchronized的时候，不必担心抛出异常。因为无论是否有异常，都会在synchronized结束处正确释放锁：</p>
<pre><code>public void add(int m) {
    synchronized (obj) {
        if (m &lt; 0) {
            throw new RuntimeException();
        }
        this.value += m;
    } // 无论有无异常，都会在此释放锁
}
</code></pre><ul>
<li>我们再来看一个错误使用synchronized的例子：</li>
</ul>
<pre><code>public class Main {
    public static void main(String[] args) throws Exception {
        var add = new AddThread();
        var dec = new DecThread();
        add.start();
        dec.start();
        add.join();
        dec.join();
        System.out.println(Counter.count);
    }
}

class Counter {
    public static final Object lock1 = new Object();
    public static final Object lock2 = new Object();
    public static int count = 0;
}

class AddThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock1) {
                Counter.count += 1;
            }
        }
    }
}

class DecThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock2) {
                Counter.count -= 1;
            }
        }
    }
}
</code></pre><p>结果并不是0，这是因为两个线程各自的synchronized锁住的不是同一个对象！这使得两个线程各自都可以同时获得锁：因为JVM只保证同一个锁在任意时刻只能被一个线程获取，但两个不同的锁在同一时刻可以被两个线程分别获取。</p>
<p>因此，使用synchronized的时候，获取到的是哪个锁非常重要。锁对象如果不对，代码逻辑就不对。</p>
<p>我们再看一个例子：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws Exception {
        var ts = new Thread[] { new AddStudentThread(), new DecStudentThread(), new AddTeacherThread(), new DecTeacherThread() };
        for (var t : ts) {
            t.start();
        }
        for (var t : ts) {
            t.join();
        }
        System.out.println(Counter.studentCount);
        System.out.println(Counter.teacherCount);
    }
}

class Counter {
    public static final Object lock = new Object();
    public static int studentCount = 0;
    public static int teacherCount = 0;
}

class AddStudentThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock) {
                Counter.studentCount += 1;
            }
        }
    }
}

class DecStudentThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock) {
                Counter.studentCount -= 1;
            }
        }
    }
}

class AddTeacherThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock) {
                Counter.teacherCount += 1;
            }
        }
    }
}

class DecTeacherThread extends Thread {
    public void run() {
        for (int i=0; i&lt;10000; i++) {
            synchronized(Counter.lock) {
                Counter.teacherCount -= 1;
            }
        }
    }
}
</code></pre><p>上述代码的4个线程对两个共享变量分别进行读写操作，但是使用的锁都是Counter.lock这一个对象，这就造成了原本可以并发执行的Counter.studentCount += 1和Counter.teacherCount += 1，现在无法并发执行了，执行效率大大降低。实际上，需要同步的线程可以分成两组：AddStudentThread和DecStudentThread，AddTeacherThread和DecTeacherThread，组之间不存在竞争，因此，应该使用两个不同的锁，即：</p>
<p>AddStudentThread和DecStudentThread使用lockStudent锁：</p>
<pre><code>synchronized(Counter.lockStudent) {
    ...
}
</code></pre><p>AddTeacherThread和DecTeacherThread使用lockTeacher锁：</p>
<pre><code>synchronized(Counter.lockTeacher) {
    ...
}
</code></pre><p>这样才能最大化地提高执行效率。</p>
<h3 id="不需要synchronized的操作">不需要synchronized的操作</h3>
<p>JVM规范定义了几种原子操作：</p>
<ul>
<li>基本类型（long和double除外）赋值，例如：int n = m；</li>
<li>引用类型赋值，例如：List<!-- raw HTML omitted --> list = anotherList。</li>
</ul>
<p>long和double是64位数据，JVM没有明确规定64位赋值操作是不是一个原子操作，不过在x64平台的JVM是把long和double的赋值作为原子操作实现的。</p>
<p>单条原子操作的语句不需要同步。例如：</p>
<pre><code>public void set(int m) {
    synchronized(lock) {
        this.value = m;
    }
}
</code></pre><p>就不需要同步。</p>
<p>对引用也是类似。例如：</p>
<pre><code>public void set(String s) {
    this.value = s;
}
</code></pre><p>上述赋值语句并不需要同步。</p>
<p>但是，如果是多行赋值语句，就必须保证是同步操作，例如：</p>
<pre><code>class Pair {
    int first;
    int last;
    public void set(int first, int last) {
        synchronized(this) {
            this.first = first;
            this.last = last;
        }
    }
}
</code></pre><p>有些时候，通过一些巧妙的转换，可以把非原子操作变为原子操作。例如，上述代码如果改造成：</p>
<pre><code>class Pair {
    int[] pair;
    public void set(int first, int last) {
        int[] ps = new int[] { first, last };
        this.pair = ps;
    }
}
</code></pre><p>就不再需要同步，因为this.pair = ps是引用赋值的原子操作。而语句：</p>
<pre><code>int[] ps = new int[] { first, last };
</code></pre><p>这里的ps是方法内部定义的局部变量，每个线程都会有各自的局部变量，互不影响，并且互不可见，并不需要同步。</p>
<h3 id="小结-7">小结</h3>
<p>多线程同时读写共享变量时，会造成逻辑错误，因此需要通过synchronized同步；</p>
<p>同步的本质就是给指定对象加锁，加锁后才能继续执行后续代码；</p>
<p>注意加锁对象必须是同一个实例；</p>
<p>对JVM定义的单个原子操作不需要同步。</p>
<hr>
<h2 id="117-同步方法">11.7 同步方法</h2>
<p>我们知道Java程序依靠synchronized对线程进行同步，使用synchronized的时候，锁住的是哪个对象非常重要。</p>
<p>让线程自己选择锁对象往往会使得代码逻辑混乱，也不利于封装。更好的方法是把synchronized逻辑封装起来。例如，我们编写一个计数器如下：</p>
<pre><code>public class Counter {
    private int count = 0;

    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }

    public void dec(int n) {
        synchronized(this) {
            count -= n;
        }
    }

    public int get() {
        return count;
    }
}
</code></pre><p>这样一来，线程调用add()、dec()方法时，它不必关心同步逻辑，因为synchronized代码块在add()、dec()方法内部。并且，我们注意到，synchronized锁住的对象是this，即当前实例，这又使得创建多个Counter实例的时候，它们之间互不影响，可以并发执行：</p>
<pre><code>var c1 = Counter();
var c2 = Counter();

// 对c1进行操作的线程:
new Thread(() -&gt; {
    c1.add();
}).start();
new Thread(() -&gt; {
    c1.dec();
}).start();

// 对c2进行操作的线程:
new Thread(() -&gt; {
    c2.add();
}).start();
new Thread(() -&gt; {
    c2.dec();
}).start();
</code></pre><p>现在，对于Counter类，多线程可以正确调用。</p>
<p>如果一个类被设计为允许多线程正确访问，我们就说这个类就是“线程安全”的（thread-safe），上面的Counter类就是线程安全的。Java标准库的java.lang.StringBuffer也是线程安全的。</p>
<p>还有一些不变类，例如String，Integer，LocalDate，它们的所有成员变量都是final，多线程同时访问时只能读不能写，这些不变类也是线程安全的。</p>
<p>最后，类似Math这些只提供静态方法，没有成员变量的类，也是线程安全的。</p>
<p>除了上述几种少数情况，大部分类，例如ArrayList，都是非线程安全的类，我们不能在多线程中修改它们。但是，如果所有线程都只读取，不写入，那么ArrayList是可以安全地在线程间共享的。</p>
<ul>
<li>没有特殊说明时，一个类默认是非线程安全的。</li>
</ul>
<p>我们再观察Counter的代码：</p>
<pre><code>public class Counter {
    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }
    ...
}
</code></pre><p>当我们锁住的是this实例时，实际上可以用synchronized修饰这个方法。下面两种写法是等价的：</p>
<pre><code>public void add(int n) {
    synchronized(this) { // 锁住this
        count += n;
    } // 解锁
}
</code></pre><pre><code>public synchronized void add(int n) { // 锁住this
    count += n;
} // 解锁
</code></pre><p>因此，用synchronized修饰的方法就是同步方法，它表示整个方法都必须用this实例加锁。</p>
<p>我们再思考一下，如果对一个静态方法添加synchronized修饰符，它锁住的是哪个对象？</p>
<pre><code>public synchronized static void test(int n) {
    ...
}
</code></pre><p>对于static方法，是没有this实例的，因为static方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的Class实例，因此，对static方法添加synchronized，锁住的是该类的class实例。上述synchronized static方法实际上相当于：</p>
<pre><code>public class Counter {
    public static void test(int n) {
        synchronized(Counter.class) {
            ...
        }
    }
}
</code></pre><p>我们再考察Counter的get()方法：</p>
<pre><code>public class Counter {
    private int count;

    public int get() {
        return count;
    }
    ...
}
</code></pre><p>它没有同步，因为读一个int变量不需要同步。</p>
<p>然而，如果我们把代码稍微改一下，返回一个包含两个int的对象：</p>
<pre><code>public class Counter {
    private int first;
    private int last;

    public Pair get() {
        Pair p = new Pair();
        p.first = first;
        p.last = last;
        return p;
    }
    ...
}
</code></pre><p>就必须要同步了。</p>
<h3 id="小结-8">小结</h3>
<p>用synchronized修饰方法可以把整个方法变为同步代码块，synchronized方法加锁对象是this；</p>
<p>通过合理的设计和数据封装可以让一个类变为“线程安全”；</p>
<p>一个类没有特殊说明，默认不是thread-safe；</p>
<p>多线程能否安全访问某个非线程安全的实例，需要具体问题具体分析。</p>
<hr>
<h2 id="118-死锁">11.8 死锁</h2>
<p>Java的线程锁是可重入的锁。</p>
<p>什么是可重入的锁？我们还是来看例子：</p>
<pre><code>public class Counter {
    private int count = 0;

    public synchronized void add(int n) {
        if (n &lt; 0) {
            dec(-n);
        } else {
            count += n;
        }
    }

    public synchronized void dec(int n) {
        count += n;
    }
}
</code></pre><p>观察synchronized修饰的add()方法，一旦线程执行到add()方法内部，说明它已经获取了当前实例的this锁。如果传入的n &lt; 0，将在add()方法内部调用dec()方法。由于dec()方法也需要获取this锁，现在问题来了：</p>
<p>对同一个线程，能否在获取到锁以后继续获取同一个锁？</p>
<p>答案是肯定的。JVM允许同一个线程重复获取同一个锁，这种能被同一个线程反复获取的锁，就叫做可重入锁。</p>
<p>由于Java的线程锁是可重入锁，所以，获取锁的时候，不但要判断是否是第一次获取，还要记录这是第几次获取。每获取一次锁，记录+1，每退出synchronized块，记录-1，减到0的时候，才会真正释放锁。</p>
<h3 id="死锁">死锁</h3>
<p>一个线程可以获取一个锁后，再继续获取另一个锁。例如：</p>
<pre><code>public void add(int m) {
    synchronized(lockA) { // 获得lockA的锁
        this.value += m;
        synchronized(lockB) { // 获得lockB的锁
            this.another += m;
        } // 释放lockB的锁
    } // 释放lockA的锁
}

public void dec(int m) {
    synchronized(lockB) { // 获得lockB的锁
        this.another -= m;
        synchronized(lockA) { // 获得lockA的锁
            this.value -= m;
        } // 释放lockA的锁
    } // 释放lockB的锁
}
</code></pre><p>在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行add()和dec()方法时：</p>
<ul>
<li>线程1：进入add()，获得lockA；</li>
<li>线程2：进入dec()，获得lockB。</li>
</ul>
<p>随后：</p>
<ul>
<li>线程1：准备获得lockB，失败，等待中；</li>
<li>线程2：准备获得lockA，失败，等待中。</li>
</ul>
<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>
<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p>
<p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p>
<p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取lockA，再获取lockB的顺序，改写dec()方法如下：</p>
<pre><code>public void dec(int m) {
    synchronized(lockA) { // 获得lockA的锁
        this.value -= m;
        synchronized(lockB) { // 获得lockB的锁
            this.another -= m;
        } // 释放lockB的锁
    } // 释放lockA的锁
}
</code></pre><h3 id="小结-9">小结</h3>
<p>Java的synchronized锁是可重入锁；</p>
<p>死锁产生的条件是多线程各自持有不同的锁，并互相试图获取对方已持有的锁，导致无限等待；</p>
<p>避免死锁的方法是多线程获取锁的顺序要一致。</p>
<hr>
<h2 id="119-使用wait和notify">11.9 使用wait和notify</h2>
<p>在Java程序中，synchronized解决了多线程竞争的问题。例如，对于一个任务管理器，多个线程同时往队列中添加任务，可以用synchronized加锁：</p>
<pre><code>class TaskQueue {
    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public synchronized void addTask(String s) {
        this.queue.add(s);
    }
}
</code></pre><p>但是synchronized并没有解决多线程协调的问题。</p>
<p>仍然以上面的TaskQueue为例，我们再编写一个getTask()方法取出队列的第一个任务：</p>
<pre><code>class TaskQueue {
    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public synchronized void addTask(String s) {
        this.queue.add(s);
    }

    public synchronized String getTask() {
        while (queue.isEmpty()) {
        }
        return queue.remove();
    }
}
</code></pre><p>上述代码看上去没有问题：getTask()内部先判断队列是否为空，如果为空，就循环等待，直到另一个线程往队列中放入了一个任务，while()循环退出，就可以返回队列的元素了。</p>
<p>但实际上while()循环永远不会退出。因为线程在执行while()循环时，已经在getTask()入口获取了this锁，其他线程根本无法调用addTask()，因为addTask()执行条件也是获取this锁。</p>
<p>因此，执行上述代码，线程会在getTask()中因为死循环而100%占用CPU资源。</p>
<p>如果深入思考一下，我们想要的执行效果是：</p>
<ul>
<li>线程1可以调用addTask()不断往队列中添加任务；</li>
<li>线程2可以调用getTask()从队列中获取任务。如果队列为空，则getTask()应该等待，直到队列中至少有一个任务时再返回。</li>
</ul>
<p>因此，多线程协调运行的原则就是：当条件不满足时，线程进入等待状态；当条件满足时，线程被唤醒，继续执行任务。</p>
<p>对于上述TaskQueue，我们先改造getTask()方法，在条件不满足时，线程进入等待状态：</p>
<pre><code>public synchronized String getTask() {
    while (queue.isEmpty()) {
        this.wait();
    }
    return queue.remove();
}
</code></pre><p>当一个线程执行到getTask()方法内部的while循环时，它必定已经获取到了this锁，此时，线程执行while条件判断，如果条件成立（队列为空），线程将执行this.wait()，进入等待状态。</p>
<p>这里的关键是：wait()方法必须在当前获取的锁对象上调用，这里获取的是this锁，因此调用this.wait()。</p>
<p>调用wait()方法后，线程进入等待状态，wait()方法不会返回，直到将来某个时刻，线程从等待状态被其他线程唤醒后，wait()方法才会返回，然后，继续执行下一条语句。</p>
<p>有些仔细的童鞋会指出：即使线程在getTask()内部等待，其他线程如果拿不到this锁，照样无法执行addTask()，肿么办？</p>
<p>这个问题的关键就在于wait()方法的执行机制非常复杂。首先，它不是一个普通的Java方法，而是定义在Object类的一个native方法，也就是由JVM的C代码实现的。其次，必须在synchronized块中才能调用wait()方法，因为wait()方法调用时，会释放线程获得的锁，wait()方法返回后，线程又会重新试图获得锁。</p>
<p>因此，只能在锁对象上调用wait()方法。因为在getTask()中，我们获得了this锁，因此，只能在this对象上调用wait()方法：</p>
<pre><code>public synchronized String getTask() {
    while (queue.isEmpty()) {
        // 释放this锁:
        this.wait();
        // 重新获取this锁
    }
    return queue.remove();
}
</code></pre><p>当一个线程在this.wait()等待时，它就会释放this锁，从而使得其他线程能够在addTask()方法获得this锁。</p>
<p>现在我们面临第二个问题：如何让等待的线程被重新唤醒，然后从wait()方法返回？答案是在相同的锁对象上调用notify()方法。我们修改addTask()如下：</p>
<pre><code>public synchronized void addTask(String s) {
    this.queue.add(s);
    this.notify(); // 唤醒在this锁等待的线程
}
</code></pre><p>注意到在往队列中添加了任务后，线程立刻对this锁对象调用notify()方法，这个方法会唤醒一个正在this锁等待的线程（就是在getTask()中位于this.wait()的线程），从而使得等待线程从this.wait()方法返回。</p>
<p>我们来看一个完整的例子：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws InterruptedException {
        var q = new TaskQueue();
        var ts = new ArrayList&lt;Thread&gt;();
        for (int i=0; i&lt;5; i++) {
            var t = new Thread() {
                public void run() {
                    // 执行task:
                    while (true) {
                        try {
                            String s = q.getTask();
                            System.out.println(&quot;execute task: &quot; + s);
                        } catch (InterruptedException e) {
                            return;
                        }
                    }
                }
            };
            t.start();
            ts.add(t);
        }
        var add = new Thread(() -&gt; {
            for (int i=0; i&lt;10; i++) {
                // 放入task:
                String s = &quot;t-&quot; + Math.random();
                System.out.println(&quot;add task: &quot; + s);
                q.addTask(s);
                try { Thread.sleep(100); } catch(InterruptedException e) {}
            }
        });
        add.start();
        add.join();
        Thread.sleep(100);
        for (var t : ts) {
            t.interrupt();
        }
    }
}

class TaskQueue {
    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public synchronized void addTask(String s) {
        this.queue.add(s);
        this.notifyAll();
    }

    public synchronized String getTask() throws InterruptedException {
        while (queue.isEmpty()) {
            this.wait();
        }
        return queue.remove();
    }
}
</code></pre><p>这个例子中，我们重点关注addTask()方法，内部调用了this.notifyAll()而不是this.notify()，使用notifyAll()将唤醒所有当前正在this锁等待的线程，而notify()只会唤醒其中一个（具体哪个依赖操作系统，有一定的随机性）。这是因为可能有多个线程正在getTask()方法内部的wait()中等待，使用notifyAll()将一次性全部唤醒。通常来说，notifyAll()更安全。有些时候，如果我们的代码逻辑考虑不周，用notify()会导致只唤醒了一个线程，而其他线程可能永远等待下去醒不过来了。</p>
<p>但是，注意到wait()方法返回时需要重新获得this锁。假设当前有3个线程被唤醒，唤醒后，首先要等待执行addTask()的线程结束此方法后，才能释放this锁，随后，这3个线程中只能有一个获取到this锁，剩下两个将继续等待。</p>
<p>再注意到我们在while()循环中调用wait()，而不是if语句：</p>
<pre><code>public synchronized String getTask() throws InterruptedException {
    if (queue.isEmpty()) {
        this.wait();
    }
    return queue.remove();
}
</code></pre><p>这种写法实际上是错误的，因为线程被唤醒时，需要再次获取this锁。多个线程被唤醒后，只有一个线程能获取this锁，此刻，该线程执行queue.remove()可以获取到队列的元素，然而，剩下的线程如果获取this锁后执行queue.remove()，此刻队列可能已经没有任何元素了，所以，要始终在while循环中wait()，并且每次被唤醒后拿到this锁就必须再次判断：</p>
<pre><code>while (queue.isEmpty()) {
    this.wait();
}
</code></pre><p>所以，正确编写多线程代码是非常困难的，需要仔细考虑的条件非常多，任何一个地方考虑不周，都会导致多线程运行时不正常。</p>
<h3 id="小结-10">小结</h3>
<p>wait和notify用于多线程协调运行：</p>
<ul>
<li>在synchronized内部可以调用wait()使线程进入等待状态；</li>
<li>必须在已获得的锁对象上调用wait()方法；</li>
<li>在synchronized内部可以调用notify()或notifyAll()唤醒其他等待线程；</li>
<li>必须在已获得的锁对象上调用notify()或notifyAll()方法；</li>
<li>已唤醒的线程还需要重新获得锁后才能继续执行。</li>
</ul>
<hr>
<h2 id="1110-使用reentrantlock">11.10 使用ReentrantLock</h2>
<p>从Java 5开始，引入了一个高级的处理并发的java.util.concurrent包，它提供了大量更高级的并发功能，能大大简化多线程程序的编写。</p>
<p>我们知道Java语言直接提供了synchronized关键字用于加锁，但这种锁一是很重，二是获取时必须一直等待，没有额外的尝试机制。</p>
<p>java.util.concurrent.locks包提供的ReentrantLock用于替代synchronized加锁，我们来看一下传统的synchronized代码：</p>
<pre><code>public class Counter {
    private int count;

    public void add(int n) {
        synchronized(this) {
            count += n;
        }
    }
}
</code></pre><p>如果用ReentrantLock替代，可以把代码改造为：</p>
<pre><code>public class Counter {
    private final Lock lock = new ReentrantLock();
    private int count;

    public void add(int n) {
        lock.lock();
        try {
            count += n;
        } finally {
            lock.unlock();
        }
    }
}
</code></pre><p>因为synchronized是Java语言层面提供的语法，所以我们不需要考虑异常，而ReentrantLock是Java代码实现的锁，我们就必须先获取锁，然后在finally中正确释放锁。</p>
<p>顾名思义，ReentrantLock是可重入锁，它和synchronized一样，一个线程可以多次获取同一个锁。</p>
<p>和synchronized不同的是，ReentrantLock可以尝试获取锁：</p>
<pre><code>if (lock.tryLock(1, TimeUnit.SECONDS)) {
    try {
        ...
    } finally {
        lock.unlock();
    }
}
</code></pre><p>上述代码在尝试获取锁的时候，最多等待1秒。如果1秒后仍未获取到锁，tryLock()返回false，程序就可以做一些额外处理，而不是无限等待下去。</p>
<p>所以，使用ReentrantLock比直接使用synchronized更安全，线程在tryLock()失败的时候不会导致死锁。</p>
<h3 id="小结-11">小结</h3>
<p>ReentrantLock可以替代synchronized进行同步；</p>
<p>ReentrantLock获取锁更安全；</p>
<p>必须先获取到锁，再进入try {&hellip;}代码块，最后使用finally保证释放锁；</p>
<p>可以使用tryLock()尝试获取锁。</p>
<hr>
<h2 id="1111-使用condition">11.11 使用Condition</h2>
<p>使用ReentrantLock比直接使用synchronized更安全，可以替代synchronized进行线程同步。</p>
<p>但是，synchronized可以配合wait和notify实现线程在条件不满足时等待，条件满足时唤醒，用ReentrantLock我们怎么编写wait和notify的功能呢？</p>
<p>答案是使用Condition对象来实现wait和notify的功能。</p>
<p>我们仍然以TaskQueue为例，把前面用synchronized实现的功能通过ReentrantLock和Condition来实现：</p>
<pre><code>class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public String getTask() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                condition.await();
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre><p>可见，使用Condition时，引用的Condition对象必须从Lock实例的newCondition()返回，这样才能获得一个绑定了Lock实例的Condition实例。</p>
<p>Condition提供的await()、signal()、signalAll()原理和synchronized锁对象的wait()、notify()、notifyAll()是一致的，并且其行为也是一样的：</p>
<ul>
<li>await()会释放当前锁，进入等待状态；</li>
<li>signal()会唤醒某个等待线程；</li>
<li>signalAll()会唤醒所有等待线程；</li>
<li>唤醒线程从await()返回后需要重新获得锁。</li>
</ul>
<p>此外，和tryLock()类似，await()可以在等待指定时间后，如果还没有被其他线程通过signal()或signalAll()唤醒，可以自己醒来：</p>
<pre><code>if (condition.await(1, TimeUnit.SECOND)) {
    // 被其他线程唤醒
} else {
    // 指定时间内没有被其他线程唤醒
}
</code></pre><p>可见，使用Condition配合Lock，我们可以实现更灵活的线程同步。</p>
<h3 id="小结-12">小结</h3>
<p>Condition可以替代wait和notify；</p>
<p>Condition对象必须从Lock对象获取。</p>
<hr>
<h2 id="1112-使用readwritelock">11.12 使用ReadWriteLock</h2>
<p>前面讲到的ReentrantLock保证了只有一个线程可以执行临界区代码：</p>
<pre><code>public class Counter {
    private final Lock lock = new ReentrantLock();
    private int[] counts = new int[10];

    public void inc(int index) {
        lock.lock();
        try {
            counts[index] += 1;
        } finally {
            lock.unlock();
        }
    }

    public int[] get() {
        lock.lock();
        try {
            return Arrays.copyOf(counts, counts.length);
        } finally {
            lock.unlock();
        }
    }
}
</code></pre><p>但是有些时候，这种保护有点过头。因为我们发现，任何时刻，只允许一个线程修改，也就是调用inc()方法是必须获取锁，但是，get()方法只读取数据，不修改数据，它实际上允许多个线程同时调用。</p>
<p>实际上我们想要的是：允许多个线程同时读，但只要有一个线程在写，其他线程就必须等待：
|      | 读     | 写     |
| :&mdash; | :&mdash;&ndash; | :&mdash;&ndash; |
| 读   | 允许   | 不允许 |
| 写   | 不允许 | 不允许 |</p>
<p>使用ReadWriteLock可以解决这个问题，它保证：</p>
<ul>
<li>只允许一个线程写入（其他线程既不能写入也不能读取）；</li>
<li>没有写入时，多个线程允许同时读（提高性能）。</li>
</ul>
<p>用ReadWriteLock实现这个功能十分容易。我们需要创建一个ReadWriteLock实例，然后分别获取读锁和写锁：</p>
<pre><code>public class Counter {
    private final ReadWriteLock rwlock = new ReentrantReadWriteLock();
    private final Lock rlock = rwlock.readLock();
    private final Lock wlock = rwlock.writeLock();
    private int[] counts = new int[10];

    public void inc(int index) {
        wlock.lock(); // 加写锁
        try {
            counts[index] += 1;
        } finally {
            wlock.unlock(); // 释放写锁
        }
    }

    public int[] get() {
        rlock.lock(); // 加读锁
        try {
            return Arrays.copyOf(counts, counts.length);
        } finally {
            rlock.unlock(); // 释放读锁
        }
    }
}
</code></pre><p>把读写操作分别用读锁和写锁来加锁，在读取时，多个线程可以同时获得读锁，这样就大大提高了并发读的执行效率。</p>
<p>使用ReadWriteLock时，适用条件是同一个数据，有大量线程读取，但仅有少数线程修改。</p>
<p>例如，一个论坛的帖子，回复可以看做写入操作，它是不频繁的，但是，浏览可以看做读取操作，是非常频繁的，这种情况就可以使用ReadWriteLock。</p>
<h3 id="小结-13">小结</h3>
<p>使用ReadWriteLock可以提高读取效率：</p>
<ul>
<li>ReadWriteLock只允许一个线程写入；</li>
<li>ReadWriteLock允许多个线程在没有写入时同时读取；</li>
<li>ReadWriteLock适合读多写少的场景。</li>
</ul>
<hr>
<h2 id="1112-使用stampedlock">11.12 使用StampedLock</h2>
<p>前面介绍的ReadWriteLock可以解决多线程同时读，但只有一个线程能写的问题。</p>
<p>如果我们深入分析ReadWriteLock，会发现它有个潜在的问题：如果有线程正在读，写线程需要等待读线程释放锁后才能获取写锁，即读的过程中不允许写，这是一种悲观的读锁。</p>
<p>要进一步提升并发执行效率，Java 8引入了新的读写锁：StampedLock。</p>
<p>StampedLock和ReadWriteLock相比，改进之处在于：读的过程中也允许获取写锁后写入！这样一来，我们读的数据就可能不一致，所以，需要一点额外的代码来判断读的过程中是否有写入，这种读锁是一种乐观锁。</p>
<p>乐观锁的意思就是乐观地估计读的过程中大概率不会有写入，因此被称为乐观锁。反过来，悲观锁则是读的过程中拒绝有写入，也就是写入必须等待。显然乐观锁的并发效率更高，但一旦有小概率的写入导致读取的数据不一致，需要能检测出来，再读一遍就行。</p>
<pre><code>public class Point {
    private final StampedLock stampedLock = new StampedLock();

    private double x;
    private double y;

    public void move(double deltaX, double deltaY) {
        long stamp = stampedLock.writeLock(); // 获取写锁
        try {
            x += deltaX;
            y += deltaY;
        } finally {
            stampedLock.unlockWrite(stamp); // 释放写锁
        }
    }

    public double distanceFromOrigin() {
        long stamp = stampedLock.tryOptimisticRead(); // 获得一个乐观读锁
        // 注意下面两行代码不是原子操作
        // 假设x,y = (100,200)
        double currentX = x;
        // 此处已读取到x=100，但x,y可能被写线程修改为(300,400)
        double currentY = y;
        // 此处已读取到y，如果没有写入，读取是正确的(100,200)
        // 如果有写入，读取是错误的(100,400)
        if (!stampedLock.validate(stamp)) { // 检查乐观读锁后是否有其他写锁发生
            stamp = stampedLock.readLock(); // 获取一个悲观读锁
            try {
                currentX = x;
                currentY = y;
            } finally {
                stampedLock.unlockRead(stamp); // 释放悲观读锁
            }
        }
        return Math.sqrt(currentX * currentX + currentY * currentY);
    }
}
</code></pre><p>和ReadWriteLock相比，写入的加锁是完全一样的，不同的是读取。注意到首先我们通过tryOptimisticRead()获取一个乐观读锁，并返回版本号。接着进行读取，读取完成后，我们通过validate()去验证版本号，如果在读取过程中没有写入，版本号不变，验证成功，我们就可以放心地继续后续操作。如果在读取过程中有写入，版本号会发生变化，验证将失败。在失败的时候，我们再通过获取悲观读锁再次读取。由于写入的概率不高，程序在绝大部分情况下可以通过乐观读锁获取数据，极少数情况下使用悲观读锁获取数据。</p>
<p>可见，StampedLock把读锁细分为乐观读和悲观读，能进一步提升并发效率。但这也是有代价的：一是代码更加复杂，二是StampedLock是不可重入锁，不能在一个线程中反复获取同一个锁。</p>
<p>StampedLock还提供了更复杂的将悲观读锁升级为写锁的功能，它主要使用在if-then-update的场景：即先读，如果读的数据满足条件，就返回，如果读的数据不满足条件，再尝试写。</p>
<h3 id="小结-14">小结</h3>
<p>StampedLock提供了乐观读锁，可取代ReadWriteLock以进一步提升并发性能；</p>
<p>StampedLock是不可重入锁。</p>
<hr>
<h2 id="1113-使用concurrent集合">11.13 使用Concurrent集合</h2>
<p>我们在前面已经通过ReentrantLock和Condition实现了一个BlockingQueue：</p>
<pre><code>public class TaskQueue {
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();
    private Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();

    public void addTask(String s) {
        lock.lock();
        try {
            queue.add(s);
            condition.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public String getTask() {
        lock.lock();
        try {
            while (queue.isEmpty()) {
                condition.await();
            }
            return queue.remove();
        } finally {
            lock.unlock();
        }
    }
}
</code></pre><p>BlockingQueue的意思就是说，当一个线程调用这个TaskQueue的getTask()方法时，该方法内部可能会让线程变成等待状态，直到队列条件满足不为空，线程被唤醒后，getTask()方法才会返回。</p>
<p>因为BlockingQueue非常有用，所以我们不必自己编写，可以直接使用Java标准库的java.util.concurrent包提供的线程安全的集合：ArrayBlockingQueue。</p>
<p>除了BlockingQueue外，针对List、Map、Set、Deque等，java.util.concurrent包也提供了对应的并发集合类。我们归纳一下：</p>
<table>
<thead>
<tr>
<th align="left">interface</th>
<th align="left">non-thread-safe</th>
<th align="left">thread-safe</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">List</td>
<td align="left">ArrayList</td>
<td align="left">CopyOnWriteArrayList</td>
</tr>
<tr>
<td align="left">Map</td>
<td align="left">HashMap</td>
<td align="left">ConcurrentHashMap</td>
</tr>
<tr>
<td align="left">Set</td>
<td align="left">HashSet/TreeSet</td>
<td align="left">CopyOnWriteArraySet</td>
</tr>
<tr>
<td align="left">Queue</td>
<td align="left">ArrayDeque / LinkedList</td>
<td align="left">ArrayBlockingQueue / LinkedBlockingQueue</td>
</tr>
<tr>
<td align="left">Deque</td>
<td align="left">ArrayDeque / LinkedList</td>
<td align="left">LinkedBlockingDeque</td>
</tr>
</tbody>
</table>
<p>使用这些并发集合与使用非线程安全的集合类完全相同。我们以ConcurrentHashMap为例：</p>
<pre><code>Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
// 在不同的线程读写:
map.put(&quot;A&quot;, &quot;1&quot;);
map.put(&quot;B&quot;, &quot;2&quot;);
map.get(&quot;A&quot;, &quot;1&quot;);
</code></pre><p>因为所有的同步和加锁的逻辑都在集合内部实现，对外部调用者来说，只需要正常按接口引用，其他代码和原来的非线程安全代码完全一样。即当我们需要多线程访问时，把：</p>
<pre><code>Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
</code></pre><p>改为：</p>
<pre><code>Map&lt;String, String&gt; map = new ConcurrentHashMap&lt;&gt;();
</code></pre><p>java.util.Collections工具类还提供了一个旧的线程安全集合转换器，可以这么用：</p>
<pre><code>Map unsafeMap = new HashMap();
Map threadSafeMap = Collections.synchronizedMap(unsafeMap);
</code></pre><p>但是它实际上是用一个包装类包装了非线程安全的Map，然后对所有读写方法都用synchronized加锁，这样获得的线程安全集合的性能比java.util.concurrent集合要低很多，所以不推荐使用。</p>
<h3 id="小结-15">小结</h3>
<p>使用java.util.concurrent包提供的线程安全的并发集合可以大大简化多线程编程：</p>
<p>多线程同时读写并发集合是安全的；</p>
<p>尽量使用Java标准库提供的并发集合，避免自己编写同步代码。</p>
<hr>
<h2 id="1114-使用atomic">11.14 使用Atomic</h2>
<p>Java的java.util.concurrent包除了提供底层锁、并发集合外，还提供了一组原子操作的封装类，它们位于java.util.concurrent.atomic包。</p>
<p>我们以AtomicInteger为例，它提供的主要操作有：</p>
<ul>
<li>增加值并返回新值：int addAndGet(int delta)</li>
<li>加1后返回新值：int incrementAndGet()</li>
<li>获取当前值：int get()</li>
<li>用CAS方式设置：int compareAndSet(int expect, int update)</li>
</ul>
<p>Atomic类是通过无锁（lock-free）的方式实现的线程安全（thread-safe）访问。它的主要原理是利用了CAS：Compare and Set。</p>
<p>如果我们自己通过CAS编写incrementAndGet()，它大概长这样：</p>
<pre><code>public int incrementAndGet(AtomicInteger var) {
    int prev, next;
    do {
        prev = var.get();
        next = prev + 1;
    } while ( ! var.compareAndSet(prev, next));
    return prev;
}
</code></pre><p>CAS是指，在这个操作中，如果AtomicInteger的当前值是prev，那么就更新为next，返回true。如果AtomicInteger的当前值不是prev，就什么也不干，返回false。通过CAS操作并配合do &hellip; while循环，即使其他线程修改了AtomicInteger的值，最终的结果也是正确的。</p>
<p>我们利用AtomicLong可以编写一个多线程安全的全局唯一ID生成器：</p>
<pre><code>class IdGenerator {
    AtomicLong var = new AtomicLong(0);

    public long getNextId() {
        return var.incrementAndGet();
    }
}
</code></pre><p>通常情况下，我们并不需要直接用do &hellip; while循环调用compareAndSet实现复杂的并发操作，而是用incrementAndGet()这样的封装好的方法，因此，使用起来非常简单。</p>
<p>在高度竞争的情况下，还可以使用Java 8提供的LongAdder和LongAccumulator。</p>
<h3 id="小结-16">小结</h3>
<p>使用java.util.concurrent.atomic提供的原子操作可以简化多线程编程：</p>
<ul>
<li>原子操作实现了无锁的线程安全；</li>
<li>适用于计数器，累加器等。</li>
</ul>
<hr>
<h2 id="1115-使用线程池">11.15 使用线程池</h2>
<p>Java语言虽然内置了多线程支持，启动一个新线程非常方便，但是，创建线程需要操作系统资源（线程资源，栈空间等），频繁创建和销毁大量线程需要消耗大量时间。</p>
<p>如果可以复用一组线程：</p>
<pre><code>┌─────┐ execute  ┌──────────────────┐
│Task1│─────────&gt;│ThreadPool        │
├─────┤          │┌───────┐┌───────┐│
│Task2│          ││Thread1││Thread2││
├─────┤          │└───────┘└───────┘│
│Task3│          │┌───────┐┌───────┐│
├─────┤          ││Thread3││Thread4││
│Task4│          │└───────┘└───────┘│
├─────┤          └──────────────────┘
│Task5│
├─────┤
│Task6│
└─────┘
  ...
</code></pre><p>那么我们就可以把很多小任务让一组线程来执行，而不是一个任务对应一个新线程。这种能接收大量小任务并进行分发处理的就是线程池。</p>
<p>简单地说，线程池内部维护了若干个线程，没有任务的时候，这些线程都处于等待状态。如果有新任务，就分配一个空闲线程执行。如果所有线程都处于忙碌状态，新任务要么放入队列等待，要么增加一个新线程进行处理。</p>
<p>Java标准库提供了ExecutorService接口表示线程池，它的典型用法如下：</p>
<pre><code>// 创建固定大小的线程池:
ExecutorService executor = Executors.newFixedThreadPool(3);
// 提交任务:
executor.submit(task1);
executor.submit(task2);
executor.submit(task3);
executor.submit(task4);
executor.submit(task5);
</code></pre><p>因为ExecutorService只是接口，Java标准库提供的几个常用实现类有：</p>
<ul>
<li>FixedThreadPool：线程数固定的线程池；</li>
<li>CachedThreadPool：线程数根据任务动态调整的线程池；</li>
<li>SingleThreadExecutor：仅单线程执行的线程池。</li>
</ul>
<p>创建这些线程池的方法都被封装到Executors这个类中。我们以FixedThreadPool为例，看看线程池的执行逻辑：</p>
<pre><code>import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        // 创建一个固定大小的线程池:
        ExecutorService es = Executors.newFixedThreadPool(4);
        for (int i = 0; i &lt; 6; i++) {
            es.submit(new Task(&quot;&quot; + i));
        }
        // 关闭线程池:
        es.shutdown();
    }
}

class Task implements Runnable {
    private final String name;

    public Task(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(&quot;start task &quot; + name);
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
        System.out.println(&quot;end task &quot; + name);
    }
}
</code></pre><p>我们观察执行结果，一次性放入6个任务，由于线程池只有固定的4个线程，因此，前4个任务会同时执行，等到有线程空闲后，才会执行后面的两个任务。</p>
<p>线程池在程序结束的时候要关闭。使用shutdown()方法关闭线程池的时候，它会等待正在执行的任务先完成，然后再关闭。shutdownNow()会立刻停止正在执行的任务，awaitTermination()则会等待指定的时间让线程池关闭。</p>
<p>如果我们把线程池改为CachedThreadPool，由于这个线程池的实现会根据任务数量动态调整线程池的大小，所以6个任务可一次性全部同时执行。</p>
<p>如果我们想把线程池的大小限制在4～10个之间动态调整怎么办？我们查看Executors.newCachedThreadPool()方法的源码：</p>
<pre><code>public static ExecutorService newCachedThreadPool() {
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                    60L, TimeUnit.SECONDS,
                                    new SynchronousQueue&lt;Runnable&gt;());
}
</code></pre><p>因此，想创建指定动态范围的线程池，可以这么写：</p>
<pre><code>int min = 4;
int max = 10;
ExecutorService es = new ThreadPoolExecutor(min, max,
        60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());
</code></pre><h3 id="scheduledthreadpool">ScheduledThreadPool</h3>
<p>还有一种任务，需要定期反复执行，例如，每秒刷新证券价格。这种任务本身固定，需要反复执行的，可以使用ScheduledThreadPool。放入ScheduledThreadPool的任务可以定期反复执行。</p>
<p>创建一个ScheduledThreadPool仍然是通过Executors类：</p>
<pre><code>ScheduledExecutorService ses = Executors.newScheduledThreadPool(4);
</code></pre><p>我们可以提交一次性任务，它会在指定延迟后只执行一次：</p>
<pre><code>// 1秒后执行一次性任务:
ses.schedule(new Task(&quot;one-time&quot;), 1, TimeUnit.SECONDS);
</code></pre><p>如果任务以固定的每3秒执行，我们可以这样写：</p>
<pre><code>// 2秒后开始执行定时任务，以3秒为间隔执行:
ses.scheduleWithFixedDelay(new Task(&quot;fixed-delay&quot;), 2, 3, TimeUnit.SECONDS);
</code></pre><p>注意FixedRate和FixedDelay的区别。</p>
<p>FixedRate是指任务总是以固定时间间隔触发，不管任务执行多长时间：</p>
<pre><code>│░░░░   │░░░░░░ │░░░    │░░░░░  │░░░  
├───────┼───────┼───────┼───────┼────&gt;
│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│&lt;─────&gt;│
</code></pre><p>而FixedDelay是指，上一次任务执行完毕后，等待固定的时间间隔，再执行下一次任务：</p>
<pre><code>│░░░│       │░░░░░│       │░░│       │░ 
└───┼───────┼─────┼───────┼──┼───────┼──&gt;
    │&lt;─────&gt;│     │&lt;─────&gt;│  │&lt;─────&gt;│
</code></pre><p>因此，使用ScheduledThreadPool时，我们要根据需要选择执行一次、FixedRate执行还是FixedDelay执行。</p>
<p>细心的童鞋还可以思考下面的问题：</p>
<ul>
<li>在FixedRate模式下，假设每秒触发，如果某次任务执行时间超过1秒，后续任务会不会并发执行？</li>
<li>如果任务抛出了异常，后续任务是否继续执行？</li>
</ul>
<p>Java标准库还提供了一个java.util.Timer类，这个类也可以定期执行任务，但是，一个Timer会对应一个Thread，所以，一个Timer只能定期执行一个任务，多个定时任务必须启动多个Timer，而一个ScheduledThreadPool就可以调度多个定时任务，所以，我们完全可以用ScheduledThreadPool取代旧的Timer。</p>
<h3 id="小结-17">小结</h3>
<p>JDK提供了ExecutorService实现了线程池功能：</p>
<ul>
<li>线程池内部维护一组线程，可以高效执行大量小任务；</li>
<li>Executors提供了静态方法创建不同类型的ExecutorService；</li>
<li>必须调用shutdown()关闭ExecutorService；</li>
<li>ScheduledThreadPool可以定期调度多个任务。</li>
</ul>
<hr>
<h2 id="1116-使用future">11.16 使用Future</h2>
<p>在执行多个任务的时候，使用Java标准库提供的线程池是非常方便的。我们提交的任务只需要实现Runnable接口，就可以让线程池去执行：</p>
<pre><code>class Task implements Runnable {
    public String result;

    public void run() {
        this.result = longTimeCalculation(); 
    }
}
</code></pre><p>Runnable接口有个问题，它的方法没有返回值。如果任务需要一个返回结果，那么只能保存到变量，还要提供额外的方法读取，非常不便。所以，Java标准库还提供了一个Callable接口，和Runnable接口比，它多了一个返回值：</p>
<pre><code>class Task implements Callable&lt;String&gt; {
    public String call() throws Exception {
        return longTimeCalculation(); 
    }
}
</code></pre><p>并且Callable接口是一个泛型接口，可以返回指定类型的结果。</p>
<p>现在的问题是，如何获得异步执行的结果？</p>
<p>如果仔细看ExecutorService.submit()方法，可以看到，它返回了一个Future类型，一个Future类型的实例代表一个未来能获取结果的对象：</p>
<pre><code>ExecutorService executor = Executors.newFixedThreadPool(4); 
// 定义任务:
Callable&lt;String&gt; task = new Task();
// 提交任务并获得Future:
Future&lt;String&gt; future = executor.submit(task);
// 从Future获取异步执行返回的结果:
String result = future.get(); // 可能阻塞
</code></pre><p>当我们提交一个Callable任务后，我们会同时获得一个Future对象，然后，我们在主线程某个时刻调用Future对象的get()方法，就可以获得异步执行的结果。在调用get()时，如果异步任务已经完成，我们就直接获得结果。如果异步任务还没有完成，那么get()会阻塞，直到任务完成后才返回结果。</p>
<p>一个Future<!-- raw HTML omitted -->接口表示一个未来可能会返回的结果，它定义的方法有：</p>
<ul>
<li>get()：获取结果（可能会等待）</li>
<li>get(long timeout, TimeUnit unit)：获取结果，但只等待指定的时间；</li>
<li>cancel(boolean mayInterruptIfRunning)：取消当前任务；</li>
<li>isDone()：判断任务是否已完成。</li>
</ul>
<h3 id="小结-18">小结</h3>
<p>对线程池提交一个Callable任务，可以获得一个Future对象；</p>
<p>可以用Future在将来某个时刻获取结果。</p>
<hr>
<h2 id="1117-使用completablefuture">11.17 使用CompletableFuture</h2>
<p>使用Future获得异步执行结果时，要么调用阻塞方法get()，要么轮询看isDone()是否为true，这两种方法都不是很好，因为主线程也会被迫等待。</p>
<p>从Java 8开始引入了CompletableFuture，它针对Future做了改进，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。</p>
<p>我们以获取股票价格为例，看看如何使用CompletableFuture：</p>
<pre><code>// CompletableFuture
import java.util.concurrent.CompletableFuture;

public class Main {
    public static void main(String[] args) throws Exception {
        // 创建异步执行任务:
        CompletableFuture&lt;Double&gt; cf = CompletableFuture.supplyAsync(Main::fetchPrice);
        // 如果执行成功:
        cf.thenAccept((result) -&gt; {
            System.out.println(&quot;price: &quot; + result);
        });
        // 如果执行异常:
        cf.exceptionally((e) -&gt; {
            e.printStackTrace();
            return null;
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(2000);
    }

    static Double fetchPrice() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
        }
        if (Math.random() &lt; 0.3) {
            throw new RuntimeException(&quot;fetch price failed!&quot;);
        }
        return 5 + Math.random() * 20;
    }
}
</code></pre><p>创建一个CompletableFuture是通过CompletableFuture.supplyAsync()实现的，它需要一个实现了Supplier接口的对象：</p>
<pre><code>public interface Supplier&lt;T&gt; {
    T get();
}
</code></pre><p>这里我们用lambda语法简化了一下，直接传入Main::fetchPrice，因为Main.fetchPrice()静态方法的签名符合Supplier接口的定义（除了方法名外）。</p>
<p>紧接着，CompletableFuture已经被提交给默认的线程池执行了，我们需要定义的是CompletableFuture完成时和异常时需要回调的实例。完成时，CompletableFuture会调用Consumer对象：</p>
<pre><code>public interface Consumer&lt;T&gt; {
    void accept(T t);
}
</code></pre><p>异常时，CompletableFuture会调用Function对象：</p>
<pre><code>public interface Function&lt;T, R&gt; {
    R apply(T t);
}
</code></pre><p>这里我们都用lambda语法简化了代码。</p>
<p>可见CompletableFuture的优点是：</p>
<ul>
<li>异步任务结束时，会自动回调某个对象的方法；</li>
<li>异步任务出错时，会自动回调某个对象的方法；</li>
<li>主线程设置好回调后，不再关心异步任务的执行。</li>
</ul>
<p>如果只是实现了异步回调机制，我们还看不出CompletableFuture相比Future的优势。CompletableFuture更强大的功能是，多个CompletableFuture可以串行执行，例如，定义两个CompletableFuture，第一个CompletableFuture根据证券名称查询证券代码，第二个CompletableFuture根据证券代码查询证券价格，这两个CompletableFuture实现串行操作如下：</p>
<pre><code>// CompletableFuture
import java.util.concurrent.CompletableFuture;

public class Main {
    public static void main(String[] args) throws Exception {
        // 第一个任务:
        CompletableFuture&lt;String&gt; cfQuery = CompletableFuture.supplyAsync(() -&gt; {
            return queryCode(&quot;中国石油&quot;);
        });
        // cfQuery成功后继续执行下一个任务:
        CompletableFuture&lt;Double&gt; cfFetch = cfQuery.thenApplyAsync((code) -&gt; {
            return fetchPrice(code);
        });
        // cfFetch成功后打印结果:
        cfFetch.thenAccept((result) -&gt; {
            System.out.println(&quot;price: &quot; + result);
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(2000);
    }

    static String queryCode(String name) {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
        }
        return &quot;601857&quot;;
    }

    static Double fetchPrice(String code) {
        try {
            Thread.sleep(500);
        } catch (InterruptedException e) {
        }
        return 5 + Math.random() * 20;
    }
}
</code></pre><p>除了串行执行外，多个CompletableFuture还可以并行执行。例如，我们考虑这样的场景：</p>
<p>同时从新浪和网易查询证券代码，只要任意一个返回结果，就进行下一步查询价格，查询价格也同时从新浪和网易查询，只要任意一个返回结果，就完成操作：</p>
<pre><code>// CompletableFuture
import java.util.concurrent.CompletableFuture;

public class Main {
    public static void main(String[] args) throws Exception {
        // 两个CompletableFuture执行异步查询:
        CompletableFuture&lt;String&gt; cfQueryFromSina = CompletableFuture.supplyAsync(() -&gt; {
            return queryCode(&quot;中国石油&quot;, &quot;https://finance.sina.com.cn/code/&quot;);
        });
        CompletableFuture&lt;String&gt; cfQueryFrom163 = CompletableFuture.supplyAsync(() -&gt; {
            return queryCode(&quot;中国石油&quot;, &quot;https://money.163.com/code/&quot;);
        });

        // 用anyOf合并为一个新的CompletableFuture:
        CompletableFuture&lt;Object&gt; cfQuery = CompletableFuture.anyOf(cfQueryFromSina, cfQueryFrom163);

        // 两个CompletableFuture执行异步查询:
        CompletableFuture&lt;Double&gt; cfFetchFromSina = cfQuery.thenApplyAsync((code) -&gt; {
            return fetchPrice((String) code, &quot;https://finance.sina.com.cn/price/&quot;);
        });
        CompletableFuture&lt;Double&gt; cfFetchFrom163 = cfQuery.thenApplyAsync((code) -&gt; {
            return fetchPrice((String) code, &quot;https://money.163.com/price/&quot;);
        });

        // 用anyOf合并为一个新的CompletableFuture:
        CompletableFuture&lt;Object&gt; cfFetch = CompletableFuture.anyOf(cfFetchFromSina, cfFetchFrom163);

        // 最终结果:
        cfFetch.thenAccept((result) -&gt; {
            System.out.println(&quot;price: &quot; + result);
        });
        // 主线程不要立刻结束，否则CompletableFuture默认使用的线程池会立刻关闭:
        Thread.sleep(2000);
    }

    static String queryCode(String name, String url) {
        System.out.println(&quot;query code from &quot; + url + &quot;...&quot;);
        try {
            Thread.sleep((long) (Math.random() * 1000));
        } catch (InterruptedException e) {
        }
        return &quot;601857&quot;;
    }

    static Double fetchPrice(String code, String url) {
        System.out.println(&quot;query price from &quot; + url + &quot;...&quot;);
        try {
            Thread.sleep((long) (Math.random() * 1000));
        } catch (InterruptedException e) {
        }
        return 5 + Math.random() * 20;
    }
}
</code></pre><p>上述逻辑实现的异步查询规则实际上是：</p>
<pre><code>┌─────────────┐ ┌─────────────┐
│ Query Code  │ │ Query Code  │
│  from sina  │ │  from 163   │
└─────────────┘ └─────────────┘
       │               │
       └───────┬───────┘
               ▼
        ┌─────────────┐
        │    anyOf    │
        └─────────────┘
               │
       ┌───────┴────────┐
       ▼                ▼
┌─────────────┐  ┌─────────────┐
│ Query Price │  │ Query Price │
│  from sina  │  │  from 163   │
└─────────────┘  └─────────────┘
       │                │
       └────────┬───────┘
                ▼
         ┌─────────────┐
         │    anyOf    │
         └─────────────┘
                │
                ▼
         ┌─────────────┐
         │Display Price│
         └─────────────┘
</code></pre><p>除了anyOf()可以实现“任意个CompletableFuture只要一个成功”，allOf()可以实现“所有CompletableFuture都必须成功”，这些组合操作可以实现非常复杂的异步流程控制。</p>
<p>最后我们注意CompletableFuture的命名规则：</p>
<ul>
<li>xxx()：表示该方法将继续在已有的线程中执行；</li>
<li>xxxAsync()：表示将异步在线程池中执行。</li>
</ul>
<h3 id="小结-19">小结</h3>
<p>CompletableFuture可以指定异步处理流程：</p>
<ul>
<li>thenAccept()处理正常结果；</li>
<li>exceptional()处理异常结果；</li>
<li>thenApplyAsync()用于串行化另一个CompletableFuture；</li>
<li>anyOf()和allOf()用于并行化多个CompletableFuture。</li>
</ul>
<hr>
<h2 id="1118-使用forkjoin">11.18 使用ForkJoin</h2>
<p>Java 7开始引入了一种新的Fork/Join线程池，它可以执行一种特殊的任务：把一个大任务拆成多个小任务并行执行。</p>
<p>我们举个例子：如果要计算一个超大数组的和，最简单的做法是用一个循环在一个线程内完成：</p>
<pre><code>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
</code></pre><p>还有一种方法，可以把数组拆成两部分，分别计算，最后加起来就是最终结果，这样可以用两个线程并行执行：</p>
<pre><code>┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
</code></pre><p>如果拆成两部分还是很大，我们还可以继续拆，用4个线程并行执行：</p>
<pre><code>┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
┌─┬─┬─┬─┬─┬─┐
└─┴─┴─┴─┴─┴─┘
</code></pre><p>这就是Fork/Join任务的原理：判断一个任务是否足够小，如果是，直接计算，否则，就分拆成几个小任务分别计算。这个过程可以反复“裂变”成一系列小任务。</p>
<p>我们来看如何使用Fork/Join对大数据进行并行求和：</p>
<pre><code>import java.util.Random;
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) throws Exception {
        // 创建2000个随机数组成的数组:
        long[] array = new long[2000];
        long expectedSum = 0;
        for (int i = 0; i &lt; array.length; i++) {
            array[i] = random();
            expectedSum += array[i];
        }
        System.out.println(&quot;Expected sum: &quot; + expectedSum);
        // fork/join:
        ForkJoinTask&lt;Long&gt; task = new SumTask(array, 0, array.length);
        long startTime = System.currentTimeMillis();
        Long result = ForkJoinPool.commonPool().invoke(task);
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;Fork/join sum: &quot; + result + &quot; in &quot; + (endTime - startTime) + &quot; ms.&quot;);
    }

    static Random random = new Random(0);

    static long random() {
        return random.nextInt(10000);
    }
}

class SumTask extends RecursiveTask&lt;Long&gt; {
    static final int THRESHOLD = 500;
    long[] array;
    int start;
    int end;

    SumTask(long[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Long compute() {
        if (end - start &lt;= THRESHOLD) {
            // 如果任务足够小,直接计算:
            long sum = 0;
            for (int i = start; i &lt; end; i++) {
                sum += this.array[i];
                // 故意放慢计算速度:
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                }
            }
            return sum;
        }
        // 任务太大,一分为二:
        int middle = (end + start) / 2;
        System.out.println(String.format(&quot;split %d~%d ==&gt; %d~%d, %d~%d&quot;, start, end, start, middle, middle, end));
        SumTask subtask1 = new SumTask(this.array, start, middle);
        SumTask subtask2 = new SumTask(this.array, middle, end);
        invokeAll(subtask1, subtask2);
        Long subresult1 = subtask1.join();
        Long subresult2 = subtask2.join();
        Long result = subresult1 + subresult2;
        System.out.println(&quot;result = &quot; + subresult1 + &quot; + &quot; + subresult2 + &quot; ==&gt; &quot; + result);
        return result;
    }
}
</code></pre><p>观察上述代码的执行过程，一个大的计算任务0~2000首先分裂为两个小任务0~1000和1000~2000，这两个小任务仍然太大，继续分裂为更小的0~500，500~1000，1000~1500，1500~2000，最后，计算结果被依次合并，得到最终结果。</p>
<p>因此，核心代码SumTask继承自RecursiveTask，在compute()方法中，关键是如何“分裂”出子任务并且提交子任务：</p>
<pre><code>class SumTask extends RecursiveTask&lt;Long&gt; {
    protected Long compute() {
        // “分裂”子任务:
        SumTask subtask1 = new SumTask(...);
        SumTask subtask2 = new SumTask(...);
        // invokeAll会并行运行两个子任务:
        invokeAll(subtask1, subtask2);
        // 获得子任务的结果:
        Long result1 = fork1.join();
        Long result2 = fork2.join();
        // 汇总结果:
        return result1 + result2;
    }
}
</code></pre><p>Fork/Join线程池在Java标准库中就有应用。Java标准库提供的java.util.Arrays.parallelSort(array)可以进行并行排序，它的原理就是内部通过Fork/Join对大数组分拆进行并行排序，在多核CPU上就可以大大提高排序的速度。</p>
<h3 id="小结-20">小结</h3>
<p>Fork/Join是一种基于“分治”的算法：通过分解任务，并行执行，最后合并结果得到最终结果。</p>
<p>ForkJoinPool线程池可以把一个大任务分拆成小任务并行执行，任务类必须继承自RecursiveTask或RecursiveAction。</p>
<p>使用Fork/Join模式可以进行并行计算以提高效率。</p>
<hr>
<h2 id="1119-使用threadlocal">11.19 使用ThreadLocal</h2>
<p>多线程是Java实现多任务的基础，Thread对象代表一个线程，我们可以在代码中调用Thread.currentThread()获取当前线程。例如，打印日志时，可以同时打印出当前线程的名字：</p>
<pre><code>public class Main {
    public static void main(String[] args) throws Exception {
        log(&quot;start main...&quot;);
        new Thread(() -&gt; {
            log(&quot;run task...&quot;);
        }).start();
        new Thread(() -&gt; {
            log(&quot;print...&quot;);
        }).start();
        log(&quot;end main.&quot;);
    }

    static void log(String s) {
        System.out.println(Thread.currentThread().getName() + &quot;: &quot; + s);
    }
}
</code></pre><p>对于多任务，Java标准库提供的线程池可以方便地执行这些任务，同时复用线程。Web应用程序就是典型的多任务应用，每个用户请求页面时，我们都会创建一个任务，类似：</p>
<pre><code>public void process(User user) {
    checkPermission();
    doWork();
    saveStatus();
    sendResponse();
}
</code></pre><p>然后，通过线程池去执行这些任务。</p>
<p>观察process()方法，它内部需要调用若干其他方法，同时，我们遇到一个问题：如何在一个线程内传递状态？</p>
<p>process()方法需要传递的状态就是User实例。有的童鞋会想，简单地传入User就可以了：</p>
<pre><code>public void process(User user) {
    checkPermission(user);
    doWork(user);
    saveStatus(user);
    sendResponse(user);
}
</code></pre><p>但是往往一个方法又会调用其他很多方法，这样会导致User传递到所有地方：</p>
<pre><code>void doWork(User user) {
    queryStatus(user);
    checkStatus();
    setNewStatus(user);
    log();
}
</code></pre><p>这种在一个线程中，横跨若干方法调用，需要传递的对象，我们通常称之为上下文（Context），它是一种状态，可以是用户身份、任务信息等。</p>
<p>给每个方法增加一个context参数非常麻烦，而且有些时候，如果调用链有无法修改源码的第三方库，User对象就传不进去了。</p>
<p>Java标准库提供了一个特殊的ThreadLocal，它可以在一个线程中传递同一个对象。</p>
<p>ThreadLocal实例通常总是以静态字段初始化如下：</p>
<pre><code>static ThreadLocal&lt;User&gt; threadLocalUser = new ThreadLocal&lt;&gt;();
</code></pre><p>它的典型使用方式如下：</p>
<pre><code>void processUser(user) {
    try {
        threadLocalUser.set(user);
        step1();
        step2();
    } finally {
        threadLocalUser.remove();
    }
}
</code></pre><p>通过设置一个User实例关联到ThreadLocal中，在移除之前，所有方法都可以随时获取到该User实例：</p>
<pre><code>void step1() {
    User u = threadLocalUser.get();
    log();
    printUser();
}

void log() {
    User u = threadLocalUser.get();
    println(u.name);
}

void step2() {
    User u = threadLocalUser.get();
    checkUser(u.id);
}
</code></pre><p>注意到普通的方法调用一定是同一个线程执行的，所以，step1()、step2()以及log()方法内，threadLocalUser.get()获取的User对象是同一个实例。</p>
<p>实际上，可以把ThreadLocal看成一个全局Map&lt;Thread, Object&gt;：每个线程获取ThreadLocal变量时，总是使用Thread自身作为key：</p>
<pre><code>try {
    threadLocalUser.set(user);
    ...
} finally {
    threadLocalUser.remove();
}
</code></pre><p>这是因为当前线程执行完相关代码后，很可能会被重新放入线程池中，如果ThreadLocal没有被清除，该线程执行其他代码时，会把上一次的状态带进去。</p>
<p>为了保证能释放ThreadLocal关联的实例，我们可以通过AutoCloseable接口配合try (resource) {&hellip;}结构，让编译器自动为我们关闭。例如，一个保存了当前用户名的ThreadLocal可以封装为一个UserContext对象：</p>
<pre><code>public class UserContext implements AutoCloseable {

    static final ThreadLocal&lt;String&gt; ctx = new ThreadLocal&lt;&gt;();

    public UserContext(String user) {
        ctx.set(user);
    }

    public static String currentUser() {
        return ctx.get();
    }

    @Override
    public void close() {
        ctx.remove();
    }
}
</code></pre><p>使用的时候，我们借助try (resource) {&hellip;}结构，可以这么写：</p>
<pre><code>try (var ctx = new UserContext(&quot;Bob&quot;)) {
    // 可任意调用UserContext.currentUser():
    String currentUser = UserContext.currentUser();
} // 在此自动调用UserContext.close()方法释放ThreadLocal关联对象

</code></pre><p>这样就在UserContext中完全封装了ThreadLocal，外部代码在try (resource) {&hellip;}内部可以随时调用UserContext.currentUser()获取当前线程绑定的用户名。</p>
<h3 id="小结-21">小结</h3>
<p>ThreadLocal表示线程的“局部变量”，它确保每个线程的ThreadLocal变量都是各自独立的；</p>
<p>ThreadLocal适合在一个线程的处理流程中保持上下文（避免了同一参数在所有方法中传递）；</p>
<p>使用ThreadLocal要用try &hellip; finally结构，并在finally中清除。</p>
<hr>
<h1 id="第12章-网络编程">第12章 网络编程</h1>
<h2 id="121-网络编程基础">12.1 网络编程基础</h2>
<p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p>
<p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用TCP/IP协议。</p>
<p>TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p>
<h3 id="ip地址">IP地址</h3>
<p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>
<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p>
<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li>10.x.x.x</li>
</ul>
<p>有一个特殊的IP地址，称之为本机地址，它总是127.0.0.1。</p>
<p>IPv4地址实际上是一个32位整数。例如：</p>
<pre><code>106717964 = 0x65ca630c
          = 65  ca  63 0c
          = 101.202.99.12
</code></pre><p>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址127.0.0.1，还有一个IP地址，例如101.202.99.12，可以通过这个IP地址接入网络。</p>
<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>
<p>某台计算机的IP是101.202.99.2，子网掩码是255.255.255.0，那么计算该计算机的网络号是：</p>
<pre><code>IP = 101.202.99.2
Mask = 255.255.255.0
Network = IP &amp; Mask = 101.202.99.0
</code></pre><p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为网关。</p>
<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫路由。</p>
<p>所以，一台计算机的一个网卡会有3个关键配置：</p>
<pre><code>IP地址，例如：10.0.2.15
子网掩码，例如：255.255.255.0
网关的IP地址，例如：10.0.2.2
</code></pre>
<h3 id="域名">域名</h3>
<p>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</p>
<p>用nslookup可以查看域名对应的IP地址：</p>
<pre><code>$ nslookup www.liaoxuefeng.com
Server:  xxx.xxx.xxx.xxx
Address: xxx.xxx.xxx.xxx#53

Non-authoritative answer:
Name:    www.liaoxuefeng.com
Address: 47.98.33.223
</code></pre><p>有一个特殊的本机域名localhost，它对应的IP地址总是本机地址127.0.0.1。</p>
<h3 id="网络模型">网络模型</h3>
<p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用分层模型，每一层负责处理自己的操作。OSI（Open System Interconnect）网络模型是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等</li>
</ul>
<p>互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">OSI</th>
<th align="left">TCP/IP</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"></td>
<td align="left">应用层</td>
<td align="left">应用层</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">表示层</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">会话层</td>
<td></td>
</tr>
<tr>
<td align="left"></td>
<td align="left">传输层</td>
<td align="left">传输层</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">网络层</td>
<td align="left">IP层</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">链路层</td>
<td align="left">网络接口层</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">物理层</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="常用协议">常用协议</h3>
<p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>
<p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>
<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>
<h3 id="小结-22">小结</h3>
<p>计算机网络的基本概念主要有：</p>
<ul>
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li>
<li>IP协议：一种分组交换传输协议；</li>
<li>TCP协议：一种面向连接，可靠传输的协议；</li>
<li>UDP协议：一种无连接，不可靠传输的协议</li>
</ul>
<hr>
<h2 id="122-tcp编程">12.2 TCP编程</h2>
<p>在开发网络应用程序的时候，我们又会遇到Socket这个概念。Socket是一个抽象概念，一个应用程序通过一个Socket来建立一个远程连接，而Socket内部通过TCP/IP协议把数据传输到网络：</p>
<pre><code>┌───────────┐                                   ┌───────────┐
│Application│                                   │Application│
├───────────┤                                   ├───────────┤
│  Socket   │                                   │  Socket   │
├───────────┤                                   ├───────────┤
│    TCP    │                                   │    TCP    │
├───────────┤      ┌──────┐       ┌──────┐      ├───────────┤
│    IP     │&lt;────&gt;│Router│&lt;─────&gt;│Router│&lt;────&gt;│    IP     │
└───────────┘      └──────┘       └──────┘      └───────────┘
</code></pre><p>Socket、TCP和部分IP的功能都是由操作系统提供的，不同的编程语言只是提供了对操作系统调用的简单的封装。例如，Java提供的几个Socket相关的类就封装了操作系统提供的接口。</p>
<p>为什么需要Socket进行网络通信？因为仅仅通过IP地址进行通信是不够的，同一台计算机同一时间会运行多个网络应用程序，例如浏览器、QQ、邮件客户端等。当操作系统接收到一个数据包的时候，如果只有IP地址，它没法判断应该发给哪个应用程序，所以，操作系统抽象出Socket接口，每个应用程序需要各自对应到不同的Socket，数据包才能根据Socket正确地发到对应的应用程序。</p>
<p>一个Socket就是由IP地址和端口号（范围是0～65535）组成，可以把Socket简单理解为IP地址加端口号。端口号总是由操作系统分配，它是一个0～65535之间的数字，其中，小于1024的端口属于特权端口，需要管理员权限，大于1024的端口可以由任意用户的应用程序打开。</p>
<pre><code>IE:101.202.99.2:1201
QQ:101.202.99.2:1304
Email:101.202.99.2:15000
</code></pre><p>使用Socket进行网络编程时，本质上就是两个进程之间的网络通信。其中一个进程必须充当服务器端，它会主动监听某个指定的端口，另一个进程必须充当客户端，它必须主动连接服务器的IP地址和指定端口，如果连接成功，服务器端和客户端就成功地建立了一个TCP连接，双方后续就可以随时发送和接收数据。</p>
<p>因此，当Socket连接成功地在服务器端和客户端之间建立后：</p>
<ul>
<li>对服务器端来说，它的Socket是指定的IP地址和指定的端口号；</li>
<li>对客户端来说，它的Socket是它所在计算机的IP地址和一个由操作系统分配的随机端口号。</li>
</ul>
<h3 id="服务器端">服务器端</h3>
<p>要使用Socket编程，我们首先要编写服务器端程序。Java标准库提供了ServerSocket来实现对指定IP和指定端口的监听。ServerSocket的典型实现代码如下：</p>
<pre><code>public class Server {
    public static void main(String[] args) throws IOException {
        ServerSocket ss = new ServerSocket(6666); // 监听指定端口
        System.out.println(&quot;server is running...&quot;);
        for (;;) {
            Socket sock = ss.accept();
            System.out.println(&quot;connected from &quot; + sock.getRemoteSocketAddress());
            Thread t = new Handler(sock);
            t.start();
        }
    }
}

class Handler extends Thread {
    Socket sock;

    public Handler(Socket sock) {
        this.sock = sock;
    }

    @Override
    public void run() {
        try (InputStream input = this.sock.getInputStream()) {
            try (OutputStream output = this.sock.getOutputStream()) {
                handle(input, output);
            }
        } catch (Exception e) {
            try {
                this.sock.close();
            } catch (IOException ioe) {
            }
            System.out.println(&quot;client disconnected.&quot;);
        }
    }

    private void handle(InputStream input, OutputStream output) throws IOException {
        var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
        var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
        writer.write(&quot;hello\n&quot;);
        writer.flush();
        for (;;) {
            String s = reader.readLine();
            if (s.equals(&quot;bye&quot;)) {
                writer.write(&quot;bye\n&quot;);
                writer.flush();
                break;
            }
            writer.write(&quot;ok: &quot; + s + &quot;\n&quot;);
            writer.flush();
        }
    }
}
</code></pre><p>服务器端通过代码：</p>
<pre><code>ServerSocket ss = new ServerSocket(6666);
</code></pre><p>在指定端口6666监听。这里我们没有指定IP地址，表示在计算机的所有网络接口上进行监听。</p>
<p>如果ServerSocket监听成功，我们就使用一个无限循环来处理客户端的连接：</p>
<pre><code>for (;;) {
    Socket sock = ss.accept();
    Thread t = new Handler(sock);
    t.start();
}
</code></pre><p>注意到代码ss.accept()表示每当有新的客户端连接进来后，就返回一个Socket实例，这个Socket实例就是用来和刚连接的客户端进行通信的。由于客户端很多，要实现并发处理，我们就必须为每个新的Socket创建一个新线程来处理，这样，主线程的作用就是接收新的连接，每当收到新连接后，就创建一个新线程进行处理。</p>
<p>我们在多线程编程的章节中介绍过线程池，这里也完全可以利用线程池来处理客户端连接，能大大提高运行效率。</p>
<p>如果没有客户端连接进来，accept()方法会阻塞并一直等待。如果有多个客户端同时连接进来，ServerSocket会把连接扔到队列里，然后一个一个处理。对于Java程序而言，只需要通过循环不断调用accept()就可以获取新的连接。</p>
<h3 id="客户端">客户端</h3>
<p>相比服务器端，客户端程序就要简单很多。一个典型的客户端程序如下：</p>
<pre><code>public class Client {
    public static void main(String[] args) throws IOException {
        Socket sock = new Socket(&quot;localhost&quot;, 6666); // 连接指定服务器和端口
        try (InputStream input = sock.getInputStream()) {
            try (OutputStream output = sock.getOutputStream()) {
                handle(input, output);
            }
        }
        sock.close();
        System.out.println(&quot;disconnected.&quot;);
    }

    private static void handle(InputStream input, OutputStream output) throws IOException {
        var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8));
        var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8));
        Scanner scanner = new Scanner(System.in);
        System.out.println(&quot;[server] &quot; + reader.readLine());
        for (;;) {
            System.out.print(&quot;&gt;&gt;&gt; &quot;); // 打印提示
            String s = scanner.nextLine(); // 读取一行输入
            writer.write(s);
            writer.newLine();
            writer.flush();
            String resp = reader.readLine();
            System.out.println(&quot;&lt;&lt;&lt; &quot; + resp);
            if (resp.equals(&quot;bye&quot;)) {
                break;
            }
        }
    }
}
</code></pre><p>客户端程序通过：</p>
<pre><code>Socket sock = new Socket(&quot;localhost&quot;, 6666);
</code></pre><p>连接到服务器端，注意上述代码的服务器地址是&quot;localhost&rdquo;，表示本机地址，端口号是6666。如果连接成功，将返回一个Socket实例，用于后续通信。</p>
<h3 id="socket流">Socket流</h3>
<p>当Socket连接创建成功后，无论是服务器端，还是客户端，我们都使用Socket实例进行网络通信。因为TCP是一种基于流的协议，因此，Java标准库使用InputStream和OutputStream来封装Socket的数据流，这样我们使用Socket的流，和普通IO流类似：</p>
<pre><code>// 用于读取网络数据:
InputStream in = sock.getInputStream();
// 用于写入网络数据:
OutputStream out = sock.getOutputStream();
</code></pre><p>最后我们重点来看看，为什么写入网络数据时，要调用flush()方法。</p>
<p>如果不调用flush()，我们很可能会发现，客户端和服务器都收不到数据，这并不是Java标准库的设计问题，而是我们以流的形式写入数据的时候，并不是一写入就立刻发送到网络，而是先写入内存缓冲区，直到缓冲区满了以后，才会一次性真正发送到网络，这样设计的目的是为了提高传输效率。如果缓冲区的数据很少，而我们又想强制把这些数据发送到网络，就必须调用flush()强制把缓冲区数据发送出去。</p>
<h3 id="小结-23">小结</h3>
<p>使用Java进行TCP编程时，需要使用Socket模型：</p>
<ul>
<li>服务器端用ServerSocket监听指定端口；</li>
<li>客户端使用Socket(InetAddress, port)连接服务器；</li>
<li>服务器端用accept()接收连接并返回Socket；</li>
<li>双方通过Socket打开InputStream/OutputStream读写数据；</li>
<li>服务器端通常使用多线程同时处理多个客户端连接，利用线程池可大幅提升效率；</li>
<li>flush()用于强制输出缓冲区到网络。</li>
</ul>
<hr>
<h2 id="123-udo编程">12.3 UDO编程</h2>
<p>和TCP编程相比，UDP编程就简单得多，因为UDP没有创建连接，数据包也是一次收发一个，所以没有流的概念。</p>
<p>在Java中使用UDP编程，仍然需要使用Socket，因为应用程序在使用UDP时必须指定网络接口（IP）和端口号。注意：UDP端口和TCP端口虽然都使用0~65535，但他们是两套独立的端口，即一个应用程序用TCP占用了端口1234，不影响另一个应用程序用UDP占用端口1234。</p>
<h3 id="服务器端-1">服务器端</h3>
<p>在服务器端，使用UDP也需要监听指定的端口。Java提供了DatagramSocket来实现这个功能，代码如下：</p>
<pre><code>DatagramSocket ds = new DatagramSocket(6666); // 监听指定端口
for (;;) { // 无限循环
    // 数据缓冲区:
    byte[] buffer = new byte[1024];
    DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
    ds.receive(packet); // 收取一个UDP数据包
    // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度
    // 将其按UTF-8编码转换为String:
    String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);
    // 发送数据:
    byte[] data = &quot;ACK&quot;.getBytes(StandardCharsets.UTF_8);
    packet.setData(data);
    ds.send(packet);
}
</code></pre><p>服务器端首先使用如下语句在指定的端口监听UDP数据包：</p>
<pre><code>DatagramSocket ds = new DatagramSocket(6666);
</code></pre><p>如果没有其他应用程序占据这个端口，那么监听成功，我们就使用一个无限循环来处理收到的UDP数据包：</p>
<pre><code>for (;;) {
    ...
}
</code></pre><p>要接收一个UDP数据包，需要准备一个byte[]缓冲区，并通过DatagramPacket实现接收：</p>
<pre><code>byte[] buffer = new byte[1024];
DatagramPacket packet = new DatagramPacket(buffer, buffer.length);
ds.receive(packet);
</code></pre><p>假设我们收取到的是一个String，那么，通过DatagramPacket返回的packet.getOffset()和packet.getLength()确定数据在缓冲区的起止位置：</p>
<pre><code>String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8);
</code></pre><p>当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包。</p>
<p>发送UDP包也是通过DatagramPacket实现的，发送代码非常简单：</p>
<pre><code>byte[] data = ...
packet.setData(data);
ds.send(packet);
</code></pre><h3 id="客户端-1">客户端</h3>
<p>和服务器端相比，客户端使用UDP时，只需要直接向服务器端发送UDP包，然后接收返回的UDP包：</p>
<pre><code>DatagramSocket ds = new DatagramSocket();
ds.setSoTimeout(1000);
ds.connect(InetAddress.getByName(&quot;localhost&quot;), 6666); // 连接指定服务器和端口
// 发送:
byte[] data = &quot;Hello&quot;.getBytes();
DatagramPacket packet = new DatagramPacket(data, data.length);
ds.send(packet);
// 接收:
byte[] buffer = new byte[1024];
packet = new DatagramPacket(buffer, buffer.length);
ds.receive(packet);
String resp = new String(packet.getData(), packet.getOffset(), packet.getLength());
ds.disconnect();
</code></pre><p>客户端打开一个DatagramSocket使用以下代码：</p>
<pre><code>DatagramSocket ds = new DatagramSocket();
ds.setSoTimeout(1000);
ds.connect(InetAddress.getByName(&quot;localhost&quot;), 6666);
</code></pre><p>客户端创建DatagramSocket实例时并不需要指定端口，而是由操作系统自动指定一个当前未使用的端口。紧接着，调用setSoTimeout(1000)设定超时1秒，意思是后续接收UDP包时，等待时间最多不会超过1秒，否则在没有收到UDP包时，客户端会无限等待下去。这一点和服务器端不一样，服务器端可以无限等待，因为它本来就被设计成长时间运行。</p>
<p>注意到客户端的DatagramSocket还调用了一个connect()方法“连接”到指定的服务器端。不是说UDP是无连接的协议吗？为啥这里需要connect()？</p>
<p>这个connect()方法不是真连接，它是为了在客户端的DatagramSocket实例中保存服务器端的IP和端口号，确保这个DatagramSocket实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。</p>
<p>如果客户端希望向两个不同的服务器发送UDP包，那么它必须创建两个DatagramSocket实例。</p>
<p>后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。</p>
<p>如果客户端认为通信结束，就可以调用disconnect()断开连接：</p>
<pre><code>ds.disconnect();
</code></pre><p>注意到disconnect()也不是真正地断开连接，它只是清除了客户端DatagramSocket实例记录的远程服务器地址和端口号，这样，DatagramSocket实例就可以连接另一个服务器端。</p>
<h3 id="小结-24">小结</h3>
<p>使用UDP协议通信时，服务器和客户端双方无需建立连接：</p>
<ul>
<li>服务器端用DatagramSocket(port)监听端口；</li>
<li>客户端使用DatagramSocket.connect()指定远程地址和端口；</li>
<li>双方通过receive()和send()读写数据；</li>
<li>DatagramSocket没有IO流接口，数据被直接写入byte[]缓冲区。</li>
</ul>
<hr>
<h2 id="124-发送email">12.4 发送Email</h2>
<p>Email就是电子邮件。电子邮件的应用已经有几十年的历史了，我们熟悉的邮箱地址比如abc@example.com，邮件软件比如Outlook都是用来收发邮件的。</p>
<p>使用Java程序也可以收发电子邮件。我们先来看一下传统的邮件是如何发送的。</p>
<p>传统的邮件是通过邮局投递，然后从一个邮局到另一个邮局，最终到达用户的邮箱：</p>
<pre><code>           ┌──────────┐    ┌──────────┐
           │PostOffice│    │PostOffice│     .───.
┌─────┐    ├──────────┤    ├──────────┤    (   ( )
│═══ ░│───&gt;│ ┌─┐ ┌┐┌┐ │───&gt;│ ┌─┐ ┌┐┌┐ │───&gt; `─┬─'
└─────┘    │ │░│ └┘└┘ │    │ │░│ └┘└┘ │       │
           └─┴─┴──────┘    └─┴─┴──────┘       │
</code></pre><p>电子邮件的发送过程也是类似的，只不过是电子邮件是从用户电脑的邮件软件，例如Outlook，发送到邮件服务器上，可能经过若干个邮件服务器的中转，最终到达对方邮件服务器上，收件方就可以用软件接收邮件：</p>
<pre><code>             ┌─────────┐    ┌─────────┐    ┌─────────┐
             │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│
┌───────┐    ├─────────┤    ├─────────┤    ├─────────┤    ┌───────┐
│░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░░░│    │░░░░░░░│
├───────┤    ├─────────┤    ├─────────┤    ├─────────┤    ├───────┤
│       │───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│───&gt;│O ░░░░░░░│&lt;───│       │
└───────┘    └─────────┘    └─────────┘    └─────────┘    └───────┘
</code></pre><p>我们把类似Outlook这样的邮件软件称为MUA：Mail User Agent，意思是给用户服务的邮件代理；邮件服务器则称为MTA：Mail Transfer Agent，意思是邮件中转的代理；最终到达的邮件服务器称为MDA：Mail Delivery Agent，意思是邮件到达的代理。电子邮件一旦到达MDA，就不再动了。实际上，电子邮件通常就存储在MDA服务器的硬盘上，然后等收件人通过软件或者登陆浏览器查看邮件。</p>
<p>MTA和MDA这样的服务器软件通常是现成的，我们不关心这些服务器内部是如何运行的。要发送邮件，我们关心的是如何编写一个MUA的软件，把邮件发送到MTA上。</p>
<p>MUA到MTA发送邮件的协议就是SMTP协议，它是Simple Mail Transport Protocol的缩写，使用标准端口25，也可以使用加密端口465或587。</p>
<p>SMTP协议是一个建立在TCP之上的协议，任何程序发送邮件都必须遵守SMTP协议。使用Java程序发送邮件时，我们无需关心SMTP协议的底层原理，只需要使用JavaMail这个标准API就可以直接发送邮件。</p>
<h3 id="准备smtp登录信息">准备SMTP登录信息</h3>
<p>假设我们准备使用自己的邮件地址me@example.com给小明发送邮件，已知小明的邮件地址是xiaoming@somewhere.com，发送邮件前，我们首先要确定作为MTA的邮件服务器地址和端口号。邮件服务器地址通常是smtp.example.com，端口号由邮件服务商确定使用25、465还是587。以下是一些常用邮件服务商的SMTP信息：</p>
<ul>
<li>QQ邮箱：SMTP服务器是smtp.qq.com，端口是465/587；</li>
<li>163邮箱：SMTP服务器是smtp.163.com，端口是465；</li>
<li>Gmail邮箱：SMTP服务器是smtp.gmail.com，端口是465/587。</li>
</ul>
<p>有了SMTP服务器的域名和端口号，我们还需要SMTP服务器的登录信息，通常是使用自己的邮件地址作为用户名，登录口令是用户口令或者一个独立设置的SMTP口令。</p>
<p>我们来看看如何使用JavaMail发送邮件。</p>
<p>首先，我们需要创建一个Maven工程，并把JavaMail相关的两个依赖加入进来：</p>
<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;javax.mail&lt;/groupId&gt;
        &lt;artifactId&gt;javax.mail-api&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.sun.mail&lt;/groupId&gt;
        &lt;artifactId&gt;javax.mail&lt;/artifactId&gt;
        &lt;version&gt;1.6.2&lt;/version&gt;
    &lt;/dependency&gt;
    ...
</code></pre><p>然后，我们通过JavaMail API连接到SMTP服务器上：</p>
<pre><code>// 服务器地址:
String smtp = &quot;smtp.office365.com&quot;;
// 登录用户名:
String username = &quot;jxsmtp101@outlook.com&quot;;
// 登录口令:
String password = &quot;********&quot;;
// 连接到SMTP服务器587端口:
Properties props = new Properties();
props.put(&quot;mail.smtp.host&quot;, smtp); // SMTP主机名
props.put(&quot;mail.smtp.port&quot;, &quot;587&quot;); // 主机端口号
props.put(&quot;mail.smtp.auth&quot;, &quot;true&quot;); // 是否需要用户认证
props.put(&quot;mail.smtp.starttls.enable&quot;, &quot;true&quot;); // 启用TLS加密
// 获取Session实例:
Session session = Session.getInstance(props, new Authenticator() {
    protected PasswordAuthentication getPasswordAuthentication() {
        return new PasswordAuthentication(username, password);
    }
});
// 设置debug模式便于调试:
session.setDebug(true);
</code></pre><p>以587端口为例，连接SMTP服务器时，需要准备一个Properties对象，填入相关信息。最后获取Session实例时，如果服务器需要认证，还需要传入一个Authenticator对象，并返回指定的用户名和口令。</p>
<p>当我们获取到Session实例后，打开调试模式可以看到SMTP通信的详细内容，便于调试。</p>
<h3 id="发送邮件">发送邮件</h3>
<p>发送邮件时，我们需要构造一个Message对象，然后调用Transport.send(Message)即可完成发送：</p>
<pre><code>MimeMessage message = new MimeMessage(session);
// 设置发送方地址:
message.setFrom(new InternetAddress(&quot;me@example.com&quot;));
// 设置接收方地址:
message.setRecipient(Message.RecipientType.TO, new InternetAddress(&quot;xiaoming@somewhere.com&quot;));
// 设置邮件主题:
message.setSubject(&quot;Hello&quot;, &quot;UTF-8&quot;);
// 设置邮件正文:
message.setText(&quot;Hi Xiaoming...&quot;, &quot;UTF-8&quot;);
// 发送:
Transport.send(message);
</code></pre><p>绝大多数邮件服务器要求发送方地址和登录用户名必须一致，否则发送将失败。</p>
<p>填入真实的地址，运行上述代码，我们可以在控制台看到JavaMail打印的调试信息：</p>
<pre><code>这是JavaMail打印的调试信息:
DEBUG: setDebug: JavaMail version 1.6.2
DEBUG: getProvider() returning javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]
DEBUG SMTP: need username and password for authentication
DEBUG SMTP: protocolConnect returning false, host=smtp.office365.com, ...
DEBUG SMTP: useEhlo true, useAuth true
开始尝试连接smtp.office365.com:
DEBUG SMTP: trying to connect to host &quot;smtp.office365.com&quot;, port 587, ...
DEBUG SMTP: connected to host &quot;smtp.office365.com&quot;, port: 587
发送命令EHLO:
EHLO localhost
SMTP服务器响应250:
250-SG3P274CA0024.outlook.office365.com Hello
250-SIZE 157286400
...
DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;
发送命令STARTTLS:
STARTTLS
SMTP服务器响应220:
220 2.0.0 SMTP server ready
EHLO localhost
250-SG3P274CA0024.outlook.office365.com Hello [111.196.164.63]
250-SIZE 157286400
250-PIPELINING
250-...
DEBUG SMTP: Found extension &quot;SIZE&quot;, arg &quot;157286400&quot;
...
尝试登录:
DEBUG SMTP: protocolConnect login, host=smtp.office365.com, user=********, password=********
DEBUG SMTP: Attempt to authenticate using mechanisms: LOGIN PLAIN DIGEST-MD5 NTLM XOAUTH2 
DEBUG SMTP: Using mechanism LOGIN
DEBUG SMTP: AUTH LOGIN command trace suppressed
登录成功:
DEBUG SMTP: AUTH LOGIN succeeded
DEBUG SMTP: use8bit false
开发发送邮件，设置FROM:
MAIL FROM:&lt;********@outlook.com&gt;
250 2.1.0 Sender OK
设置TO:
RCPT TO:&lt;********@sina.com&gt;
250 2.1.5 Recipient OK
发送邮件数据:
DATA
服务器响应354:
354 Start mail input; end with &lt;CRLF&gt;.&lt;CRLF&gt;
真正的邮件数据:
Date: Mon, 2 Dec 2019 09:37:52 +0800 (CST)
From: ********@outlook.com
To: ********001@sina.com
Message-ID: &lt;1617791695.0.1575250672483@localhost&gt;
邮件主题是编码后的文本:
Subject: =?UTF-8?Q?JavaMail=E9=82=AE=E4=BB=B6?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: base64

邮件正文是Base64编码的文本:
SGVsbG8sIOi/meaYr+S4gOWwgeadpeiHqmphdmFtYWls55qE6YKu5Lu277yB
.
邮件数据发送完成后，以\r\n.\r\n结束，服务器响应250表示发送成功:
250 2.0.0 OK &lt;HK0PR03MB4961.apcprd03.prod.outlook.com&gt; [Hostname=HK0PR03MB4961.apcprd03.prod.outlook.com]
DEBUG SMTP: message successfully delivered to mail server
发送QUIT命令:
QUIT
服务器响应221结束TCP连接:
221 2.0.0 Service closing transmission channel
</code></pre><p>从上面的调试信息可以看出，SMTP协议是一个请求-响应协议，客户端总是发送命令，然后等待服务器响应。服务器响应总是以数字开头，后面的信息才是用于调试的文本。这些响应码已经被定义在SMTP协议中了，查看具体的响应码就可以知道出错原因。</p>
<p>如果一切顺利，对方将收到一封文本格式的电子邮件.</p>
<h3 id="发送html邮件">发送HTML邮件</h3>
<p>发送HTML邮件和文本邮件是类似的，只需要把：</p>
<pre><code>message.setText(body, &quot;UTF-8&quot;);
</code></pre><p>改为：</p>
<pre><code>message.setText(body, &quot;UTF-8&quot;, &quot;html&quot;);
</code></pre><p>传入的body是类似<!-- raw HTML omitted -->Hello<!-- raw HTML omitted --><!-- raw HTML omitted -->Hi, xxx<!-- raw HTML omitted -->这样的HTML字符串即可。</p>
<p>HTML邮件可以在邮件客户端直接显示为网页格式.</p>
<h3 id="发送附件">发送附件</h3>
<p>要在电子邮件中携带附件，我们就不能直接调用message.setText()方法，而是要构造一个Multipart对象：</p>
<pre><code>Multipart multipart = new MimeMultipart();
// 添加text:
BodyPart textpart = new MimeBodyPart();
textpart.setContent(body, &quot;text/html;charset=utf-8&quot;);
multipart.addBodyPart(textpart);
// 添加image:
BodyPart imagepart = new MimeBodyPart();
imagepart.setFileName(fileName);
imagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, &quot;application/octet-stream&quot;)));
multipart.addBodyPart(imagepart);
// 设置邮件内容为multipart:
message.setContent(multipart);
</code></pre><p>一个Multipart对象可以添加若干个BodyPart，其中第一个BodyPart是文本，即邮件正文，后面的BodyPart是附件。BodyPart依靠setContent()决定添加的内容，如果添加文本，用setContent(&quot;&hellip;&quot;, &ldquo;text/plain;charset=utf-8&rdquo;)添加纯文本，或者用setContent(&quot;&hellip;&quot;, &ldquo;text/html;charset=utf-8&rdquo;)添加HTML文本。如果添加附件，需要设置文件名（不一定和真实文件名一致），并且添加一个DataHandler()，传入文件的MIME类型。二进制文件可以用application/octet-stream，Word文档则是application/msword。</p>
<p>最后，通过setContent()把Multipart添加到Message中，即可发送。</p>
<p>带附件的邮件在客户端会被提示下载.</p>
<h3 id="发送内嵌图片的html邮件">发送内嵌图片的HTML邮件</h3>
<p>有些童鞋可能注意到，HTML邮件中可以内嵌图片，这是怎么做到的？</p>
<p>如果给一个<!-- raw HTML omitted -->，这样的外部图片链接通常会被邮件客户端过滤，并提示用户显示图片并不安全。只有内嵌的图片才能正常在邮件中显示。</p>
<p>内嵌图片实际上也是一个附件，即邮件本身也是Multipart，但需要做一点额外的处理：</p>
<pre><code>Multipart multipart = new MimeMultipart();
// 添加text:
BodyPart textpart = new MimeBodyPart();
textpart.setContent(&quot;&lt;h1&gt;Hello&lt;/h1&gt;&lt;p&gt;&lt;img src=\&quot;cid:img01\&quot;&gt;&lt;/p&gt;&quot;, &quot;text/html;charset=utf-8&quot;);
multipart.addBodyPart(textpart);
// 添加image:
BodyPart imagepart = new MimeBodyPart();
imagepart.setFileName(fileName);
imagepart.setDataHandler(new DataHandler(new ByteArrayDataSource(input, &quot;image/jpeg&quot;)));
// 与HTML的&lt;img src=&quot;cid:img01&quot;&gt;关联:
imagepart.setHeader(&quot;Content-ID&quot;, &quot;&lt;img01&gt;&quot;);
multipart.addBodyPart(imagepart);
</code></pre><p>在HTML邮件中引用图片时，需要设定一个ID，用类似&lt;img src=&quot;cid:img01&quot;&gt;引用，然后，在添加图片作为BodyPart时，除了要正确设置MIME类型（根据图片类型使用image/jpeg或image/png），还需要设置一个Header：</p>
<pre><code>imagepart.setHeader(&quot;Content-ID&quot;, &quot;&lt;img01&gt;&quot;);
</code></pre><p>这个ID和HTML中引用的ID对应起来，邮件客户端就可以正常显示内嵌图片.</p>
<h3 id="常见问题">常见问题</h3>
<p>如果用户名或口令错误，会导致535登录失败：</p>
<pre><code>DEBUG SMTP: AUTH LOGIN failed
Exception in thread &quot;main&quot; javax.mail.AuthenticationFailedException: 535 5.7.3 Authentication unsuccessful [HK0PR03CA0105.apcprd03.prod.outlook.com]
</code></pre><p>如果登录用户和发件人不一致，会导致554拒绝发送错误：</p>
<pre><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 5.2.0 STOREDRV.Submission.Exception:SendAsDeniedException.MapiExceptionSendAsDenied;
</code></pre><p>有些时候，如果邮件主题和正文过于简单，会导致554被识别为垃圾邮件的错误：</p>
<pre><code>DEBUG SMTP: MessagingException while sending, THROW: 
com.sun.mail.smtp.SMTPSendFailedException: 554 DT:SPM
</code></pre><h3 id="小结-25">小结</h3>
<p>使用JavaMail API发送邮件本质上是一个MUA软件通过SMTP协议发送邮件至MTA服务器；</p>
<p>打开调试模式可以看到详细的SMTP交互信息；</p>
<p>某些邮件服务商需要开启SMTP，并需要独立的SMTP登录密码。</p>
<hr>
<h2 id="125-接受email">12.5 接受Email</h2>
<p>发送Email的过程我们在上一节已经讲过了，客户端总是通过SMTP协议把邮件发送给MTA。</p>
<p>接收Email则相反，因为邮件最终到达收件人的MDA服务器，所以，接收邮件是收件人用自己的客户端把邮件从MDA服务器上抓取到本地的过程。</p>
<p>接收邮件使用最广泛的协议是POP3：Post Office Protocol version 3，它也是一个建立在TCP连接之上的协议。POP3服务器的标准端口是110，如果整个会话需要加密，那么使用加密端口995。</p>
<p>另一种接收邮件的协议是IMAP：Internet Mail Access Protocol，它使用标准端口143和加密端口993。IMAP和POP3的主要区别是，IMAP协议在本地的所有操作都会自动同步到服务器上，并且，IMAP可以允许用户在邮件服务器的收件箱中创建文件夹。</p>
<p>JavaMail也提供了IMAP协议的支持。因为POP3和IMAP的使用方式非常类似，因此我们只介绍POP3的用法。</p>
<p>使用POP3收取Email时，我们无需关心POP3协议底层，因为JavaMail提供了高层接口。首先需要连接到Store对象：</p>
<pre><code>// 准备登录信息:
String host = &quot;pop3.example.com&quot;;
int port = 995;
String username = &quot;bob@example.com&quot;;
String password = &quot;password&quot;;

Properties props = new Properties();
props.setProperty(&quot;mail.store.protocol&quot;, &quot;pop3&quot;); // 协议名称
props.setProperty(&quot;mail.pop3.host&quot;, host);// POP3主机名
props.setProperty(&quot;mail.pop3.port&quot;, String.valueOf(port)); // 端口号
// 启动SSL:
props.put(&quot;mail.smtp.socketFactory.class&quot;, &quot;javax.net.ssl.SSLSocketFactory&quot;);
props.put(&quot;mail.smtp.socketFactory.port&quot;, String.valueOf(port));

// 连接到Store:
URLName url = new URLName(&quot;pop3&quot;, host, post, &quot;&quot;, username, password);
Session session = Session.getInstance(props, null);
session.setDebug(true); // 显示调试信息
Store store = new POP3SSLStore(session, url);
store.connect();
</code></pre><p>一个Store对象表示整个邮箱的存储，要收取邮件，我们需要通过Store访问指定的Folder（文件夹），通常是INBOX表示收件箱：</p>
<pre><code>// 获取收件箱:
Folder folder = store.getFolder(&quot;INBOX&quot;);
// 以读写方式打开:
folder.open(Folder.READ_WRITE);
// 打印邮件总数/新邮件数量/未读数量/已删除数量:
System.out.println(&quot;Total messages: &quot; + folder.getMessageCount());
System.out.println(&quot;New messages: &quot; + folder.getNewMessageCount());
System.out.println(&quot;Unread messages: &quot; + folder.getUnreadMessageCount());
System.out.println(&quot;Deleted messages: &quot; + folder.getDeletedMessageCount());
// 获取每一封邮件:
Message[] messages = folder.getMessages();
for (Message message : messages) {
    // 打印每一封邮件:
    printMessage((MimeMessage) message);
}
</code></pre><p>当我们获取到一个Message对象时，可以强制转型为MimeMessage，然后打印出邮件主题、发件人、收件人等信息：</p>
<pre><code>void printMessage(MimeMessage msg) throws IOException, MessagingException {
    // 邮件主题:
    System.out.println(&quot;Subject: &quot; + MimeUtility.decodeText(msg.getSubject()));
    // 发件人:
    Address[] froms = msg.getFrom();
    InternetAddress address = (InternetAddress) froms[0];
    String personal = address.getPersonal();
    String from = personal == null ? address.getAddress() : (MimeUtility.decodeText(personal) + &quot; &lt;&quot; + address.getAddress() + &quot;&gt;&quot;);
    System.out.println(&quot;From: &quot; + from);
    // 继续打印收件人:
    ...
}
</code></pre><p>比较麻烦的是获取邮件的正文。一个MimeMessage对象也是一个Part对象，它可能只包含一个文本，也可能是一个Multipart对象，即由几个Part构成，因此，需要递归地解析出完整的正文：</p>
<pre><code>String getBody(Part part) throws MessagingException, IOException {
    if (part.isMimeType(&quot;text/*&quot;)) {
        // Part是文本:
        return part.getContent().toString();
    }
    if (part.isMimeType(&quot;multipart/*&quot;)) {
        // Part是一个Multipart对象:
        Multipart multipart = (Multipart) part.getContent();
        // 循环解析每个子Part:
        for (int i = 0; i &lt; multipart.getCount(); i++) {
            BodyPart bodyPart = multipart.getBodyPart(i);
            String body = getBody(bodyPart);
            if (!body.isEmpty()) {
                return body;
            }
        }
    }
    return &quot;&quot;;
}
</code></pre><p>最后记得关闭Folder和Store：</p>
<pre><code>folder.close(true); // 传入true表示删除操作会同步到服务器上（即删除服务器收件箱的邮件）
store.close();
</code></pre><h3 id="小结-26">小结</h3>
<p>使用Java接收Email时，可以用POP3协议或IMAP协议。</p>
<p>使用POP3协议时，需要用Maven引入JavaMail依赖，并确定POP3服务器的域名／端口／是否使用SSL等，然后，调用相关API接收Email。</p>
<p>设置debug模式可以查看通信详细内容，便于排查错误。</p>
<hr>
<h2 id="126-http编程">12.6 HTTP编程</h2>
<p>什么是HTTP？HTTP就是目前使用最广泛的Web应用程序使用的基础协议，例如，浏览器访问网站，手机App访问后台服务器，都是通过HTTP协议实现的。</p>
<p>HTTP是HyperText Transfer Protocol的缩写，翻译为超文本传输协议，它是基于TCP协议之上的一种请求-响应协议。</p>
<p>HTTP/1.1 的方法:
| 方法    | 说明                   |
| :&mdash;&mdash; | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; |
| GET     | 获取资源               |
| POST    | 传输实体主体           |
| PUT     | 传输文件               |
| HEAD    | 获得报文首部           |
| DELETE  | 删除文件               |
| OPTIONS | 询问支持的方法         |
| TRACE   | 追踪路径               |
| CONNECT | 要求用隧道协议连接代理 |</p>
<p>我们来看一下浏览器请求访问某个网站时发送的HTTP请求-响应。当浏览器希望访问某个网站时，浏览器和网站服务器之间首先建立TCP连接，且服务器总是使用80端口和加密端口443，然后，浏览器向服务器发送一个HTTP请求，服务器收到后，返回一个HTTP响应，并且在响应中包含了HTML的网页内容，这样，浏览器解析HTML后就可以给用户显示网页了。一个完整的HTTP请求-响应如下：</p>
<pre><code>            GET / HTTP/1.1
            Host: www.sina.com.cn
            User-Agent: Mozilla/5 MSIE
            Accept: */*                          ┌────────┐
┌─────────┐ Accept-Language: zh-CN,en            │░░░░░░░░│
│O ░░░░░░░│─────────────────────────────────────&gt;├────────┤
├─────────┤&lt;─────────────────────────────────────│░░░░░░░░│
│         │ HTTP/1.1 200 OK                      ├────────┤
│         │ Date: Tue, 10 Jul 2012 06:50:15 GMT  │░░░░░░░░│
│         │ Content-Type: text/html              │░░░░░░░░│
└─────────┘ Content-Length: 133251               └────────┘
  Browser   &lt;!DOCTYPE html&gt;                        Server
            &lt;html&gt;&lt;body&gt;
            &lt;h1&gt;Hello&lt;/h1&gt;
            ...
</code></pre><p>HTTP请求的格式是固定的，它由HTTP Header和HTTP Body两部分构成。第一行总是请求方法 路径 HTTP版本，例如，GET / HTTP/1.1表示使用GET请求，路径是/，版本是HTTP/1.1。</p>
<p>后续的每一行都是固定的Header: Value格式，我们称为HTTP Header，服务器依靠某些特定的Header来识别客户端请求，例如：</p>
<ul>
<li>Host：表示请求的域名，因为一台服务器上可能有多个网站，因此有必要依靠Host来识别用于请求；</li>
<li>User-Agent：表示客户端自身标识信息，不同的浏览器有不同的标识，服务器依靠User-Agent判断客户端类型；</li>
<li>Accept：表示客户端能处理的HTTP响应格式，*/*表示任意格式，text/*表示任意文本，image/png表示PNG格式的图片；</li>
<li>Accept-Language：表示客户端接收的语言，多种语言按优先级排序，服务器依靠该字段给用户返回特定语言的网页版本。</li>
</ul>
<p>如果是GET请求，那么该HTTP请求只有HTTP Header，没有HTTP Body。如果是POST请求，那么该HTTP请求带有Body，以一个空行分隔。一个典型的带Body的HTTP请求如下：</p>
<pre><code>POST /login HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

username=hello&amp;password=123456
</code></pre><p>POST请求通常要设置Content-Type表示Body的类型，Content-Length表示Body的长度，这样服务器就可以根据请求的Header和Body做出正确的响应。</p>
<p>此外，GET请求的参数必须附加在URL上，并以URLEncode方式编码，例如：http://www.example.com/?a=1&amp;b=K%26R，
参数分别是a=1和b=K&amp;R。因为URL的长度限制，GET请求的参数不能太多，而POST请求的参数就没有长度限制，因为POST请求的参数必须放到Body中。并且，POST请求的参数不一定是URL编码，可以按任意格式编码，只需要在Content-Type中正确设置即可。常见的发送JSON的POST请求如下：</p>
<pre><code>POST /login HTTP/1.1
Content-Type: application/json
Content-Length: 38

{&quot;username&quot;:&quot;bob&quot;,&quot;password&quot;:&quot;123456&quot;}
</code></pre><p>HTTP响应也是由Header和Body两部分组成，一个典型的HTTP响应如下：</p>
<pre><code>HTTP/1.1 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Type: text/html
Content-Length: 133251

&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;body&gt;
&lt;h1&gt;Hello&lt;/h1&gt;
...
</code></pre><p>响应的第一行总是HTTP版本 响应代码 响应说明，例如，HTTP/1.1 200 OK表示版本是HTTP/1.1，响应代码是200，响应说明是OK。客户端只依赖响应代码判断HTTP响应是否成功。HTTP有固定的响应代码：</p>
<ul>
<li>1xx：表示一个提示性响应，例如101表示将切换协议，常见于WebSocket连接；</li>
<li>2xx：表示一个成功的响应：
<ul>
<li>200 OK 表示从客户端发来的请求在服务器端被正常处理了。</li>
<li>204 No Content 该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中 不含实体的主体部分。另外，也不允许返回任何实体的主体。</li>
<li>206 Partial Content 该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</li>
</ul>
</li>
<li>3xx：表示一个重定向的响应：
<ul>
<li>301 Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后 应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</li>
<li>302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。</li>
<li>303 See Other 该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。 303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别</li>
<li>304 Not Modified 该状态码表示客户端发送附带条件的请求时，服务器端允许请求访 问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应 的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关 系。</li>
<li>307 Temporary Redirect 临时重定向。该状态码与 302 Found 有着相同的含义。</li>
</ul>
</li>
<li>4xx：表示一个因为客户端问题导致的错误响应：
<ul>
<li>400 Bad Request 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求 的内容后再次发送请求。</li>
<li>401 Unauthorized 该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、 DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示 用 户认证失败。</li>
<li>403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。</li>
<li>404 Not Found 该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服 务器端拒绝请求且不想说明理由时使用。</li>
</ul>
</li>
<li>5xx：表示一个因为服务器问题导致的错误响应：
<ul>
<li>500 Internal Server Error 该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</li>
<li>503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法 处理请求。</li>
</ul>
</li>
</ul>
<p>当浏览器收到第一个HTTP响应后，它解析HTML后，又会发送一系列HTTP请求，例如，GET /logo.jpg HTTP/1.1请求一个图片，服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器：</p>
<pre><code>HTTP/1.1 200 OK
Content-Type: image/jpeg
Content-Length: 18391

????JFIFHH??XExifMM?i&amp;??X?...(二进制的JPEG图片)
</code></pre><p>因此，服务器总是被动地接收客户端的一个HTTP请求，然后响应它。客户端则根据需要发送若干个HTTP请求。</p>
<p>对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率：</p>
<pre><code>                       ┌─────────┐
┌─────────┐            │░░░░░░░░░│
│O ░░░░░░░│            ├─────────┤
├─────────┤            │░░░░░░░░░│
│         │            ├─────────┤
│         │            │░░░░░░░░░│
└─────────┘            └─────────┘
     │      request 1       │
     │─────────────────────&gt;│
     │      response 1      │
     │&lt;─────────────────────│
     │      request 2       │
     │─────────────────────&gt;│
     │      response 2      │
     │&lt;─────────────────────│
     │      request 3       │
     │─────────────────────&gt;│
     │      response 3      │
     │&lt;─────────────────────│
     ▼                      ▼
</code></pre><p>因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。</p>
<p>所以，为了进一步提速，HTTP/2.0允许客户端在没有收到响应的时候，发送多个HTTP请求，服务器返回响应的时候，不一定按顺序返回，只要双方能识别出哪个响应对应哪个请求，就可以做到并行发送和接收：</p>
<pre><code>                       ┌─────────┐
┌─────────┐            │░░░░░░░░░│
│O ░░░░░░░│            ├─────────┤
├─────────┤            │░░░░░░░░░│
│         │            ├─────────┤
│         │            │░░░░░░░░░│
└─────────┘            └─────────┘
     │      request 1       │
     │─────────────────────&gt;│
     │      request 2       │
     │─────────────────────&gt;│
     │      response 1      │
     │&lt;─────────────────────│
     │      request 3       │
     │─────────────────────&gt;│
     │      response 3      │
     │&lt;─────────────────────│
     │      response 2      │
     │&lt;─────────────────────│
     ▼                      ▼
</code></pre><p>可见，HTTP/2.0进一步提高了效率。</p>
<h3 id="http编程">HTTP编程</h3>
<p>既然HTTP涉及到客户端和服务器端，和TCP类似，我们也需要针对客户端编程和针对服务器端编程。</p>
<p>本节我们不讨论服务器端的HTTP编程，因为服务器端的HTTP编程本质上就是编写Web服务器，这是一个非常复杂的体系，也是JavaEE开发的核心内容，我们在后面的章节再仔细研究。</p>
<p>本节我们只讨论作为客户端的HTTP编程。</p>
<p>因为浏览器也是一种HTTP客户端，所以，客户端的HTTP编程，它的行为本质上和浏览器是一样的，即发送一个HTTP请求，接收服务器响应后，获得响应内容。只不过浏览器进一步把响应内容解析后渲染并展示给了用户，而我们使用Java进行HTTP客户端编程仅限于获得响应内容。</p>
<p>我们来看一下Java如果使用HTTP客户端编程。</p>
<p>Java标准库提供了基于HTTP的包，但是要注意，早期的JDK版本是通过HttpURLConnection访问HTTP，典型代码如下：</p>
<pre><code>URL url = new URL(&quot;http://www.example.com/path/to/target?a=1&amp;b=2&quot;);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setRequestMethod(&quot;GET&quot;);
conn.setUseCaches(false);
conn.setConnectTimeout(5000); // 请求超时5秒
// 设置HTTP头:
conn.setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;);
conn.setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)&quot;);
// 连接并发送HTTP请求:
conn.connect();
// 判断HTTP响应是否200:
if (conn.getResponseCode() != 200) {
    throw new RuntimeException(&quot;bad response&quot;);
}		
// 获取所有响应Header:
Map&lt;String, List&lt;String&gt;&gt; map = conn.getHeaderFields();
for (String key : map.keySet()) {
    System.out.println(key + &quot;: &quot; + map.get(key));
}
// 获取响应内容:
InputStream input = conn.getInputStream();
...
</code></pre><p>上述代码编写比较繁琐，并且需要手动处理InputStream，所以用起来很麻烦。</p>
<p>从Java 11开始，引入了新的HttpClient，它使用链式调用的API，能大大简化HTTP的处理。</p>
<p>我们来看一下如何使用新版的HttpClient。首先需要创建一个全局HttpClient实例，因为HttpClient内部使用线程池优化多个HTTP连接，可以复用：</p>
<pre><code>static HttpClient httpClient = HttpClient.newBuilder().build();
</code></pre><p>使用GET请求获取文本内容代码如下：</p>
<pre><code>import java.net.URI;
import java.net.http.*;
import java.net.http.HttpClient.Version;
import java.time.Duration;
import java.util.*;

public class Main {
    // 全局HttpClient:
    static HttpClient httpClient = HttpClient.newBuilder().build();

    public static void main(String[] args) throws Exception {
        String url = &quot;https://www.sina.com.cn/&quot;;
        HttpRequest request = HttpRequest.newBuilder(new URI(url))
            // 设置Header:
            .header(&quot;User-Agent&quot;, &quot;Java HttpClient&quot;).header(&quot;Accept&quot;, &quot;*/*&quot;)
            // 设置超时:
            .timeout(Duration.ofSeconds(5))
            // 设置版本:
            .version(Version.HTTP_2).build();
        HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
        // HTTP允许重复的Header，因此一个Header可对应多个Value:
        Map&lt;String, List&lt;String&gt;&gt; headers = response.headers().map();
        for (String header : headers.keySet()) {
            System.out.println(header + &quot;: &quot; + headers.get(header).get(0));
        }
        System.out.println(response.body().substring(0, 1024) + &quot;...&quot;);
    }
}
</code></pre><p>如果我们要获取图片这样的二进制内容，只需要把HttpResponse.BodyHandlers.ofString()换成HttpResponse.BodyHandlers.ofByteArray()，就可以获得一个HttpResponse&lt;byte[]&gt;对象。如果响应的内容很大，不希望一次性全部加载到内存，可以使用HttpResponse.BodyHandlers.ofInputStream()获取一个InputStream流。</p>
<p>要使用POST请求，我们要准备好发送的Body数据并正确设置Content-Type：</p>
<pre><code>String url = &quot;http://www.example.com/login&quot;;
String body = &quot;username=bob&amp;password=123456&quot;;
HttpRequest request = HttpRequest.newBuilder(new URI(url))
    // 设置Header:
    .header(&quot;Accept&quot;, &quot;*/*&quot;)
    .header(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)
    // 设置超时:
    .timeout(Duration.ofSeconds(5))
    // 设置版本:
    .version(Version.HTTP_2)
    // 使用POST并设置Body:
    .POST(BodyPublishers.ofString(body, StandardCharsets.UTF_8)).build();
HttpResponse&lt;String&gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
String s = response.body();
</code></pre><h3 id="小结-27">小结</h3>
<p>Java提供了HttpClient作为新的HTTP客户端编程接口用于取代老的HttpURLConnection接口；</p>
<p>HttpClient使用链式调用并通过内置的BodyPublishers和BodyHandlers来更方便地处理数据。</p>
<hr>
<h2 id="127-rmi远程调用">12.7 RMI远程调用</h2>
<p>Java的RMI远程调用是指，一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法。RMI是Remote Method Invocation的缩写。</p>
<p>提供服务的一方我们称之为服务器，而实现远程调用的一方我们称之为客户端。</p>
<p>我们先来实现一个最简单的RMI：服务器会提供一个WorldClock服务，允许客户端获取指定时区的时间，即允许客户端调用下面的方法：</p>
<pre><code>LocalDateTime getLocalDateTime(String zoneId);
</code></pre><p>要实现RMI，服务器和客户端必须共享同一个接口。我们定义一个WorldClock接口，代码如下：</p>
<pre><code>public interface WorldClock extends Remote {
    LocalDateTime getLocalDateTime(String zoneId) throws RemoteException;
}
</code></pre><p>Java的RMI规定此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException。</p>
<p>下一步是编写服务器的实现类，因为客户端请求的调用方法getLocalDateTime()最终会通过这个实现类返回结果。实现类WorldClockService代码如下：</p>
<pre><code>public class WorldClockService implements WorldClock {
    @Override
    public LocalDateTime getLocalDateTime(String zoneId) throws RemoteException {
        return LocalDateTime.now(ZoneId.of(zoneId)).withNano(0);
    }
}
</code></pre><p>现在，服务器端的服务相关代码就编写完毕。我们需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用：</p>
<pre><code>public class Server {
    public static void main(String[] args) throws RemoteException {
        System.out.println(&quot;create World clock remote service...&quot;);
        // 实例化一个WorldClock:
        WorldClock worldClock = new WorldClockService();
        // 将此服务转换为远程服务接口:
        WorldClock skeleton = (WorldClock) UnicastRemoteObject.exportObject(worldClock, 0);
        // 将RMI服务注册到1099端口:
        Registry registry = LocateRegistry.createRegistry(1099);
        // 注册此服务，服务名为&quot;WorldClock&quot;:
        registry.rebind(&quot;WorldClock&quot;, skeleton);
    }
}
</code></pre><p>上述代码主要目的是通过RMI提供的相关类，将我们自己的WorldClock实例注册到RMI服务上。RMI的默认端口是1099，最后一步注册服务时通过rebind()指定服务名称为&quot;WorldClock&rdquo;。</p>
<p>下一步我们就可以编写客户端代码。RMI要求服务器和客户端共享同一个接口，因此我们要把WorldClock.java这个接口文件复制到客户端，然后在客户端实现RMI调用：</p>
<pre><code>public class Client {
    public static void main(String[] args) throws RemoteException, NotBoundException {
        // 连接到服务器localhost，端口1099:
        Registry registry = LocateRegistry.getRegistry(&quot;localhost&quot;, 1099);
        // 查找名称为&quot;WorldClock&quot;的服务并强制转型为WorldClock接口:
        WorldClock worldClock = (WorldClock) registry.lookup(&quot;WorldClock&quot;);
        // 正常调用接口方法:
        LocalDateTime now = worldClock.getLocalDateTime(&quot;Asia/Shanghai&quot;);
        // 打印调用结果:
        System.out.println(now);
    }
}
</code></pre><p>先运行服务器，再运行客户端。从运行结果可知，因为客户端只有接口，并没有实现类，因此，客户端获得的接口方法返回值实际上是通过网络从服务器端获取的。整个过程实际上非常简单，对客户端来说，客户端持有的WorldClock接口实际上对应了一个“实现类”，它是由Registry内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的WorldClockService，而是Registry自动生成的代码。我们把客户端的“实现类”称为stub，而服务器端的网络服务类称为skeleton，它会真正调用服务器端的WorldClockService，获取结果，然后把结果通过网络传递给客户端。整个过程由RMI底层负责实现序列化和反序列化：</p>
<pre><code>┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
  ┌─────────────┐                                 ┌─────────────┐
│ │   Service   │ │         │                     │   Service   │ │
  └─────────────┘                                 └─────────────┘
│        ▲        │         │                            ▲        │
         │                                               │
│        │        │         │                            │        │
  ┌─────────────┐   Network   ┌───────────────┐   ┌─────────────┐
│ │ Client Stub ├─┼─────────┼&gt;│Server Skeleton│──&gt;│Service Impl │ │
  └─────────────┘             └───────────────┘   └─────────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ┘         └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
</code></pre><p>Java的RMI严重依赖序列化和反序列化，而这种情况下可能会造成严重的安全漏洞，因为Java的序列化和反序列化不但涉及到数据，还涉及到二进制的字节码，即使使用白名单机制也很难保证100%排除恶意构造的字节码。因此，使用RMI时，双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>
<p>此外，Java的RMI调用机制决定了双方必须是Java程序，其他语言很难调用Java的RMI。如果要使用不同语言进行RPC调用，可以选择更通用的协议，例如gRPC。</p>
<h3 id="小结-28">小结</h3>
<p>Java提供了RMI实现远程方法调用：</p>
<p>RMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务；</p>
<p>RMI的序列化和反序列化可能会造成安全漏洞，因此调用双方必须是内网互相信任的机器，不要把1099端口暴露在公网上作为对外服务。</p>
<hr>
<h1 id="第13章-io">第13章 IO</h1>
<h2 id="131-file">13.1 File</h2>
<hr>
<h3 id="1311-file类的概述和构造方法">13.1.1 File类的概述和构造方法</h3>
<p>File：它是文件和目录路径名的抽象表示</p>
<ul>
<li>文件和目录是可以通过File封装成对象的</li>
<li>对File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已，他可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</li>
</ul>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">File(String pathname)</td>
<td align="left">通过给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td align="left">File(String parent, String child)</td>
<td align="left">从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td align="left">File(File parent, String child)</td>
<td align="left">从父抽象路径名和子路径名字符串创建新的File实例</td>
</tr>
</tbody>
</table>
<pre><code>package io.file;

import java.io.File;

/**
 * File: 文件和目录路径名的抽象表示
 *      1、文件和目录是可以通过File封装成对象的
 *      2、对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的
 *         将来是要通过具体的操作把这个路径的内容转换为具体存在的
 *
 * 构造方法：
 *      File(String pathname):通过给定的路径名称字符转换为抽象路径名来创建新的File实例
 *      File(String parent, String child);从父亲路径名字符串和子路径名称字符串创建新的File实例
 *      File(File PARENT, String child): 从父抽象路径名和子路径名字字符串创新的File实例
 *
 * @author qq_lin
 */
public class FileDemo {
    public static void main(String[] args) {
        /**
         * File(String pathname):通过给定的路径名称字符转换为抽象路径名来创建新的File实例
          */
        File f1 = new File(&quot;d:/qq_lin/java.txt&quot;);
        System.out.println(f1);

        /**
         * File(String parent, String child);从父亲路径名字符串和子路径名称字符串创建新的File实例
         */
        File f2 = new File(&quot;d:/qq_lin&quot;, &quot;java.txt&quot;);
        System.out.println(f2);

        /**
         * File(File PARENT, String child): 从父抽象路径名和子路径名字字符串创新的File实例
         */
        File f3 = new File(&quot;d://qq_lin&quot;);
        File f4 = new File(f3, &quot;java.txt&quot;);
        System.out.println(f4);
    }
}
</code></pre><hr>
<h3 id="1312-file类创建功能">13.1.2 File类创建功能</h3>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">public boolean createNewFile()</td>
<td align="left">当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td>
</tr>
<tr>
<td align="left">public boolean mkdir()</td>
<td align="left">创建由此抽象路径名命名的目录</td>
</tr>
<tr>
<td align="left">public boolean mkdirs()</td>
<td align="left">创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录</td>
</tr>
</tbody>
</table>
<pre><code>package io.file;

import java.io.File;
import java.io.IOException;

/**
 * File类创建功能：
 *      pubLic boolean createNewFile():当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件
 *          如果文件不存在，就创建文件，并返回true
 *          如果文件存在，就不创建文件，并返回false
 *
 *      public Boolean mkdir():创建由此抽象路径名命名的目录
 *          如果目录不存在，就创建文件，并返回true
 *          如果目录存在，就不创建文件，并返回false
 *
 *      public Boolean mkdirs():创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录
 *
 * @author qq_lin
 */
public class FileDemo2 {
    public static void main(String[] args) throws IOException {
        /**
         * 需求 1：需要在d:/linqq目录下创建一个文件Java.txt
         */
        File f1 = new File(&quot;d:/linqq/Java.txt&quot;);
        System.out.println(f1.createNewFile());
        System.out.println(&quot;------&quot;);

        /**
         * 需求 2：需要在d:/linqq目录下创建一个目录JavaSE
         */
        File f2 = new File(&quot;d:/linqq/JavaSE&quot;);
        System.out.println(f2.mkdir());
        System.out.println(&quot;------&quot;);

        /**
         * 需求 3：需要在d:/linqq目录下创建一个多级目录JavaWEB/HTML
         */
        File f3 = new File(&quot;d:/linqq/JavaWEB/HTMl&quot;);
        System.out.println(f3.mkdirs());
        System.out.println(&quot;------&quot;);

        /**
         * 需求 4：需要在d:/linqq目录下创建一个文件javase.txt
         */
        File f4 = new File(&quot;d:/linqq/Java.txt&quot;);
//        System.out.println(f4.mkdir());
        System.out.println(f4.createNewFile());
    }
}
</code></pre><hr>
<h3 id="1313-file类判断和获取功能">13.1.3 File类判断和获取功能</h3>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">public boolean isDirectory()</td>
<td align="left">测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td align="left">public boolean isFile()</td>
<td align="left">测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td align="left">public boolean exists()</td>
<td align="left">测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td align="left">public String getAbsolutePath(()</td>
<td align="left">返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td align="left">public String getPath()</td>
<td align="left">将此抽象路径名转换为路径名字符串</td>
</tr>
<tr>
<td align="left">public String getName()</td>
<td align="left">返回由此抽象路径名表示的文件或目录的名称</td>
</tr>
<tr>
<td align="left">public String[] list()</td>
<td align="left">返回此抽象路径名表示的目录中的文件和目录的名称字符串数组</td>
</tr>
<tr>
<td align="left">public File[] listFiles()</td>
<td align="left">返回此抽象路径名表示的目录中的文件和目录的File对象数组</td>
</tr>
</tbody>
</table>
<pre><code>package io.file;

import java.io.File;

/**
 * File类的判断和获取功能：
 *      public boolean isDirectory():测试此抽象路径名表示的File是否为目录
 *      public boolean isFile():测试此抽象路径名表示的File是否问文件
 *      public boolean exits():测试此抽象路径名表示的FIle是否存在
 *
 *      public String getAbsolutePath():返回此抽象路径名的绝对路径名字符串
 *      public String getPath():将此抽象路径名转换为路径名字符串
 *      public String getName():返回由此抽象路径名表示的文件或目录的名称
 *
 *      public String[] list():返回此抽象路径名表示的目录中的文件和目录的名称字符串数组
 *      public File[] listFiles():返回此抽象路径名表示的目录中的文件和目录的File对象数组
 *
 * @author qq_lin
 */
public class FileDemo3 {
    public static void main(String[] args) {
        // 创建一个File对象
        File f = new File(&quot;myFile/java.txt&quot;);

//*      public boolean isDirectory():测试此抽象路径名表示的File是否为目录
//*      public boolean isFile():测试此抽象路径名表示的File是否问文件
//*      public boolean exits():测试此抽象路径名表示的FIle是否存在
        System.out.println(f.isDirectory());
        System.out.println(f.isFile());
        System.out.println(f.exists());
        System.out.println(&quot;------&quot;);

//*      public String getAbsolutePath():返回此抽象路径名的绝对路径名字符串
//*      public String getPath():将此抽象路径名转换为路径名字符串
//*      public String getName():返回由此抽象路径名表示的文件或目录的名称

        System.out.println(f.getAbsoluteFile());
        System.out.println(f.getPath());
        System.out.println(f.getName());
        System.out.println(&quot;------&quot;);


//        public String[] list():返回此抽象路径名表示的目录中的文件和目录的名称字符串数组
//        public File[] listFiles():返回此抽象路径名表示的目录中的文件和目录的File对象数组

        File f2 = new File(&quot;d:/linqq&quot;);
        String[] strArray = f2.list();
        for (String str :
                strArray) {
            System.out.println(str);
        }
        System.out.println(&quot;------&quot;);
        
        File[] fileArray = f2.listFiles();
        for (File file :
                fileArray) {
            if (file.isFile()) {
                System.out.println(file.getName());
            }
        }
    }
}
</code></pre><hr>
<h3 id="1314-file类删除功能">13.1.4 File类删除功能</h3>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">public boolean delete()</td>
<td align="left">删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody>
</table>
<p>绝对路径和相对路径的区别</p>
<ul>
<li>绝对路径：完整的路径名，不需要任何其他信息就可以定位它所表示的文件。例如，E:/ITcast/java.txt</li>
<li>相对路径：必须使用取自其他路径名的信息进行解释。例如，myFile/java.txt</li>
</ul>
<p>删除目录时的注意事项：</p>
<ul>
<li>如果目录中有内容（目录、文件），不能直接删除。应该先删除目录中的内容，最后才能删除目录</li>
</ul>
<pre><code>package io.file;

import java.io.File;
import java.io.IOException;

/**
 * File类删除功能：
 *      public boolean delete()：删除由此抽象路径名表示的文件或目录
 *
 * @author qq_lin
 */
public class FileDemo4 {
    public static void main(String[] args) throws IOException {
        /**
         * 需求1：在当前模块目录下创建java.txt
         */
        File f1 = new File(&quot;d:/myFile/Java.txt&quot;);
        System.out.println(f1.createNewFile());

        /**
         * 需求2：删除当前模块目录下的java.txt文件
         */
        System.out.println(f1.delete());
        System.out.println(&quot;------&quot;);

        /**
         * 需求3：在当前模块目录下创建itcast目录
         */
        File f2 = new File(&quot;myFile/itcast&quot;);
        System.out.println(f2.mkdir());

        /**
         * 需求4：删除当前模块目录下的itcast目录
         */
        System.out.println(f2.delete());
        System.out.println(&quot;------&quot;);

        /**
         * 需求5：在当前模块下创建一个目录itcast，然后在目录下创建一个文件java.txt
         */
        File f3 = new File(&quot;myFile/itcast&quot;);
        System.out.println(f3.mkdir());
        File f4 = new File(&quot;myFile/itcast/java.txt&quot;);
        System.out.println(f4.createNewFile());

        /**
         * 需求6：删除当前模块下的目录itcast
         */
        System.out.println(f4.delete());
        System.out.println(f3.delete());
    }
}
</code></pre><hr>
<h3 id="1315-递归">13.1.5 递归</h3>
<p>递归，在数学与计算机科学中，是指在函数的定义中使用函数自身的方法。也就是说，递归算法是一种直接或者间接调用自身函数或者方法的算法。</p>
<p>通俗来说，递归算法的实质是把问题分解成规模缩小的同类问题的子问题，然后递归调用方法来表示问题的解。</p>
<p>以编程的角度来说，递归指的是方法定义中调用方法本身的现象</p>
<p>递归的基本原理</p>
<ul>
<li>第一：每一级的函数调用都有自己的变量。</li>
<li>第二：每一次函数调用都会有一次返回。</li>
<li>第三：递归函数中，位于递归调用前的语句和各级被调用函数具有相同的执行顺序。</li>
<li>第四：递归函数中，位于递归调用后的语句的执行顺序和各个被调用函数的顺序相反。</li>
<li>第五：虽然每一级递归都有自己的变量，但是函数代码并不会得到复制。</li>
</ul>
<p>递归的三大要素</p>
<ul>
<li>第一要素：明确你这个函数想要干什么。先不管函数里面的代码什么，而是要先明白，你这个函数的功能是什么，要完成什么样的一件事。</li>
<li>第二要素：寻找递归结束条件。我们需要找出当参数为啥时，递归结束，之后直接把结果返回，请注意，这个时候我们必须能根据这个参数的值，能够直接知道函数的结果是什么。</li>
<li>第三要素：找出函数的等价关系式。我们要不断缩小参数的范围，缩小之后，我们可以通过一些辅助的变量或者操作，使原函数的结果不变。</li>
</ul>
<p>递归解决问题的思路：</p>
<ul>
<li>把一个复制的问题层层转化为一个与原问题相似的规模较小的问题来求解</li>
<li>递归策略只需少量的程序就可以描述出解题过程所需要的多次重复计算</li>
</ul>
<p>递归解决问题需要找到两个内容：</p>
<ul>
<li>递归出口：否则会出现内存溢出</li>
<li>递归规则：与原问题相似的规模较小的问题</li>
</ul>
<pre><code>package io.file;

/**
 * 递归概述：
 *      以编程的角度来说，递归指的是方法定义中调用方法本身的现象
 *
 * @author qq_lin
 */
public class DiGuiDemo {
    public static void main(String[] args) {
        int[] arr = new int[20];

        arr[0] = 1;
        arr[1] = 1;

        for (int i = 2; i &lt; arr.length; i++) {
            arr[i] = arr[i - 1] + arr[i - 2];
        }
        System.out.println(arr[19]);
        System.out.println(f(20));
    }

    /**
     * 递归解决问题，首先需要定义一个方法：
     *      定义一个方法f(n):表示第n个月的兔子对数
     *      那么，第n-1个月的兔子对数该如何表示：f(n-1)
     *      同理，第n-2个月的兔子对数该如何表示：f(n-2)
     */
    public static int f(int n) {
        if (n==1 || n == 2) {
            return 1;
        } else {
            return f(n - 1) + f(n - 2);

        }
    }
}
</code></pre><p>递归的优化方法</p>
<p>递归问题中想到思路本身不非常难，真正的难点在于如何优化。</p>
<ol>
<li>考虑是否重复计算</li>
</ol>
<ul>
<li>如果你使用递归的时候不进行优化，是有非常非常非常多的子问题被重复计算的。因此，使用递归的时候，必要须要考虑有没有重复计算，如果重复计算了，一定要把计算过的状态保存起来。</li>
</ul>
<ol start="2">
<li>考虑尾递归</li>
</ol>
<ul>
<li>
<p>对于递归的问题，我们一般都是从上往下递归的，直到递归到最底，再一层一层着把值返回。</p>
</li>
<li>
<p>不过，有时候当 n 比较大的时候，例如当 n = 10000 时，那么必须要往下递归10000层直到 n &lt;=1 才将结果慢慢返回，如果n太大的话，可能栈空间会不够用。这个时候，就可以用尾递归优化来解决。</p>
</li>
<li>
<p>顾名思义，尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量。直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。</p>
</li>
</ul>
<p>以下为递归的案例题</p>
<pre><code>package io.file;

/**
 * 需求：递归求5的阶乘，并把结果在控制台输出
 * 思路：
 *      1、定义一个方法，用于递归求阶乘，参数为一个int类型的变量
 *      2、在内部判断变量的值是否为1
 *          是：返回1
 *          不是：返回n*(n-1)!
 *      3、调用方法
 *      4、输出结果
 *
 * @author qq_lin
 */
public class DiGuiDemo2 {
    public static void main(String[] args) {
        int result = f(5);
        System.out.println(&quot;5的阶乘是&quot; + result);
    }

    static int f(int n) {
        if (n == 1) {
            return 1;
        } else {
            return n * f(n-1);
        }
    }
}
</code></pre><pre><code>package io.file;

import java.io.File;

/**
 * 需求：
 *      给定一个路径（d:/linqq/itcast),请通过递归完成遍历该目录下的所有内容，并把所有文件的绝对路径输出在控制台
 * 思路：
 *      1、根据给定的路径创建一个File对象
 *      2、定义一个方法，用于获取给定目录下的所有内容，参数为第一步创建的File对象
 *      3、获取给定的File目录下所有的文件或者目录的File数据
 *      4、遍历该File数组，得到每个File对象
 *      5、判断该File对象是否是目录
 *          是：递归调用
 *          不是：获取绝对路径输出在控制台
 *      6、调用方法
 *
 * @author qq_lin
 */
public class DiGuiDemo3 {
    public static void main(String[] args) {
        File srcFile = new File(&quot;d:/linqq&quot;);

        getAllFilePath(srcFile);
    }

    /**
     * 定义一个方法，用于获取给定目录下的所有内容
     * @param srcFile 参数为第一步创建的File对象
     */
    public static void getAllFilePath(File srcFile) {
        /**
         * 获取给定的File目录下所有的文件或者目录的File数据
         */
        File[] fileArray = srcFile.listFiles();
        /**
         * 遍历该File数组，得到每个File对象
         */
        if (fileArray != null) {
            int count = 0;
            int sum = 0;
            for (File file :
                    fileArray) {
                // 判断该File对象是否是目录
                if (file.isDirectory()) {
                    count ++;
                    sum = count + sum;
                    System.out.println(&quot;目录: &quot; + file.getName() + &quot;\n&quot; + &quot;里面有&quot;  + count + &quot;个文件&quot;);
                    System.out.println(&quot;------&quot;);
                    // 是：递归调用
                    getAllFilePath(file);
                } else {
                    // 不是：获取绝对路径输出在控制台
                    System.out.println(file.getAbsoluteFile());
                }
            }
        }
    }
}
</code></pre><hr>
<h2 id="132-字节流">13.2 字节流</h2>
<hr>
<h3 id="1321-io流概述和分类">13.2.1 IO流概述和分类</h3>
<p>IO流概述：</p>
<ul>
<li>IO：输入、输出（Input/Ouput)</li>
<li>流：一种抽象概念，是对数据传输的总称。也就是说数据在设备间的传输为流，流的本质是数据传输</li>
<li>IO流就是用来处理设备间数据传输问题的
<ul>
<li>常用的应用：文件复制；文件上传；文件下载</li>
</ul>
</li>
</ul>
<p>IO流分类：</p>
<ul>
<li>按照数据的流向
<ul>
<li>输入流：读数据</li>
<li>输出流：写数据</li>
</ul>
</li>
<li>按照数据类型来分
<ul>
<li>字节流
<ul>
<li>字节输入流；</li>
<li>字节输出流</li>
</ul>
</li>
<li>字符流
<ul>
<li>字符输入流</li>
<li>字符输出流</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>一般情况，IO流的分类按照数据类型来划分的
那么这两种流都在什么情况下使用</p>
<ul>
<li>如果是文本格式，可阅读的情况下，使用字符流，否则，使用字节流</li>
<li>在不清楚的状态下，选用字节流</li>
</ul>
<hr>
<h3 id="1322-字节流写数据">13.2.2 字节流写数据</h3>
<p>字节流抽象基本类</p>
<ul>
<li>InputStream:表示字节输入流的所有类的超类</li>
<li>OutputStream:表示字节输出流的所有类的超类</li>
<li>子类名特点：子类名称都是以其父类名作为子类名的后缀</li>
</ul>
<p>FileOutputStream：文件输出流用于将数据写入File</p>
<ul>
<li>FileOutputStream(String name)；创建文件输出流以制定的名称写入文件</li>
</ul>
<p>使用字节输出流写数据的步骤：</p>
<ul>
<li>创建字节输出流对象（调用系统功能创建了文件，创建了字节输出流对象，让字节输出流对象指向文件）</li>
<li>调用字节输出流对象的写数据方法</li>
<li>释放资源（关闭此文件输出流并释放与此相关联的任何系统资源）</li>
</ul>
<pre><code>package io.file;

import java.io.FileOutputStream;
import java.io.IOException;

/**
 * FileOutputStream：文件输出流用于将数据写入File
 * - FileOutputStream(String name)；创建文件输出流以制定的名称写入文件
 *
 * @author qq_lin
 */
public class FileOutputStreamDemo {
    /**
     * 创建字节流对象
     */
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream(&quot;/fos.txt&quot;);
    /*
        做了三件事：
            A 调用系统功能创建了文件
            B 创建了字节输出流对象
            C 让字节输出流对象指向创建好的文件
     */

        /**
         * void write (int b):将制定的字节写入此文件输出流
         */
        fos.write(97);

        /**
         * void close(): 关闭此文件输出流并释放与此流相关联的任何系统资源
         */
        fos.close();
    }
}
</code></pre><hr>
<h3 id="1323-字节流写数据的3种方式">13.2.3 字节流写数据的3种方式</h3>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
<th align="left">写入</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">void write(int b)</td>
<td align="left">将指定的字节写入此文件输出</td>
<td align="left">一次写一个字节数据</td>
</tr>
<tr>
<td align="left">void write(byte[] b)</td>
<td align="left">将b.length字节从指定的字节数组写入此文件输出流</td>
<td align="left">一次写一个字节数组数据</td>
</tr>
<tr>
<td align="left">void write(byte[] b, int off, int len)</td>
<td align="left">将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流</td>
<td align="left">一次写一个字节数组的部分数据</td>
</tr>
</tbody>
</table>
<pre><code>package io.file;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @author qq_lin
 */
public class FileOutPutStreamDemo2 {
    public static void main(String[] args) throws IOException {
        FileOutputStream fos = new FileOutputStream(&quot;/fos.txt&quot;);
        FileOutputStream fos2 = new FileOutputStream(new File(&quot;/fos.txt&quot;));

        // void write(int b):将制定的字节写入此文件输出流
        fos.write(97);
        fos.write(98);
        fos.write(99);
        fos.write(100);
        fos.write(101);

        // void write(byte[] b): 将b.length字节从指定的字节数组写入此文件输出流
        byte[] bys = {97, 98, 99, 100, 101};
        // byte[] getBytes(): 返回字符串对应的字节数组
        byte[] bys2 = &quot;abcde&quot;.getBytes();

        fos.write(bys);

        // void write(byte[] b, int off, int len:将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流
        fos.write(bys2, 1, 3);

        fos.close();
    }
}
</code></pre><hr>
<h3 id="1324-字节流写数据的两个小问题">13.2.4 字节流写数据的两个小问题</h3>
<p>字节流写数据如何实现换行</p>
<ul>
<li>写入数据后，加换行符
<ul>
<li>Windows：\r\n</li>
<li>Linux：\n</li>
<li>Mac:\r</li>
</ul>
</li>
</ul>
<p>字节流写数据如何实现追加写入</p>
<ul>
<li>public FileOutputStream (String name, boolean append)</li>
<li>创建文件输出流以指定的名称写入文件，如果第二个参数为true，则字节将写入文件的末尾而不是开头</li>
</ul>
<pre><code>package io.file;

import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @author qq_lin
 */
public class FileOutputStreamDemo3 {
    public static void main(String[] args) throws IOException {
        // 创建字节输出流对象
//        FileOutputStream fos = new FileOutputStream(&quot;/fos.txt&quot;);
        
        // public FileOutputStream(String name, boolean append)
        FileOutputStream fos = new FileOutputStream(&quot;/fos.txt&quot;,true);

        // 写数据
        for (int i = 0; i &lt; 10; i++) {
            fos.write(&quot;hello&quot;.getBytes());
            fos.write(&quot;\r\n&quot;.getBytes());
        }

        fos.close();
    }
}
</code></pre><hr>
<h3 id="1325-字节流写数据加异常处理">13.2.5 字节流写数据加异常处理</h3>
<p>finally：在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源
特点：被finally控制的语句一定会执行，除非JVM退出</p>
<pre><code>tyr {
    do something
} catch(IOException e) {
    e.printStackTrace()
} finally {
    fos.closr()
}
</code></pre><pre><code>package io.file;

import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @author qq_lin
 */
public class FileOutputStreamDemo4 {
    public static void main(String[] args)  {
        FileOutputStream fos = null;

        try {
            fos = new FileOutputStream(&quot;/fos.txt&quot;);
            fos.write(&quot;hello&quot;.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
</code></pre><p>try-with-resources: 把流定义在try()里,try,catch或者finally结束的时候，会自动关闭
这种编写代码的方式叫做 try-with-resources， 这是从JDK7开始支持的技术</p>
<p>所有的流，都实现了一个接口叫做 AutoCloseable，任何类实现了这个接口，都可以在try()中进行实例化。 并且在try, catch, finally结束的时候自动关闭，回收相关资源。</p>
<pre><code>package io.file;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * @author qq_lin
 */
public class FileOutputStreamDemo4 {
    public static void main(String[] args)  {
        File f = new File(&quot;/fos.txt&quot;);
        try (FileOutputStream fos = new FileOutputStream(f);){
            fos.write(&quot;hello&quot;.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><hr>
<h3 id="1326-字节流读数据">13.2.6 字节流读数据</h3>
<h4 id="13261-字节流读数据一次读一个字节数据">13.2.6.1 字节流读数据（一次读一个字节数据）</h4>
<p>需求：把文件fos.txt中的内容读取处理在控制台输出</p>
<p>FileInputStream：从文件系统中的文件获取输入字节</p>
<ul>
<li>FileInputStream(String name): 通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的路径名name命名</li>
</ul>
<p>使用字节输入流读数据的步骤：</p>
<ol>
<li>创建字节输入对象</li>
<li>调用字节输入流对象的读数据方法</li>
<li>释放资源</li>
</ol>
<pre><code>package io.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

/**
 * @author qq_lin
 */
public class FileInputStreamDemo {
    public static void main(String[] args) {
        File f = new File(&quot;fos.txt&quot;);

        try ( FileInputStream fis = new FileInputStream(f);){
            int by;
            // 如果文件到达末尾，read()返回 -1
            while ((by=fis.read()) != -1) {
                System.out.println((char)by);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

</code></pre><p>以下为案例</p>
<pre><code>package io.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * 需求：将一个文本文件复制到另一个位置
 * 思路：
 *      1、根据数据源创建字节输入流对象
 *      2、根据目的地创建字节输出流对象
 *      3、读写数据，复制文本文件（一次读取一个字节，一个写入一个字节）
 *      4、释放资源
 *
 * @author qq_lin
 */
public class FileCopy {
    public static void main(String[] args) {
        File f1 = new File(&quot;fos.txt&quot;);
        File f2 = new File(&quot;d:/linqq/fos.txt&quot;);
        try (
                FileInputStream fis = new FileInputStream(f1);
                FileOutputStream fos = new FileOutputStream(f2);
                ){
            int by;
            // 如果文件到达末尾，read()返回 -1
            while ((by=fis.read()) != -1) {
                fos.write(by);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h4 id="13262-字节流读数据一次读一个字节数组数据">13.2.6.2 字节流读数据（一次读一个字节数组数据）</h4>
<p>需求：把文件fos.txt中的内容读取出来在控制台输出</p>
<p>使用字节输入流读数据的步骤：</p>
<ol>
<li>创建字节输入对象</li>
<li>调用字节输入流对象的读数据方法</li>
<li>释放资源</li>
</ol>
<pre><code>package io.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

/**
 * @author qq_lin
 */
public class FileInputStreamDemo2 {
    public static void main(String[] args) {
        File f = new File(&quot;fos.txt&quot;);

        try (FileInputStream fis = new FileInputStream(f);){
            byte[] bys = new byte[1024];
            int len;
            // 如果文件到达末尾，read()返回 -1
            while ((len=fis.read(bys)) != -1) {
                int read = fis.read(bys, 0, len);
                System.out.println(read);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>以下为案例：</p>
<pre><code>package io.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

/**
 * 需求：复制图片格式的文件到另一个文件夹
 * 思路：
 *      1、根据数据源创建字节输入流对象
 *      2、根据目的地创建字节输出流对象
 *      3、读写数据，复制图片（一次读取一个字节数组，一次写入一个字节数据）
 *      4、释放资源
 * 
 * @author qq_lin
 */
public class FileCopyImage {
    public static void main(String[] args) {
        File f1 = new File(&quot;mn.jpg&quot;);
        File f2 = new File(&quot;d:/mn.jpg&quot;);
        
        try (
                FileInputStream fis = new FileInputStream(f1);
                FileOutputStream fos = new FileOutputStream(f2);
                ){
            byte[] bys = new byte[1024];
            int len;
            while ((len=fis.read(bys)) != -1) {
                fos.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><hr>
<h3 id="1327-字节流缓冲流">13.2.7 字节流缓冲流</h3>
<p>字节缓冲流：</p>
<ul>
<li>BufferedOutputStream:该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</li>
<li>BufferedInputStream:创建BufferInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需求从所包含的输入流中重新填充，一次很多字节</li>
</ul>
<p>构造方法：</p>
<ul>
<li>字节缓冲输出流：BufferedOutputStream(OutputStream out)</li>
<li>字节缓冲输入流：BufferedInputStreamm(InputStream in)</li>
</ul>
<p>为什么构造器需要的是字节流，而不是具体的文件或者路径</p>
<ul>
<li>字节缓冲区仅仅提供缓冲区，而真正的读写数据还得依靠基本的字节流对象进行操作</li>
</ul>
<pre><code>package io.file;

import java.io.*;

/**
 * @author qq_lin
 */
public class BufferOutputStreamDemo {
    public static void main(String[] args) {
        File f = new File(&quot;fos.txt&quot;);

        /**
         * 利用字节缓冲BufferedOutputStream，写入数据
         */
        try (
                FileOutputStream fos = new FileOutputStream(f);
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                ){
            bos.write(&quot;hello\r\n&quot;.getBytes());
            bos.write(&quot;world\r\n&quot;.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }

        /**
         * 利用字节缓冲BufferedInputStream，读取数据：
         *      分别为两种方式，单个字节读取，单个字节数组读取
         */
        try (
                FileInputStream fis = new FileInputStream(f);
                BufferedInputStream bis = new BufferedInputStream(fis);
                ) {
            int by;
            while ((by = bis.read()) != -1) {
                System.out.println((char) by);
            }

            byte[] bys = new byte[1024];
            int len;
            while ((len = bis.read(bys)) != -1) {
                bis.read(bys, 0, len);
            }
        } catch(IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>以下为案例：</p>
<pre><code>package io.file;

import java.io.*;

/**
 * 需求：复制一个视频文件，到另一位置
 * 思路：
 *    1、根据数据源创建字节输入流对象
 *    2、根据目的地创建字节输出流对象
 *    3、读写数据，复制视频（一次读取一个字节数组，一次写入一个字节数组）
 *    4、释放资源
 *
 * 方法：四种实现方式，并记录每种方法复制视频的时间：
 *    1、基本字节流一次读写一个字节        耗时：64565ms
 *    2、基本字节流一次读写一个字节数组    耗时：107ms
 *    3、字节缓冲流一次读写一个字节        耗时：405ms
 *    4、字节缓冲流一次读写一个字节数据    耗时：60ms
 * 
 * 结论：字节缓冲流一次读写一个字节数据，速度最快
 *
 * @author qq_lin
 */
public class FileCopyVideo {
    public static void main(String[] args) {
        // 记录开始时间
        long startTime = System.currentTimeMillis();

        // 复制视频
        method1();
//        method2();
//        method3();
//        method4();

        // 记录结束时间
        long endTime = System.currentTimeMillis();
        System.out.println(&quot;共耗时： &quot; + (endTime - startTime) + &quot;毫秒&quot;);
    }

    /**
     * 1、基本字节流一次读写一个字节
     */
    public static void method1(){
        File f1 = new File(&quot;lol.avi&quot;);
        File f2 = new File(&quot;d:/lol.avi&quot;);

        try (
                FileInputStream fis = new FileInputStream(f1);
                BufferedInputStream bis = new BufferedInputStream(fis);
                FileOutputStream fos = new FileOutputStream(f2);
                BufferedOutputStream bos = new BufferedOutputStream(fos);
                ){
            int by;
            while ((by = fis.read()) != -1) {
                fos.write(by);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 2、基本字节流一次读写一个字节数组
     */
    public static void method2(){
        File f1 = new File(&quot;lol.avi&quot;);
        File f2 = new File(&quot;d:/lol.avi&quot;);

        try (
                FileInputStream fis = new FileInputStream(f1);
                BufferedInputStream bis = new BufferedInputStream(fis);
                FileOutputStream fos = new FileOutputStream(f2);
                BufferedOutputStream bos = new BufferedOutputStream(fos);
        ){
            byte[] bys = new byte[1024];
            int len;
            while ((len = fis.read(bys)) != -1) {
                fos.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * 3、字节缓冲流一次读写一个字节
     */
    public static void method3(){
        File f1 = new File(&quot;lol.avi&quot;);
        File f2 = new File(&quot;d:/lol.avi&quot;);

        try (
                FileInputStream fis = new FileInputStream(f1);
                BufferedInputStream bis = new BufferedInputStream(fis);
                FileOutputStream fos = new FileOutputStream(f2);
                BufferedOutputStream bos = new BufferedOutputStream(fos);
        ){
            int by;
            while ((by = bis.read()) != -1) {
                bos.write(by);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    /**
     * 4、字节缓冲流一次读写一个字节数据
     */
    public static void method4(){
        File f1 = new File(&quot;lol.avi&quot;);
        File f2 = new File(&quot;d:/lol.avi&quot;);

        try (
                FileInputStream fis = new FileInputStream(f1);
                BufferedInputStream bis = new BufferedInputStream(fis);
                FileOutputStream fos = new FileOutputStream(f2);
                BufferedOutputStream bos = new BufferedOutputStream(fos);
        ){
            byte[] bys = new byte[1024];
            int len;
            while ((len = bis.read(bys)) != -1) {
                bos.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}
</code></pre><hr>
<h2 id="133-字符流">13.3 字符流</h2>
<hr>
<h3 id="1331-为什么会出现字符流">13.3.1 为什么会出现字符流</h3>
<p>由于字节流操作中文不方便，所以Java就提供字符流</p>
<ul>
<li>字符流 = 字节流 + 编码表</li>
</ul>
<p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题，原因是最终地产操作会自动进行拼接成中文，如何识别是中文</p>
<ul>
<li>汉字在存储的时候，无论选择哪种编码存在，第一个字节都负数</li>
</ul>
<h3 id="1332-编码表">13.3.2 编码表</h3>
<p>工作后经常接触的编码方式有如下几种：</p>
<ul>
<li>ISO-8859-1 ASCII 数字和西欧字母</li>
<li>GBK GB2312 BIG5 中文</li>
<li>UNICODE (统一码，万国码)</li>
</ul>
<p>其中
ISO-8859-1 包含 ASCII</p>
<p>GB2312 是简体中文，BIG5是繁体中文，GBK同时包含简体和繁体以及日文。</p>
<p>UNICODE 包括了所有的文字，无论中文，英文，藏文，法文，世界所有的文字都包含其中,然后 UTF-8，UTF-16和UTF-32，就是对其的二次优化，其中UTF-8最常用</p>
<hr>
<h3 id="1333-字符串中的编码解码问题">13.3.3 字符串中的编码解码问题</h3>
<p>编码：</p>
<ul>
<li>byte[] getBytes():使用平台的默认字符串将该String编码为一系列字节，将结果存储到新的字节数组中</li>
<li>byte[] getBytes(String charsetName): 使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中</li>
</ul>
<p>解码：</p>
<ul>
<li>String(byte[] bytes): 通过使用平台的默认字符集解码指定的字节数组来构造新的String</li>
<li>String(byte[] bytes, String CharsetName):通过指定的字符集解码指定的字节数组来构造新的String</li>
</ul>
<pre><code>package io.file;

import java.io.UnsupportedEncodingException;

/**
 * 编码：
 * - byte[] getBytes():使用平台的默认字符串将该String编码为一系列字节，将结果存储到新的字节数组中
 * - byte[] getBytes(String charsetName): 使用指定的字符集将该String编码为一系列字节，将结果存储到新的字节数组中
 *
 * 解码：
 * - String(byte[] bytes): 通过使用平台的默认字符集解码指定的字节数组来构造新的String
 * - String(byte[] bytes, String CharsetName):通过指定的字符集解码指定的字节数组来构造新的String
 *
 * @author qq_lin
 */
public class StringDemo {
    public static void main(String[] args) throws UnsupportedEncodingException {
        // 定义一个字符串
        String s = &quot;中国&quot;;
        
        // byte[] getBytes():使用平台的默认字符串将该String编码为一系列字节，将结果存储到新的字节数组中
        byte[] bytes = s.getBytes();
        // byte[] getBytes(String charsetName): 使用指定的字符集将该String编码为一系列字节
        byte[] bytes1 = s.getBytes(&quot;UTF-8&quot;);
        
        System.out.println(bytes);
        System.out.println(bytes1);

        // String(byte[] bytes): 通过使用平台的默认字符集解码指定的字节数组来构造新的String
        String s1 = new String(bytes);
        String s2 = new String(bytes1);
        // String(byte[] bytes, String CharsetName):通过指定的字符集解码指定的字节数组来构造新的String
        String s3 = new String(bytes,&quot;UTF-8&quot;);
        System.out.println(s3);
    }
}
</code></pre><h3 id="1334-字符流中的编码解码问题">13.3.4 字符流中的编码解码问题</h3>
<p>字符流抽象基类：</p>
<ul>
<li>Reader：字符输入流的抽象类</li>
<li>Writer: 字符输出流的抽象类</li>
</ul>
<p>字符流中的编码解码问题相关的两个类：</p>
<ul>
<li>InputStreamReader:是从字节流到字符流的桥梁
<ul>
<li>读取字节，并使用指定的编码将其家吗为字符</li>
<li>使用的字符集可以有名称指定，也可以被明确指定，或者可以接受平台的默认字符集</li>
</ul>
</li>
<li>OutputStreamWriter：是从字符流到字节流的桥梁
<ul>
<li>使用指定的编码将写入的字符编码为字节</li>
<li>使用的字符集可以有名称指定，也可以被明确指定，或者可以接受平台的默认字符集</li>
</ul>
</li>
</ul>
<pre><code>package io.file;

import java.io.*;

/**
 * - InputStreamReader:是从字节流到字符流的桥梁
 *   - 读取字节，并使用指定的编码将其家吗为字符
 *   - 使用的字符集可以有名称指定，也可以被明确指定，或者可以接受平台的默认字符集
 * - OutputStreamWriter：是从字符流到字节流的桥梁
 *   - 使用指定的编码将写入的字符编码为字节
 *   - 使用的字符集可以有名称指定，也可以被明确指定，或者可以接受平台的默认字符集
 *
 * @author qq_lin
 */
public class StringDemo2 {
    public static void main(String[] args) throws IOException {
        File f = new File(&quot;java.txt&quot;);

        FileOutputStream fos = new FileOutputStream(f);
        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;UTF-8&quot;);
        osw.write(&quot;中国&quot;);
        osw.close();

        FileInputStream fis = new FileInputStream(f);
        InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;);
        int ch;
        while ((ch=isr.read()) != -1) {
            System.out.println((char)ch);
        }
        isr.close();
    }
}
</code></pre><h3 id="1335-字符流写数据的5种方式">13.3.5 字符流写数据的5种方式</h3>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">void write(int c)</td>
<td align="left">写一个字符</td>
</tr>
<tr>
<td align="left">void write(char[] cbuf)</td>
<td align="left">写入一个字符数组</td>
</tr>
<tr>
<td align="left">void write(char[] cbuf, int off, int len)</td>
<td align="left">写入字符串的一部分</td>
</tr>
<tr>
<td align="left">void write(String str)</td>
<td align="left">写入一个字符串</td>
</tr>
<tr>
<td align="left">void write(String str, int off, int len)</td>
<td align="left">写一个字符串的一部分</td>
</tr>
</tbody>
</table>
<pre><code>package io.file;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;

/**
 * @author qq_lin
 */
public class StringDemo3 {
    public static void main(String[] args) throws IOException {
        File f = new File(&quot;java.txt&quot;);
        FileOutputStream fos = new FileOutputStream(f);
        OutputStreamWriter osw = new OutputStreamWriter(fos, &quot;UTF-8&quot;);

        // void write(int c),写一个字符
        osw.write(97);
        osw.flush();
        

        // void write(char[] cbuf),写入一个字符数组
        char[] chars = {'a', 'b', 'c', 'd', 'e'};
        osw.write(chars);
        //  void write(char[] cbuf, int off, int len),写入字符串的一部分
        osw.write(chars, 0, 3);
        osw.write(chars, 0, chars.length);

        // void write(String str),写入一个字符串
        String s = &quot;abcde&quot;;
        osw.write(s);
        // void write(String str, int off, int len),写一个字符串的一部分
        osw.write(s, 0, 3);
        osw.write(s, 0, s.length());

        osw.close();
    }
}
</code></pre><h3 id="1336-字符流读数据的2种方式">13.3.6 字符流读数据的2种方式</h3>
<table>
<thead>
<tr>
<th align="left">方法名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">int read()</td>
<td align="left">一次读一个字符数据</td>
</tr>
<tr>
<td align="left">int read(char[] cbuf)</td>
<td align="left">一次读一个字符数组数据</td>
</tr>
</tbody>
</table>
<pre><code>package io.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

/**
 * @author qq_lin
 */
public class StringDemo4 {
    public static void main(String[] args) throws IOException {
        File f = new File(&quot;java.txt&quot;);
        FileInputStream fis = new FileInputStream(f);
        InputStreamReader isr = new InputStreamReader(fis, &quot;UTF-8&quot;);

        // int read(),一次读一个字符数据
        int ch;
        while ((ch = isr.read()) != -1) {
            System.out.println((char)ch);
        }

        // int read(char[] cbuf),一次读一个字符数组数据
        char[] chars = new char[1024];
        int len;
        while ((len = isr.read()) != -1) {
            System.out.print(new String(chars, 0, len));
        }

        isr.close();
    }
}
</code></pre><p>以下为案例:</p>
<pre><code>package io.file;

import java.io.*;

/**
 * 需求：
 *      把模块目录下的文件复制到模块目录下
 *
 * 思路：
 *      1、根据数据源创建字符输入流对象
 *      2、根据目的地创建字符输出流对象
 *      3、写入数据，复制文件
 *      4、释放资源
 *
 * @author qq_lin
 */
public class StringDemo5 {
    public static void main(String[] args) {
        File f = new File(&quot;java.txt&quot;);
        File f2 = new File(&quot;d:/linqq/java.txt&quot;);

        try (
                FileInputStream fis = new FileInputStream(f);
                InputStreamReader isr = new InputStreamReader(fis);
                FileOutputStream fos = new FileOutputStream(f2);
                OutputStreamWriter osw = new OutputStreamWriter(fos);
                ){
//            int ch;
//            while ((ch = isr.read()) != -1) {
//                osw.write(ch);
//            }
            
            char[] chars = new char[1024];
            int len;
            while ((len = isr.read(chars)) != -1) {
                osw.write(chars, 0, len);
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>以下为案例：</p>
<pre><code>package io.file;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

/**
 * 需求：
 *      把模块目录下的文件复制到模块目录下
 *
 * 分析：
 *      1、轮转流的名字比较长，而我们常见的操作都是按照本地默认的编码实现，因此可以使用对应的子类
 *      2、FileReader:用于读取字符文件的便捷类
 *          FileReader(String fileName)
 *      3、FileWriter:用于写入字符文件的便捷类
 *          FileWrite(String fileName)
 *      4、数据源和目的地的分析
 *          数据源：java.txt -&gt; 读数据 -&gt; Reader -&gt; InputStreamReader -&gt; FileReader
 *          目的地：d:/linqq/java.txt -&gt; 写数据 -&gt; Writer -&gt; OutputStreamWriter -&gt; FileWriter
 *
 * 思路：
 *      1、根据数据源创建字符输入流对象
 *      2、根据目的地创建字符输出流对象
 *      3、写入数据，复制文件
 *      4、释放资源
 *
 * @author qq_lin
 */
public class StringDemo6 {
    public static void main(String[] args) {
        File f = new File(&quot;java.txt&quot;);
        File f2 = new File(&quot;d:/linqq/java.txt&quot;);

        try (
                FileReader fr = new FileReader(f);
                FileWriter fw = new FileWriter(f2);
                ){
//            int ch;
//            while ((ch = fr.read()) != -1) {
//                fw.write(ch);
//            }

            char[] chars = new char[1024];
            int len;
            while ((len = fr.read(chars)) != -1) {
                fw.write(chars, 0, len);
            }


        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id="1337-字节缓冲流">13.3.7 字节缓冲流</h3>
<p>字符缓冲流：</p>
<ul>
<li>BufferedWriter:将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小，默认值足够大，可以用于大多数用途</li>
<li>BufferedReader:从字符输入轮流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可以用于大多数用途</li>
</ul>
<p>构造方法：</p>
<ul>
<li>BufferedWriter(Writer out)</li>
<li>BuffferedReader(Reader in)</li>
</ul>
<pre><code>package io.file;

import java.io.*;

/**
 * @author qq_lin
 */
public class BufferWriterDemo {
    public static void main(String[] args) {
        File f = new File(&quot;java.txt&quot;);
        File f2 = new File(&quot;d:/linqq/java.txt&quot;);
        
        try (   
                FileReader fr = new FileReader(f);
                BufferedReader br = new BufferedReader(fr);
                FileWriter fw = new FileWriter(f2);
                BufferedWriter bw = new BufferedWriter(fw);
                ){
            
//            int ch;
//            while ((ch = br.read()) != -1) {
//                bw.write(ch);
//            }
            
            char[] chars = new char[1024];
            int len;
            while ((len = br.read(chars)) != -1) {
                bw.write(chars, 0, len);
            }
            
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id="1338-字符缓冲流特有功能">13.3.8 字符缓冲流特有功能</h3>
<p>BufferedWriter:</p>
<ul>
<li>void newLine():写一行行分隔符，行分割符字符串由系统属性定义</li>
</ul>
<p>BufferedReader:</p>
<ul>
<li>public String readLine():读一行文字，结果包含行的内容的字符串，不包括任何终止字符，如果流的结尾已经到达，则为null</li>
</ul>
<pre><code>package io.file;

import java.io.*;

/**
 * @author qq_lin
 */
public class BufferedWriterDemo2 {
    public static void main(String[] args) {
        File f = new File(&quot;java.txt&quot;);
        File f2 = new File(&quot;d:/linqq/java.txt&quot;);

        try (
                FileReader fr = new FileReader(f);
                BufferedReader br = new BufferedReader(fr);
                FileWriter fw = new FileWriter(f2);
                BufferedWriter bw = new BufferedWriter(fw);
                ){

            String line;
            while ((line = br.readLine()) != null) {
                bw.write(line);
                bw.newLine();
                bw.flush();
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><hr>
<h3 id="1339-io流小结">13.3.9 IO流小结</h3>
<p>字节流：</p>
<ul>
<li>字节输入流InputStream
<ul>
<li>FileInputStream</li>
<li>BufferedInputStream</li>
</ul>
</li>
<li>字节输出流OutputStream
<ul>
<li>FileOutputStream</li>
<li>BufferedOutputStream</li>
</ul>
</li>
</ul>
<p>字符流：</p>
<ul>
<li>字符输入流Reader
<ul>
<li>InputStreamReader
<ul>
<li>FileReader</li>
</ul>
</li>
<li>BufferedReader</li>
</ul>
</li>
<li>字符输出流Writer
<ul>
<li>OutputStreamWriter
<ul>
<li>FileWriter</li>
</ul>
</li>
<li>BufferedWriter</li>
</ul>
</li>
</ul>
<hr>
<h2 id="134-特殊操作流">13.4 特殊操作流</h2>
<h3 id="1341-标准输入输出流">13.4.1 标准输入输出流</h3>
<p>System类种由两个静态的成员变量：</p>
<ul>
<li>public static final InputStream in:标准输入流。通常该流对应于键盘输入或由主机环境或用户指定的另一个输入源</li>
<li>public Static final PrintStream out:标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输入目标</li>
</ul>
<pre><code>package io.file;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Scanner;

/**
 * @author qq_lin
 */
public class SystemIn {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        System.out.println(&quot;请输入一个字符串：&quot;);
        String line = br.readLine();
        System.out.println(&quot;你输入的字符串是： &quot; + line);

        System.out.println(&quot;请输入一个整数：&quot;);
        int i = Integer.parseInt(br.readLine());
        System.out.println(&quot;你输入的整数是： &quot; + i);

        // 然而以上语句过于冗长，Java提供了Scanner类
        Scanner sc = new Scanner(System.in);
    }
}
</code></pre><p>自己实现键盘录入数据：</p>
<ul>
<li>BufferedReader br = new BufferedReader(new InputStreamReader(System.in));</li>
</ul>
<p>代码过于冗长，使用Java提供的一个类实现键盘录入</p>
<ul>
<li>Scanner sc = new Scanner(System.in);</li>
</ul>
<p>输出语句的本质：是一个标准的输出流</p>
<ul>
<li>PrintStream ps = System.out;</li>
<li>PrintStream类有的方法，System.out都可以用</li>
</ul>
<h3 id="1342-打印流">13.4.2 打印流</h3>
<p>打印流分类</p>
<ul>
<li>字节打印流：PrintStream</li>
<li>字符打印流：PrintWriter</li>
</ul>
<p>打印流的特点：</p>
<ul>
<li>只负责输出数据，不负责读取数据</li>
<li>有自己的特有方法</li>
</ul>
<p>字节打印流</p>
<ul>
<li>PrintStream(String fileName):使用指定的文件名创建新的打印流</li>
<li>使用继承父类的方法写数据，查看的时候会转码；使用自己的特有方法写数据，查看的数据原样输出</li>
</ul>
<p>字符打印流</p>
<ul>
<li>PrintWriter(String fileName): 使用指定的文件名创建一个新的PrintWriter，而不需要自动执行刷选</li>
<li>Printwriter(Writer out, boolean autoFlush):创建一个新的PrintWriter
<ul>
<li>out:字符输出流</li>
<li>autoFlush:一个布尔值，如果为真，则println、printf，或者format方法将刷新输出缓冲区</li>
</ul>
</li>
</ul>
<h3 id="1343-对象序列化流">13.4.3 对象序列化流</h3>
<p>对象序列化：就是将对象保存到磁盘中，或者在网络中传输对象</p>
<p>这种机制就是使用一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象中存储的属性等信息</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化</p>
<p>要实现序列化和反序列化就要使用对象序列化流和对象反序列化流：</p>
<ul>
<li>对象序列化流：ObjectOutputStream
<ul>
<li>将Java对象的原始数据类型和图形写入OutputSream,可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象</li>
<li>构造方法：
<ul>
<li>ObjectOutputStream(OutputStream out):创建一个写入指定的OutputStream的ObjectOutputStream</li>
</ul>
</li>
<li>序列化对象的方法：
<ul>
<li>void writeObject(Object obj):将指定的对象写入ObjectOutputStream</li>
</ul>
</li>
<li>注意：
<ul>
<li>一个对象要想被序列化，该对象所属的类必须实现Serializable接口</li>
<li>Serializable是一个标记接口，实现该接口，不需要重写任何方法</li>
</ul>
</li>
</ul>
</li>
<li>对象反序列化流：ObjectInputStream
<ul>
<li>ObjectInputSream反序列化先前使用ObjectOutputStream编写的原始数据和对象</li>
<li>构造方法：ObjectInputStream(InputStream in)</li>
<li>反序列化对象的方法：ObjectreadObject()</li>
</ul>
</li>
</ul>
<pre><code>package com.itheima_02;

import java.io.Serializable;

/**
 * @author qq_lin
 */
public class Student implements Serializable {
    private static final long serialVersionUID = 42L;
	private String name;
	private float age;

	public float getAge() {
		return age;
	}

	public void setAge(float age) {
		this.age = age;
	}

	public Student(String name, float age) {
		this.name = name;
		this.age = age;
	}

	public Student() {
	}

	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}

}
</code></pre><pre><code>package io.file;

import com.itheima_02.Student;

import java.io.*;

/**
 * @author qq_lin
 */
public class ObjectStreamDemo {
    public static void main(String[] args) throws IOException {
        write();
        read();
    }

    /**
     * 反序列化
     */
    private static void read() {
        File f = new File(&quot;oos.txt&quot;);
        try (
                FileInputStream fis = new FileInputStream(f);
                ObjectInputStream ois = new ObjectInputStream(fis);
                ){
            Object o = ois.readObject();
            Student s = (Student) o;
            System.out.println(s.getName() + &quot;, &quot; + s.getAge());

        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }

    /**
     * 序列化
     */
    private static void write() {
        File f = new File(&quot;oos.txt&quot;);
        try (
                FileOutputStream fos = new FileOutputStream(f);
                ObjectOutputStream oos = new ObjectOutputStream(fos);
                ){
            Student s = new Student(&quot;李小龙&quot;, 30);
            oos.writeObject(s);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><h3 id="序列化中存在的问题">序列化中存在的问题</h3>
<p>用对象序列化流序列化了一个对象后，假如我们修改了对象所属的类文件，读取数据会不会出现问题？</p>
<ul>
<li>
<p>java.io.InvalidClassExcepion</p>
<ul>
<li>当序列化运行时检测到类中的以下问题之一时抛出
<ul>
<li>类的串行版本与从流中读取的类描述符的类型不匹配</li>
<li>该类包含未知的数据类型</li>
<li>该类没有可访问的无参数构造函数</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Stream classdesc serialVersionUID = -3743788623620386195</p>
</li>
<li>
<p>Local class serialVersionUID = -247282590948908173</p>
</li>
</ul>
<p>如果出现问题了，该如何解决？</p>
<ul>
<li>给对象所属的类加一个值：private static final long serialVersionUID = 42L;</li>
</ul>
<p>如果一个对象中的某个成员变量的值不想被序列化，该如何操作？</p>
<ul>
<li>给对象中的成员变量属性加一个修饰符transient：private float tramsient age;</li>
</ul>
<hr>
<h3 id="1344-properties">13.4.4 Properties</h3>
<p>Properties概述:</p>
<ul>
<li>是一个Map体系的集合类</li>
<li>Properties可以保存到流中或从流中加载</li>
</ul>
<pre><code>package io.file;

import java.util.Properties;
import java.util.Set;

/**
 * @author qq_lin
 */
public class PropertiesDemo {
    public static void main(String[] args) {
        Properties prop = new Properties();

        prop.put(&quot;001&quot;, &quot;a&quot;);
        prop.put(&quot;002&quot;, &quot;b&quot;);
        prop.put(&quot;003&quot;, &quot;c&quot;);

        Set&lt;Object&gt; keySet = prop.keySet();
        for (Object key : keySet) {
            Object value = prop.get(key);
            System.out.println(key + &quot;, &quot; + value);
        }
    }
}
</code></pre><p>Properties作为集合的特有方法：
| 方法名                                       | 说明                                                             |
| :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; |
| Object.setProperty(String key, String value) | 设置集合的键和值，都是String类型，底层调用Hashtable方法put       |
| String getProperty(String key)               | 使用此属性列表中指定的键搜索属性                                 |
| Set<!-- raw HTML omitted --> StringPropertyNamees()           | 从该属性列表中返回一个不可修改的键集，其中键及其对应的值是字符串 |</p>
<pre><code>package io.file;

import java.util.Properties;
import java.util.Set;

/**
 * @author qq_lin
 */
public class PropertiesDemo2 {
    public static void main(String[] args) {
        Properties prop = new Properties();

        prop.setProperty(&quot;001&quot;, &quot;a&quot;);
        prop.setProperty(&quot;002&quot;, &quot;b&quot;);
        prop.setProperty(&quot;003&quot;, &quot;c&quot;);

        Set&lt;String&gt; names = prop.stringPropertyNames();
        for (String key : names) {
            String value = prop.getProperty(key);
            System.out.println(key + &quot;, &quot; + value);
        }
    }
}
</code></pre><p>Properties和IO流结合的方法：
| 方法名                                        | 说明                                                                                                  |
| :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- |
| void load(InputStream inStream)               | 从输入字节流读取属性列表（键和元素对）                                                                |
| void load(Reader reader)                      | 从输入字符流读取属性列表（键和元素读对）                                                              |
| void store(OutputStream out, String comments) | 将此属性列表（键和元素对）写入此Properties表中，以适应于使用load(InputStream)方法的格式写入输出字节流 |
| void store(Writer writer, String comments)    | 将此属性列表（键和元素对）写入此Properties表中，以适合使用load（Reader）方法的格式写入输出字符流      |</p>
<pre><code>package io.file;

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Properties;

/**
 * @author qq_lin
 */
public class PropertiesDemo3 {
    public static void main(String[] args) throws IOException {
        myStore();
        myLoad();
    }

    private static void myLoad() throws IOException {
        Properties prop = new Properties();

        FileReader fr = new FileReader(&quot;fw.txt&quot;);
        prop.load(fr);
        fr.close();

        System.out.println(prop);
    }

    private static void myStore() throws IOException {
        Properties prop = new Properties();

        prop.setProperty(&quot;001&quot;, &quot;a&quot;);
        prop.setProperty(&quot;002&quot;, &quot;b&quot;);
        prop.setProperty(&quot;003&quot;, &quot;c&quot;);

        FileWriter fw = new FileWriter(&quot;fw.txt&quot;);
        prop.store(fw, null);
        fw.close();
    }
}
</code></pre><hr>
<h1 id="第14章-jdbc编程">第14章 JDBC编程</h1>
<p>程序运行的时候，往往需要存取数据。现代应用程序最基本，也是使用最广泛的数据存储就是关系数据库。</p>
<p>Java为关系数据库定义了一套标准的访问接口：JDBC（Java Database Connectivity），本章我们介绍如何在Java程序中使用JDBC</p>
<h2 id="141-jdbc简介">14.1 JDBC简介</h2>
<p>在介绍JDBC之前，我们先简单介绍一下关系数据库。</p>
<p>程序运行的时候，数据都是在内存中的。当程序终止的时候，通常都需要将数据保存到磁盘上，无论是保存到本地磁盘，还是通过网络保存到服务器上，最终都会将数据写入磁盘文件。</p>
<p>而如何定义数据的存储格式就是一个大问题。如果我们自己来定义存储格式，比如保存一个班级所有学生的成绩单：
| 名字    | 成绩 |
| :&mdash;&mdash; | :&mdash; |
| Michael | 99   |
| Bob     | 85   |
| Bart    | 59   |
| Lisa    | 87   |</p>
<p>你可以用一个文本文件保存，一行保存一个学生，用,隔开：</p>
<pre><code>Michael,99
Bob,85
Bart,59
Lisa,87
</code></pre><p>你还可以用JSON格式保存，也是文本文件：</p>
<pre><code>[
    {&quot;name&quot;:&quot;Michael&quot;,&quot;score&quot;:99},
    {&quot;name&quot;:&quot;Bob&quot;,&quot;score&quot;:85},
    {&quot;name&quot;:&quot;Bart&quot;,&quot;score&quot;:59},
    {&quot;name&quot;:&quot;Lisa&quot;,&quot;score&quot;:87}
]
</code></pre><p>你还可以定义各种保存格式，但是问题来了：</p>
<p>存储和读取需要自己实现，JSON还是标准，自己定义的格式就各式各样了；</p>
<p>不能做快速查询，只有把数据全部读到内存中才能自己遍历，但有时候数据的大小远远超过了内存（比如蓝光电影，40GB的数据），根本无法全部读入内存。</p>
<p>为了便于程序保存和读取数据，而且，能直接通过条件快速查询到指定的数据，就出现了数据库（Database）这种专门用于集中存储和查询的软件。</p>
<p>数据库软件诞生的历史非常久远，早在1950年数据库就诞生了。经历了网状数据库，层次数据库，我们现在广泛使用的关系数据库是20世纪70年代基于关系模型的基础上诞生的。</p>
<p>关系模型有一套复杂的数学理论，但是从概念上是十分容易理解的。举个学校的例子：</p>
<p>假设某个XX省YY市ZZ县第一实验小学有3个年级，要表示出这3个年级，可以在Excel中用一个表格画出来：</p>
<!-- raw HTML omitted -->
<p>每个年级又有若干个班级，要把所有班级表示出来，可以在Excel中再画一个表格：
<!-- raw HTML omitted --></p>
<p>这两个表格有个映射关系，就是根据Grade_ID可以在班级表中查找到对应的所有班级：
<!-- raw HTML omitted --></p>
<p>也就是Grade表的每一行对应Class表的多行，在关系数据库中，这种基于表（Table）的一对多的关系就是关系数据库的基础。</p>
<p>根据某个年级的ID就可以查找所有班级的行，这种查询语句在关系数据库中称为SQL语句，可以写成：</p>
<pre><code>SELECT * FROM classes WHERE grade_id = '1';
</code></pre>
<p>结果也是一个表：</p>
<pre><code>---------+----------+----------
grade_id | class_id | name
---------+----------+----------
1        | 11       | 一年级一班
---------+----------+----------
1        | 12       | 一年级二班
---------+----------+----------
1        | 13       | 一年级三班
---------+----------+----------
</code></pre><p>类似的，Class表的一行记录又可以关联到Student表的多行记录：
<!-- raw HTML omitted --></p>
<h3 id="nosql">NoSQL</h3>
<p>你也许还听说过NoSQL数据库，很多NoSQL宣传其速度和规模远远超过关系数据库，所以很多同学觉得有了NoSQL是否就不需要SQL了呢？千万不要被他们忽悠了，连SQL都不明白怎么可能搞明白NoSQL呢？</p>
<h3 id="数据库类别">数据库类别</h3>
<p>既然我们要使用关系数据库，就必须选择一个关系数据库。目前广泛使用的关系数据库也就这么几种：</p>
<p>付费的商用数据库：</p>
<ul>
<li>Oracle，典型的高富帅；</li>
<li>SQL Server，微软自家产品，Windows定制专款；</li>
<li>DB2，IBM的产品，听起来挺高端；</li>
<li>Sybase，曾经跟微软是好基友，后来关系破裂，现在家境惨淡。</li>
</ul>
<p>这些数据库都是不开源而且付费的，最大的好处是花了钱出了问题可以找厂家解决，不过在Web的世界里，常常需要部署成千上万的数据库服务器，当然不能把大把大把的银子扔给厂家，所以，无论是Google、Facebook，还是国内的BAT，无一例外都选择了免费的开源数据库：</p>
<ul>
<li>MySQL，大家都在用，一般错不了；</li>
<li>PostgreSQL，学术气息有点重，其实挺不错，但知名度没有MySQL高；</li>
<li>sqlite，嵌入式数据库，适合桌面和移动应用。</li>
</ul>
<p>作为一个Java工程师，选择哪个免费数据库呢？当然是MySQL。因为MySQL普及率最高，出了错，可以很容易找到解决方法。而且，围绕MySQL有一大堆监控和运维的工具，安装和使用很方便。</p>
<h3 id="安装mysql">安装MySQL</h3>
<p>为了能继续后面的学习，你需要从MySQL官方网站下载并安装MySQL Community Server 5.6，这个版本是免费的，其他高级版本是要收钱的（请放心，收钱的功能我们用不上）。MySQL是跨平台的，选择对应的平台下载安装文件，安装即可。</p>
<p>安装时，MySQL会提示输入root用户的口令，请务必记清楚。如果怕记不住，就把口令设置为password。</p>
<p>在Windows上，安装时请选择UTF-8编码，以便正确地处理中文。</p>
<p>在Mac或Linux上，需要编辑MySQL的配置文件，把数据库默认的编码全部改为UTF-8。MySQL的配置文件默认存放在/etc/my.cnf或者/etc/mysql/my.cnf：</p>
<pre><code>[client]
default-character-set = utf8

[mysqld]
default-storage-engine = INNODB
character-set-server = utf8
collation-server = utf8_general_ci
</code></pre><p>重启MySQL后，可以通过MySQL的客户端命令行检查编码：</p>
<pre><code>$ mysql -u root -p
Enter password: 
Welcome to the MySQL monitor...
...

mysql&gt; show variables like '%char%';
+--------------------------+--------------------------------------------------------+
| Variable_name            | Value                                                  |
+--------------------------+--------------------------------------------------------+
| character_set_client     | utf8                                                   |
| character_set_connection | utf8                                                   |
| character_set_database   | utf8                                                   |
| character_set_filesystem | binary                                                 |
| character_set_results    | utf8                                                   |
| character_set_server     | utf8                                                   |
| character_set_system     | utf8                                                   |
| character_sets_dir       | /usr/local/mysql-5.1.65-osx10.6-x86_64/share/charsets/ |
+--------------------------+--------------------------------------------------------+
8 rows in set (0.00 sec)
</code></pre><p>看到utf8字样就表示编码设置正确。</p>
<p>注：如果MySQL的版本≥5.5.3，可以把编码设置为utf8mb4，utf8mb4和utf8完全兼容，但它支持最新的Unicode标准，可以显示emoji字符。</p>
<h3 id="jdbc">JDBC</h3>
<p>什么是JDBC？JDBC是Java DataBase Connectivity的缩写，它是Java程序访问数据库的标准接口。</p>
<p>使用Java程序访问数据库时，Java代码并不是直接通过TCP连接去访问数据库，而是通过JDBC接口来访问，而JDBC接口则通过JDBC驱动来实现真正对数据库的访问。</p>
<p>例如，我们在Java代码中如果要访问MySQL，那么必须编写代码操作JDBC接口。注意到JDBC接口是Java标准库自带的，所以可以直接编译。而具体的JDBC驱动是由数据库厂商提供的，例如，MySQL的JDBC驱动由Oracle提供。因此，访问某个具体的数据库，我们只需要引入该厂商提供的JDBC驱动，就可以通过JDBC接口来访问，这样保证了Java程序编写的是一套数据库访问代码，却可以访问各种不同的数据库，因为他们都提供了标准的JDBC驱动：</p>
<pre><code>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐

│  ┌───────────────┐  │
   │   Java App    │
│  └───────────────┘  │
           │
│          ▼          │
   ┌───────────────┐
│  │JDBC Interface │&lt;─┼─── JDK
   └───────────────┘
│          │          │
           ▼
│  ┌───────────────┐  │
   │  JDBC Driver  │&lt;───── Vendor
│  └───────────────┘  │
           │
└ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ┘
           ▼
   ┌───────────────┐
   │   Database    │
   └───────────────┘
</code></pre><p>从代码来看，Java标准库自带的JDBC接口其实就是定义了一组接口，而某个具体的JDBC驱动其实就是实现了这些接口的类：</p>
<pre><code>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐

│  ┌───────────────┐  │
   │   Java App    │
│  └───────────────┘  │
           │
│          ▼          │
   ┌───────────────┐
│  │JDBC Interface │&lt;─┼─── JDK
   └───────────────┘
│          │          │
           ▼
│  ┌───────────────┐  │
   │ MySQL Driver  │&lt;───── Oracle
│  └───────────────┘  │
           │
└ ─ ─ ─ ─ ─│─ ─ ─ ─ ─ ┘
           ▼
   ┌───────────────┐
   │     MySQL     │
   └───────────────┘
</code></pre><p>实际上，一个MySQL的JDBC的驱动就是一个jar包，它本身也是纯Java编写的。我们自己编写的代码只需要引用Java标准库提供的java.sql包下面的相关接口，由此再间接地通过MySQL驱动的jar包通过网络访问MySQL服务器，所有复杂的网络通讯都被封装到JDBC驱动中，因此，Java程序本身只需要引入一个MySQL驱动的jar包就可以正常访问MySQL服务器：</p>
<pre><code>┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐
   ┌───────────────┐
│  │   App.class   │  │
   └───────────────┘
│          │          │
           ▼
│  ┌───────────────┐  │
   │  java.sql.*   │
│  └───────────────┘  │
           │
│          ▼          │
   ┌───────────────┐     TCP    ┌───────────────┐
│  │ mysql-xxx.jar │──┼────────&gt;│     MySQL     │
   └───────────────┘            └───────────────┘
└ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘
          JVM
</code></pre><h3 id="小结-29">小结</h3>
<p>使用JDBC的好处是：</p>
<ul>
<li>各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发；</li>
<li>Java程序编译期仅依赖java.sql包，不依赖具体数据库的jar包；</li>
<li>可随时替换底层数据库，访问数据库的Java代码基本不变。</li>
</ul>
<hr>
<h2 id="142-jdbc查询">14.2 JDBC查询</h2>
<p>前面我们讲了Java程序要通过JDBC接口来查询数据库。JDBC是一套接口规范，它在哪呢？就在Java的标准库java.sql里放着，不过这里面大部分都是接口。接口并不能直接实例化，而是必须实例化对应的实现类，然后通过接口引用这个实例。那么问题来了：JDBC接口的实现类在哪？</p>
<p>因为JDBC接口并不知道我们要使用哪个数据库，所以，用哪个数据库，我们就去使用哪个数据库的“实现类”，我们把某个数据库实现了JDBC接口的jar包称为JDBC驱动。</p>
<p>因为我们选择了MySQL 5.x作为数据库，所以我们首先得找一个MySQL的JDBC驱动。所谓JDBC驱动，其实就是一个第三方jar包，我们直接添加一个Maven依赖就可以了：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>注意到这里添加依赖的scope是runtime，因为编译Java程序并不需要MySQL的这个jar包，只有在运行期才需要使用。如果把runtime改成compile，虽然也能正常编译，但是在IDE里写程序的时候，会多出来一大堆类似com.mysql.jdbc.Connection这样的类，非常容易与Java标准库的JDBC接口混淆，所以坚决不要设置为compile。</p>
<p>有了驱动，我们还要确保MySQL在本机正常运行，并且还需要准备一点数据。这里我们用一个脚本创建数据库和表，然后插入一些数据：</p>
<p>有了驱动，我们还要确保MySQL在本机正常运行，并且还需要准备一点数据。这里我们用一个脚本创建数据库和表，然后插入一些数据：</p>
<pre><code>-- 创建数据库learjdbc:
DROP DATABASE IF EXISTS learnjdbc;
CREATE DATABASE learnjdbc;

-- 创建登录用户learn/口令learnpassword
CREATE USER IF NOT EXISTS learn@'%' IDENTIFIED BY 'learnpassword';
GRANT ALL PRIVILEGES ON learnjdbc.* TO learn@'%' WITH GRANT OPTION;
FLUSH PRIVILEGES;

-- 创建表students:
USE learnjdbc;
CREATE TABLE students (
  id BIGINT AUTO_INCREMENT NOT NULL,
  name VARCHAR(50) NOT NULL,
  gender TINYINT(1) NOT NULL,
  grade INT NOT NULL,
  score INT NOT NULL,
  PRIMARY KEY(id)
) Engine=INNODB DEFAULT CHARSET=UTF8;

-- 插入初始数据:
INSERT INTO students (name, gender, grade, score) VALUES ('小明', 1, 1, 88);
INSERT INTO students (name, gender, grade, score) VALUES ('小红', 1, 1, 95);
INSERT INTO students (name, gender, grade, score) VALUES ('小军', 0, 1, 93);
INSERT INTO students (name, gender, grade, score) VALUES ('小白', 0, 1, 100);
INSERT INTO students (name, gender, grade, score) VALUES ('小牛', 1, 2, 96);
INSERT INTO students (name, gender, grade, score) VALUES ('小兵', 1, 2, 99);
INSERT INTO students (name, gender, grade, score) VALUES ('小强', 0, 2, 86);
INSERT INTO students (name, gender, grade, score) VALUES ('小乔', 0, 2, 79);
INSERT INTO students (name, gender, grade, score) VALUES ('小青', 1, 3, 85);
INSERT INTO students (name, gender, grade, score) VALUES ('小王', 1, 3, 90);
INSERT INTO students (name, gender, grade, score) VALUES ('小林', 0, 3, 91);
INSERT INTO students (name, gender, grade, score) VALUES ('小贝', 0, 3, 77);
</code></pre><p>在控制台输入mysql -u root -p，输入root口令后以root身份，把上述SQL贴到控制台执行一遍就行。如果你运行的是最新版MySQL 8.x，需要调整一下CREATE USER语句。</p>
<h3 id="jdbc连接">JDBC连接</h3>
<p>使用JDBC时，我们先了解什么是Connection。Connection代表一个JDBC连接，它相当于Java程序到数据库的连接（通常是TCP连接）。打开一个Connection时，需要准备URL、用户名和口令，才能成功连接到数据库。</p>
<p>URL是由数据库厂商指定的格式，例如，MySQL的URL是：</p>
<pre><code>jdbc:mysql://&lt;hostname&gt;:&lt;port&gt;/&lt;db&gt;?key1=value1&amp;key2=value2
</code></pre>
<p>假设数据库运行在本机localhost，端口使用标准的3306，数据库名称是learnjdbc，那么URL如下：</p>
<pre><code>jdbc:mysql://localhost:3306/learnjdbc?useSSL=false&amp;characterEncoding=utf8
</code></pre>
<p>后面的两个参数表示不使用SSL加密，使用UTF-8作为字符编码（注意MySQL的UTF-8是utf8）。</p>
<p>要获取数据库连接，使用如下代码：</p>
<pre><code>// JDBC连接的URL, 不同数据库有不同的格式:
String JDBC_URL = &quot;jdbc:mysql://localhost:3306/test&quot;;
String JDBC_USER = &quot;root&quot;;
String JDBC_PASSWORD = &quot;password&quot;;
// 获取连接:
Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD);
// TODO: 访问数据库...
// 关闭连接:
conn.close();
</code></pre><p>核心代码是DriverManager提供的静态方法getConnection()。DriverManager会自动扫描classpath，找到所有的JDBC驱动，然后根据我们传入的URL自动挑选一个合适的驱动。</p>
<p>因为JDBC连接是一种昂贵的资源，所以使用后要及时释放。使用try (resource)来自动释放JDBC连接是一个好方法：</p>
<pre><code>try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    ...
}
</code></pre><h3 id="jdbc查询">JDBC查询</h3>
<p>获取到JDBC连接后，下一步我们就可以查询数据库了。查询数据库分以下几步：</p>
<p>第一步，通过Connection提供的createStatement()方法创建一个Statement对象，用于执行一个查询；</p>
<p>第二步，执行Statement对象提供的executeQuery(&ldquo;SELECT * FROM students&rdquo;)并传入SQL语句，执行查询并获得返回的结果集，使用ResultSet来引用这个结果集；</p>
<p>第三步，反复调用ResultSet的next()方法并读取每一行结果。</p>
<p>完整查询代码如下：</p>
<pre><code>try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD) {
    try (Statement stmt = conn.createStatement()) {
        try (ResultSet rs = stmt.executeQuery(&quot;SELECT id, grade, name, gender FROM students WHERE gender=\'M\'&quot;)) {
            while (rs.next()) {
                long id = rs.getLong(1); // 注意：索引从1开始
                long grade = rs.getLong(2);
                String name = rs.getString(3);
                String gender = rs.getString(4);
            }
        }
    }
}
</code></pre><p>注意要点：
Statment和ResultSet都是需要关闭的资源，因此嵌套使用try (resource)确保及时关闭；</p>
<p>rs.next()用于判断是否有下一行记录，如果有，将自动把当前行移动到下一行（一开始获得ResultSet时当前行不是第一行）；</p>
<p>ResultSet获取列时，索引从1开始而不是0；</p>
<p>必须根据SELECT的列的对应位置来调用getLong(1)，getString(2)这些方法，否则对应位置的数据类型不对，将报错。</p>
<h3 id="sql注入">SQL注入</h3>
<p>使用Statement拼字符串非常容易引发SQL注入的问题，这是因为SQL参数往往是从方法参数传入的。</p>
<p>我们来看一个例子：假设用户登录的验证方法如下：</p>
<pre><code>User login(String name, String pass) {
    ...
    stmt.executeQuery(&quot;SELECT * FROM user WHERE login='&quot; + name + &quot;' AND pass='&quot; + pass + &quot;'&quot;);
    ...
}
</code></pre><p>其中，参数name和pass通常都是Web页面输入后由程序接收到的。</p>
<p>如果用户的输入是程序期待的值，就可以拼出正确的SQL。例如：name = &ldquo;bob&rdquo;，pass = &ldquo;1234&rdquo;：</p>
<pre><code>SELECT * FROM user WHERE login='bob' OR pass=' AND pass=' OR pass=''
</code></pre><p>这个SQL语句执行的时候，根本不用判断口令是否正确，这样一来，登录就形同虚设。</p>
<p>要避免SQL注入攻击，一个办法是针对所有字符串参数进行转义，但是转义很麻烦，而且需要在任何使用SQL的地方增加转义代码。</p>
<p>还有一个办法就是使用PreparedStatement。使用PreparedStatement可以完全避免SQL注入的问题，因为PreparedStatement始终使用?作为占位符，并且把数据连同SQL本身传给数据库，这样可以保证每次传给数据库的SQL语句是相同的，只是占位符的数据不同，还能高效利用数据库本身对查询的缓存。上述登录SQL如果用PreparedStatement可以改写如下：</p>
<pre><code>User login(String name, String pass) {
    ...
    String sql = &quot;SELECT * FROM user WHERE login=? AND pass=?&quot;;
    PreparedStatement ps = conn.prepareStatement(sql);
    ps.setObject(1, name);
    ps.setObject(2, pass);
    ...
}
</code></pre><p>所以，PreparedStatement比Statement更安全，而且更快。</p>
<p>使用Java对数据库进行操作时，必须使用PreparedStatement，严禁任何通过参数拼字符串的代码！</p>
<p>我们把上面使用Statement的代码改为使用PreparedStatement：</p>
<pre><code>try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD) {
    try (PreparedStatement ps = conn.prepareStatement(&quot;SELECT id, grade, name, gender FROM students WHERE gender=? AND grade=?&quot;)) {
        ps.setObject(1, &quot;M&quot;); // 注意：索引从1开始
        ps.setObject(2, 3);
        try (ResultSet rs = ps.executeQuery()) {
            while (rs.next()) {
                long id = rs.getLong(&quot;id&quot;);
                long grade = rs.getLong(&quot;grade&quot;);
                String name = rs.getString(&quot;name&quot;);
                String gender = rs.getString(&quot;gender&quot;);
            }
        }
    }
}
</code></pre><p>使用PreparedStatement和Statement稍有不同，必须首先调用setObject()设置每个占位符?的值，最后获取的仍然是ResultSet对象。</p>
<p>另外注意到从结果集读取列时，使用String类型的列名比索引要易读，而且不易出错。</p>
<p>注意到JDBC查询的返回值总是ResultSet，即使我们写这样的聚合查询SELECT SUM(score) FROM &hellip;，也需要按结果集读取：</p>
<pre><code>ResultSet rs = ...
if (rs.next()) {
    double sum = rs.getDouble(1);
}
</code></pre><h3 id="数据类型">数据类型</h3>
<p>有的童鞋可能注意到了，使用JDBC的时候，我们需要在Java数据类型和SQL数据类型之间进行转换。JDBC在java.sql.Types定义了一组常量来表示如何映射SQL数据类型，但是平时我们使用的类型通常也就以下几种：
| SQL数据类型   | Java数据类型             |
| :&mdash;&mdash;&mdash;&mdash; | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; |
| BIT, BOOL     | boolean                  |
| INTEGER       | int                      |
| BIGINT        | long                     |
| REAL          | float                    |
| FLOAT, DOUBLE | double                   |
| CHAR, VARCHAR | String                   |
| DECIMAL       | BigDecimal               |
| DATE          | java.sql.Date, LocalDate |
| TIME          | java.sql.Time, LocalTime |</p>
<p>注意：只有最新的JDBC驱动才支持LocalDate和LocalTime。</p>
<h3 id="小结-30">小结</h3>
<p>JDBC接口的Connection代表一个JDBC连接；</p>
<p>使用JDBC查询时，总是使用PreparedStatement进行查询而不是Statement；</p>
<p>查询结果总是ResultSet，即使使用聚合查询也不例外。</p>
<hr>
<h2 id="143-jdbc更新">14.3 JDBC更新</h2>
<p>数据库操作总结起来就四个字：增删改查，行话叫CRUD：Create，Retrieve，Update和Delete。</p>
<p>查就是查询，我们已经讲过了，就是使用PreparedStatement进行各种SELECT，然后处理结果集。现在我们来看看如何使用JDBC进行增删改。</p>
<h3 id="插入">插入</h3>
<p>插入操作是INSERT，即插入一条新记录。通过JDBC进行插入，本质上也是用PreparedStatement执行一条SQL语句，不过最后执行的不是executeQuery()，而是executeUpdate()。示例代码如下：</p>
<pre><code>try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (PreparedStatement ps = conn.prepareStatement(
            &quot;INSERT INTO students (id, grade, name, gender) VALUES (?,?,?,?)&quot;)) {
        ps.setObject(1, 999); // 注意：索引从1开始
        ps.setObject(2, 1); // grade
        ps.setObject(3, &quot;Bob&quot;); // name
        ps.setObject(4, &quot;M&quot;); // gender
        int n = ps.executeUpdate(); // 1
    }
}
</code></pre><p>设置参数与查询是一样的，有几个?占位符就必须设置对应的参数。虽然Statement也可以执行插入操作，但我们仍然要严格遵循绝不能手动拼SQL字符串的原则，以避免安全漏洞。</p>
<p>当成功执行executeUpdate()后，返回值是int，表示插入的记录数量。此处总是1，因为只插入了一条记录。</p>
<h3 id="插入并获取主键">插入并获取主键</h3>
<p>如果数据库的表设置了自增主键，那么在执行INSERT语句时，并不需要指定主键，数据库会自动分配主键。对于使用自增主键的程序，有个额外的步骤，就是如何获取插入后的自增主键的值。</p>
<p>要获取自增主键，不能先插入，再查询。因为两条SQL执行期间可能有别的程序也插入了同一个表。获取自增主键的正确写法是在创建PreparedStatement的时候，指定一个RETURN_GENERATED_KEYS标志位，表示JDBC驱动必须返回插入的自增主键。示例代码如下：</p>
<pre><code>try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (PreparedStatement ps = conn.prepareStatement(
            &quot;INSERT INTO students (grade, name, gender) VALUES (?,?,?)&quot;,
            Statement.RETURN_GENERATED_KEYS)) {
        ps.setObject(1, 1); // grade
        ps.setObject(2, &quot;Bob&quot;); // name
        ps.setObject(3, &quot;M&quot;); // gender
        int n = ps.executeUpdate(); // 1
        try (ResultSet rs = ps.getGeneratedKeys()) {
            if (rs.next()) {
                long id = rs.getLong(1); // 注意：索引从1开始
            }
        }
    }
}
</code></pre><p>观察上述代码，有两点注意事项：</p>
<p>一是调用prepareStatement()时，第二个参数必须传入常量Statement.RETURN_GENERATED_KEYS，否则JDBC驱动不会返回自增主键；</p>
<p>二是执行executeUpdate()方法后，必须调用getGeneratedKeys()获取一个ResultSet对象，这个对象包含了数据库自动生成的主键的值，读取该对象的每一行来获取自增主键的值。如果一次插入多条记录，那么这个ResultSet对象就会有多行返回值。如果插入时有多列自增，那么ResultSet对象的每一行都会对应多个自增值（自增列不一定必须是主键）。</p>
<h3 id="更新">更新</h3>
<p>更新操作是UPDATE语句，它可以一次更新若干列的记录。更新操作和插入操作在JDBC代码的层面上实际上没有区别，除了SQL语句不同：</p>
<pre><code>
try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (PreparedStatement ps = conn.prepareStatement(&quot;UPDATE students SET name=? WHERE id=?&quot;)) {
        ps.setObject(1, &quot;Bob&quot;); // 注意：索引从1开始
        ps.setObject(2, 999);
        int n = ps.executeUpdate(); // 返回更新的行数
    }
}
</code></pre><p>executeUpdate()返回数据库实际更新的行数。返回结果可能是正数，也可能是0（表示没有任何记录更新）。</p>
<h3 id="删除">删除</h3>
<p>删除操作是DELETE语句，它可以一次删除若干列。和更新一样，除了SQL语句不同外，JDBC代码都是相同的：</p>
<pre><code>try (Connection conn = DriverManager.getConnection(JDBC_URL, JDBC_USER, JDBC_PASSWORD)) {
    try (PreparedStatement ps = conn.prepareStatement(&quot;DELETE FROM students WHERE id=?&quot;)) {
        ps.setObject(1, 999); // 注意：索引从1开始
        int n = ps.executeUpdate(); // 删除的行数
    }
}
</code></pre><h3 id="小结-31">小结</h3>
<p>使用JDBC执行INSERT、UPDATE和DELETE都可视为更新操作；</p>
<p>更新操作使用PreparedStatement的executeUpdate()进行，返回受影响的行数。</p>
<hr>
<h2 id="144-jdbc事务">14.4 JDBC事务</h2>
<p>数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的synchronized同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性：</p>
<ul>
<li>Atomicity：原子性</li>
<li>Consistency：一致性</li>
<li>Isolation：隔离性</li>
<li>Durability：持久性</li>
</ul>
<p>数据库事务可以并发执行，而数据库系统从效率考虑，对事务定义了不同的隔离级别。SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：
| Isolation Level  | 脏读（Dirty Read） | 不可重复读（Non Repeatable Read） | 幻读（Phantom Read） |
| :&mdash;&mdash;&mdash;&mdash;&mdash; | :&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- |
| Read Uncommitted | Yes                | Yes                               | Yes                  |
| Read Committed   | -                  | Yes                               | Yes                  |
| Repeatable Read  | -                  | -                                 | Yes                  |
| Serializable     | -                  | -                                 | -                    |
对应用程序来说，数据库事务非常重要，很多运行着关键任务的应用程序，都必须依赖数据库事务保证程序的结果正常。</p>
<p>举个例子：假设小明准备给小红支付100，两人在数据库中的记录主键分别是123和456，那么用两条SQL语句操作如下：</p>
<pre><code>UPDATE accounts SET balance = balance - 100 WHERE id=123 AND balance &gt;= 100;
UPDATE accounts SET balance = balance + 100 WHERE id=456;
</code></pre><p>这两条语句必须以事务方式执行才能保证业务的正确性，因为一旦第一条SQL执行成功而第二条SQL失败的话，系统的钱就会凭空减少100，而有了事务，要么这笔转账成功，要么转账失败，双方账户的钱都不变。</p>
<p>这里我们不讨论详细的SQL事务，如果对SQL事务不熟悉，请参考SQL事务。</p>
<p>要在JDBC中执行事务，本质上就是如何把多条SQL包裹在一个数据库事务中执行。我们来看JDBC的事务代码：</p>
<pre><code>Connection conn = openConnection();
try {
    // 关闭自动提交:
    conn.setAutoCommit(false);
    // 执行多条SQL语句:
    insert(); update(); delete();
    // 提交事务:
    conn.commit();
} catch (SQLException e) {
    // 回滚事务:
    conn.rollback();
} finally {
    conn.setAutoCommit(true);
    conn.close();
}
</code></pre><p>其中，开启事务的关键代码是conn.setAutoCommit(false)，表示关闭自动提交。提交事务的代码在执行完指定的若干条SQL语句后，调用conn.commit()。要注意事务不是总能成功，如果事务提交失败，会抛出SQL异常（也可能在执行SQL语句的时候就抛出了），此时我们必须捕获并调用conn.rollback()回滚事务。最后，在finally中通过conn.setAutoCommit(true)把Connection对象的状态恢复到初始值。</p>
<p>实际上，默认情况下，我们获取到Connection连接后，总是处于“自动提交”模式，也就是每执行一条SQL都是作为事务自动执行的，这也是为什么前面几节我们的更新操作总能成功的原因：因为默认有这种“隐式事务”。只要关闭了Connection的autoCommit，那么就可以在一个事务中执行多条语句，事务以commit()方法结束。</p>
<p>如果要设定事务的隔离级别，可以使用如下代码：</p>
<pre><code>// 设定隔离级别为READ COMMITTED:
conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);
</code></pre><p>如果没有调用上述方法，那么会使用数据库的默认隔离级别。MySQL的默认隔离级别是REPEATABLE READ。</p>
<h3 id="小结-32">小结</h3>
<p>数据库事务（Transaction）具有ACID特性：</p>
<ul>
<li>Atomicity：原子性</li>
<li>Consistency：一致性</li>
<li>Isolation：隔离性</li>
<li>Durability：持久性</li>
</ul>
<p>JDBC提供了事务的支持，使用Connection可以开启、提交或回滚事务。</p>
<hr>
<h2 id="145-jdbc-batch">14.5 JDBC Batch</h2>
<p>使用JDBC操作数据库的时候，经常会执行一些批量操作。</p>
<p>例如，一次性给会员增加可用优惠券若干，我们可以执行以下SQL代码：</p>
<pre><code>INSERT INTO coupons (user_id, type, expires) VALUES (123, 'DISCOUNT', '2030-12-31');
INSERT INTO coupons (user_id, type, expires) VALUES (234, 'DISCOUNT', '2030-12-31');
INSERT INTO coupons (user_id, type, expires) VALUES (345, 'DISCOUNT', '2030-12-31');
INSERT INTO coupons (user_id, type, expires) VALUES (456, 'DISCOUNT', '2030-12-31');
...
</code></pre><p>实际上执行JDBC时，因为只有占位符参数不同，所以SQL实际上是一样的：</p>
<pre><code>for (var params : paramsList) {
    PreparedStatement ps = conn.preparedStatement(&quot;INSERT INTO coupons (user_id, type, expires) VALUES (?,?,?)&quot;);
    ps.setLong(params.get(0));
    ps.setString(params.get(1));
    ps.setString(params.get(2));
    ps.executeUpdate();
}
</code></pre><p>类似的还有，给每个员工薪水增加10%～30%：</p>
<pre><code>UPDATE employees SET salary = salary * ? WHERE id = ?
</code></pre><p>通过一个循环来执行每个PreparedStatement虽然可行，但是性能很低。SQL数据库对SQL语句相同，但只有参数不同的若干语句可以作为batch执行，即批量执行，这种操作有特别优化，速度远远快于循环执行每个SQL。</p>
<p>在JDBC代码中，我们可以利用SQL数据库的这一特性，把同一个SQL但参数不同的若干次操作合并为一个batch执行。我们以批量插入为例，示例代码如下：</p>
<pre><code>try (PreparedStatement ps = conn.prepareStatement(&quot;INSERT INTO students (name, gender, grade, score) VALUES (?, ?, ?, ?)&quot;)) {
    // 对同一个PreparedStatement反复设置参数并调用addBatch():
    for (String name : names) {
        ps.setString(1, name);
        ps.setBoolean(2, gender);
        ps.setInt(3, grade);
        ps.setInt(4, score);
        ps.addBatch(); // 添加到batch
    }
    // 执行batch:
    int[] ns = ps.executeBatch();
    for (int n : ns) {
        System.out.println(n + &quot; inserted.&quot;); // batch中每个SQL执行的结果数量
    }
}
</code></pre><p>执行batch和执行一个SQL不同点在于，需要对同一个PreparedStatement反复设置参数并调用addBatch()，这样就相当于给一个SQL加上了多组参数，相当于变成了“多行”SQL。</p>
<p>第二个不同点是调用的不是executeUpdate()，而是executeBatch()，因为我们设置了多组参数，相应地，返回结果也是多个int值，因此返回类型是int[]，循环int[]数组即可获取每组参数执行后影响的结果数量。</p>
<h3 id="小结-33">小结</h3>
<p>使用JDBC的batch操作会大大提高执行效率，对内容相同，参数不同的SQL，要优先考虑batch操作。</p>
<hr>
<h2 id="146-jdbc连接池">14.6 JDBC连接池</h2>
<p>我们在讲多线程的时候说过，创建线程是一个昂贵的操作，如果有大量的小任务需要执行，并且频繁地创建和销毁线程，实际上会消耗大量的系统资源，往往创建和消耗线程所耗费的时间比执行任务的时间还长，所以，为了提高效率，可以用线程池。</p>
<p>类似的，在执行JDBC的增删改查的操作时，如果每一次操作都来一次打开连接，操作，关闭连接，那么创建和销毁JDBC连接的开销就太大了。为了避免频繁地创建和销毁JDBC连接，我们可以通过连接池（Connection Pool）复用已经创建好的连接。</p>
<p>JDBC连接池有一个标准的接口javax.sql.DataSource，注意这个类位于Java标准库中，但仅仅是接口。要使用JDBC连接池，我们必须选择一个JDBC连接池的实现。常用的JDBC连接池有：</p>
<ul>
<li>HikariCP</li>
<li>C3P0</li>
<li>BoneCP</li>
<li>Druid</li>
</ul>
<p>目前使用最广泛的是HikariCP。我们以HikariCP为例，要使用JDBC连接池，先添加HikariCP的依赖如下：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;
    &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;
    &lt;version&gt;2.7.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>紧接着，我们需要创建一个DataSource实例，这个实例就是连接池：</p>
<pre><code>HikariConfig config = new HikariConfig();
config.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/test&quot;);
config.setUsername(&quot;root&quot;);
config.setPassword(&quot;password&quot;);
config.addDataSourceProperty(&quot;connectionTimeout&quot;, &quot;1000&quot;); // 连接超时：1秒
config.addDataSourceProperty(&quot;idleTimeout&quot;, &quot;60000&quot;); // 空闲超时：60秒
config.addDataSourceProperty(&quot;maximumPoolSize&quot;, &quot;10&quot;); // 最大连接数：10
DataSource ds = new HikariDataSource(config);
</code></pre><p>注意创建DataSource也是一个非常昂贵的操作，所以通常DataSource实例总是作为一个全局变量存储，并贯穿整个应用程序的生命周期。</p>
<p>有了连接池以后，我们如何使用它呢？和前面的代码类似，只是获取Connection时，把DriverManage.getConnection()改为ds.getConnection()：</p>
<pre><code>try (Connection conn = ds.getConnection()) { // 在此获取连接
    ...
} // 在此“关闭”连接
</code></pre><p>通过连接池获取连接时，并不需要指定JDBC的相关URL、用户名、口令等信息，因为这些信息已经存储在连接池内部了（创建HikariDataSource时传入的HikariConfig持有这些信息）。一开始，连接池内部并没有连接，所以，第一次调用ds.getConnection()，会迫使连接池内部先创建一个Connection，再返回给客户端使用。当我们调用conn.close()方法时（在try(resource){&hellip;}结束处），不是真正“关闭”连接，而是释放到连接池中，以便下次获取连接时能直接返回。</p>
<p>因此，连接池内部维护了若干个Connection实例，如果调用ds.getConnection()，就选择一个空闲连接，并标记它为“正在使用”然后返回，如果对Connection调用close()，那么就把连接再次标记为“空闲”从而等待下次调用。这样一来，我们就通过连接池维护了少量连接，但可以频繁地执行大量的SQL语句。</p>
<p>通常连接池提供了大量的参数可以配置，例如，维护的最小、最大活动连接数，指定一个连接在空闲一段时间后自动关闭等，需要根据应用程序的负载合理地配置这些参数。此外，大多数连接池都提供了详细的实时状态以便进行监控。</p>
<h3 id="小结-34">小结</h3>
<p>数据库连接池是一种复用Connection的组件，它可以避免反复创建新连接，提高JDBC代码的运行效率；</p>
<p>可以配置连接池的详细参数并监控连接池。</p>
<hr>
<h1 id="第15章-xml与json">第15章 XML与JSON</h1>
<p>XML和JSON是两种经常在网络使用的数据表示格式，本章我们介绍如何使用Java读写XML和JSON。</p>
<h2 id="151-xml简介">15.1 XML简介</h2>
<p>XML是可扩展标记语言（eXtensible Markup Language）的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p>
<p>例如，一个描述书籍的XML文档可能如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE note SYSTEM &quot;book.dtd&quot;&gt;
&lt;book id=&quot;1&quot;&gt;
    &lt;name&gt;Java核心技术&lt;/name&gt;
    &lt;author&gt;Cay s. Hosrstmann&lt;/author&gt;
    &lt;isbn lang=&quot;CN&quot;&gt;1234567&lt;/isbn&gt;
    &lt;tags&gt;
        &lt;tag&gt;Java&lt;/tag&gt;
        &lt;tag&gt;NetWork&lt;/tag&gt;
    &lt;/tags&gt;
    &lt;pubDate/&gt;
&lt;/book&gt;
</code></pre><p>XML有几个特点：一是纯文本，默认使用UTF-8编码，二是可嵌套，适合表示结构化数据。如果把XML内容存为文件，那么它就是一个XML文件，例如book.xml。此外，XML内容经常通过网络作为消息传输。</p>
<h3 id="xml的结构">XML的结构</h3>
<p>XML有固定的结构，首行必定是<!-- raw HTML omitted -->，可以加上可选的编码。紧接着，如果以类似<!-- raw HTML omitted -->声明的是文档定义类型（DTD：Document Type Definition），DTD是可选的。接下来是XML的文档内容，一个XML文档有且仅有一个根元素，根元素可以包含任意个子元素，元素可以包含属性，例如，<!-- raw HTML omitted -->1234567<!-- raw HTML omitted -->包含一个属性lang=&quot;CN&rdquo;，且元素必须正确嵌套。如果是空元素，可以用<!-- raw HTML omitted -->表示。</p>
<p>由于使用了&lt;、&gt;以及引号等标识符，如果内容出现了特殊符号，需要使用&amp;???;表示转义。例如，Java<!-- raw HTML omitted -->必须写成：</p>
<pre><code>&lt;name&gt;Java&amp;lt;tm&amp;gt;&lt;/name&gt;
</code></pre><p>常见的特殊字符如下：
| 字符 | 表示    |
| :&mdash; | :&mdash;&mdash; |
| &lt;    | &amp;lt;   |
| &gt;    | &amp;gt;   |
| &amp;    | &amp;amp;  |
| &quot;    | &amp;quot; |
| '    | &amp;apos; |
格式正确的XML（Well Formed）是指XML的格式是正确的，可以被解析器正常读取。而合法的XML是指，不但XML格式正确，而且它的数据结构可以被DTD或者XSD验证。</p>
<p>DTD文档可以指定一系列规则，例如：</p>
<ul>
<li>根元素必须是book</li>
<li>book元素必须包含name，author等指定元素</li>
<li>isbn元素必须包含属性lang</li>
<li>&hellip;</li>
</ul>
<p>如何验证XML文件的正确性呢？最简单的方式是通过浏览器验证。可以直接把XML文件拖拽到浏览器窗口，如果格式错误，浏览器会报错。</p>
<p>和结构类似的HTML不同，浏览器对HTML有一定的“容错性”，缺少关闭标签也可以被解析，但XML要求严格的格式，任何没有正确嵌套的标签都会导致错误。</p>
<p>XML是一个技术体系，除了我们经常用到的XML文档本身外，XML还支持：</p>
<ul>
<li>DTD和XSD：验证XML结构和数据是否有效；</li>
<li>Namespace：XML节点和属性的名字空间；</li>
<li>XSLT：把XML转化为另一种文本；</li>
<li>XPath：一种XML节点查询语言；</li>
<li>&hellip;</li>
</ul>
<p>实际上，XML的这些相关技术实现起来非常复杂，在实际应用中很少用到，通常了解一下就可以了。</p>
<h3 id="小结-35">小结</h3>
<p>XML使用嵌套结构的数据表示方式，支持格式验证；</p>
<p>XML常用于配置文件、网络消息传输等。</p>
<hr>
<h2 id="152-使用dom">15.2 使用DOM</h2>
<p>因为XML是一种树形结构的文档，它有两种标准的解析API：</p>
<ul>
<li>DOM：一次性读取XML，并在内存中表示为树形结构；</li>
<li>SAX：以流的形式读取XML，使用事件回调。</li>
</ul>
<p>我们先来看如何使用DOM来读取XML。</p>
<p>DOM是Document Object Model的缩写，DOM模型就是把XML结构作为一个树形结构处理，从根节点开始，每个节点都可以包含任意个子节点。</p>
<p>我们以下面的XML为例：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&gt;
&lt;book id=&quot;1&quot;&gt;
    &lt;name&gt;Java核心技术&lt;/name&gt;
    &lt;author&gt;Cay S Horstmann&lt;/author&gt;
    &lt;ison lang=&quot;CN&quot;&gt;1234567&lt;/isbn&gt;
    &lt;tags&gt;
        &lt;tag&gt;Java&lt;/tag&gt;
        &lt;tag&gt;Network&lt;/tag&gt;
    &lt;/tags&gt;
    &lt;pubDate/&gt;
&lt;/book&gt;
</code></pre><p>如果解析为DOM结构，它大概长这样：</p>
<pre><code>                      ┌─────────┐
                      │document │
                      └─────────┘
                           │
                           ▼
                      ┌─────────┐
                      │  book   │
                      └─────────┘
                           │
     ┌──────────┬──────────┼──────────┬──────────┐
     ▼          ▼          ▼          ▼          ▼
┌─────────┐┌─────────┐┌─────────┐┌─────────┐┌─────────┐
│  name   ││ author  ││  isbn   ││  tags   ││ pubDate │
└─────────┘└─────────┘└─────────┘└─────────┘└─────────┘
                                      │
                                 ┌────┴────┐
                                 ▼         ▼
                             ┌───────┐ ┌───────┐
                             │  tag  │ │  tag  │
                             └───────┘ └───────┘
</code></pre><p>注意到最顶层的document代表XML文档，它是真正的“根”，而<!-- raw HTML omitted -->虽然是根元素，但它是document的一个子节点。</p>
<p>Java提供了DOM API来解析XML，它使用下面的对象来表示XML的内容：</p>
<ul>
<li>Document：代表整个XML文档；</li>
<li>Element：代表一个XML元素；</li>
<li>Attribute：代表一个元素的某个属性。
使用DOM API解析一个XML文档的代码如下：</li>
</ul>
<pre><code>InputStream input = Main.class.getResourceAsStream(&quot;/book.xml&quot;);
DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
DocumentBuilder db = dbf.newDocumentBuilder();
Document doc = db.parse(input);
</code></pre><p>DocumentBuilder.parse()用于解析一个XML，它可以接收InputStream，File或者URL，如果解析无误，我们将获得一个Document对象，这个对象代表了整个XML文档的树形结构，需要遍历以便读取指定元素的值：</p>
<pre><code>void printNode(Node n, int indent) {
    for (int i = 0; i &lt; indent; i++) {
        System.out.print(' ');
    }
    switch (n.getNodeType()) {
    case Node.DOCUMENT_NODE: // Document节点
        System.out.println(&quot;Document: &quot; + n.getNodeName());
        break;
    case Node.ELEMENT_NODE: // 元素节点
        System.out.println(&quot;Element: &quot; + n.getNodeName());
        break;
    case Node.TEXT_NODE: // 文本
        System.out.println(&quot;Text: &quot; + n.getNodeName() + &quot; = &quot; + n.getNodeValue());
        break;
    case Node.ATTRIBUTE_NODE: // 属性
        System.out.println(&quot;Attr: &quot; + n.getNodeName() + &quot; = &quot; + n.getNodeValue());
        break;
    default: // 其他
        System.out.println(&quot;NodeType: &quot; + n.getNodeType() + &quot;, NodeName: &quot; + n.getNodeName());
    }
    for (Node child = n.getFirstChild(); child != null; child = child.getNextSibling()) {
        printNode(child, indent + 1);
    }
}
</code></pre><p>解析结构如下：</p>
<pre><code>Document: #document
 Element: book
  Text: #text = 
    
  Element: name
   Text: #text = Java核心技术
  Text: #text = 
    
  Element: author
   Text: #text = Cay S. Horstmann
  Text: #text = 
  ...
</code></pre><p>对于DOM API解析出来的结构，我们从根节点Document出发，可以遍历所有子节点，获取所有元素、属性、文本数据，还可以包括注释，这些节点被统称为Node，每个Node都有自己的Type，根据Type来区分一个Node到底是元素，还是属性，还是文本，等等。</p>
<p>使用DOM API时，如果要读取某个元素的文本，需要访问它的Text类型的子节点，所以使用起来还是比较繁琐的。</p>
<h3 id="小结-36">小结</h3>
<p>Java提供的DOM API可以将XML解析为DOM结构，以Document对象表示；</p>
<p>DOM可在内存中完整表示XML数据结构；</p>
<p>DOM解析速度慢，内存占用大。</p>
<hr>
<h2 id="153-使用sax">15.3 使用SAX</h2>
<p>使用DOM解析XML的优点是用起来省事，但它的主要缺点是内存占用太大。</p>
<p>另一种解析XML的方式是SAX。SAX是Simple API for XML的缩写，它是一种基于流的解析方式，边读取XML边解析，并以事件回调的方式让调用者获取数据。因为是一边读一边解析，所以无论XML有多大，占用的内存都很小。</p>
<p>SAX解析会触发一系列事件：</p>
<ul>
<li>startDocument：开始读取XML文档；</li>
<li>startElement：读取到了一个元素，例如<!-- raw HTML omitted -->；</li>
<li>characters：读取到了字符；</li>
<li>endElement：读取到了一个结束的元素，例如<!-- raw HTML omitted -->；</li>
<li>endDocument：读取XML文档结束。</li>
</ul>
<p>如果我们用SAX API解析XML，Java代码如下：</p>
<pre><code>InputStream input = Main.class.getResourceAsStream(&quot;/book.xml&quot;);
SAXParsetFactory spf = SAXParserFactory.newInstance();
SAXParse saxParser = spf.newSAXParser();
saxParser.parse(input, new MyHandler());
</code></pre><p>关键代码SAXParser.parse()除了需要传入一个InputStream外，还需要传入一个回调对象，这个对象要继承自DefaultHandler：</p>
<pre><code>class MyHandler extends DefaultHandler {
    public void startDocument() throws SAXException {
        print(&quot;start document&quot;);
    }

    public void endDocument() throws SAXException {
        print(&quot;end document&quot;);
    }

    public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        print(&quot;start element:&quot;, localName, qName);
    }

    public void endElement(String uri, String localName, String qName) throws SAXException {
        print(&quot;end element:&quot;, localName, qName);
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        print(&quot;characters:&quot;, new String(ch, start, length));
    }

    public void error(SAXParseException e) throws SAXException {
        print(&quot;error:&quot;, e);
    }

    void print(Object... objs) {
        for (Object obj : objs) {
            System.out.print(obj);
            System.out.print(&quot; &quot;);
        }
        System.out.println();
    }
}
</code></pre><p>运行SAX解析代码，可以打印出下面的结果：</p>
<pre><code>start document
start element:  book
characters:
     
start element:  name
characters: Java核心技术
end element:  name
characters:
     
start element:  author
...
</code></pre><p>如果要读取<!-- raw HTML omitted -->节点的文本，我们就必须在解析过程中根据startElement()和endElement()定位当前正在读取的节点，可以使用栈结构保存，每遇到一个startElement()入栈，每遇到一个endElement()出栈，这样，读到characters()时我们才知道当前读取的文本是哪个节点的。可见，使用SAX API仍然比较麻烦。</p>
<h3 id="小结-37">小结</h3>
<p>SAX是一种流式解析XML的API；</p>
<p>SAX通过事件触发，读取速度快，消耗内存少；</p>
<p>调用方必须通过回调方法获得解析过程中的数据。</p>
<hr>
<h2 id="154-使用jackson">15.4 使用Jackson</h2>
<p>前面我们介绍了DOM和SAX两种解析XML的标准接口。但是，无论是DOM还是SAX，使用起来都不直观。</p>
<p>观察XML文档的结构：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;book id=&quot;1&quot;&gt;
    &lt;name&gt;Java核心技术&lt;/name&gt;
    &lt;author&gt;Cay S. Horstmann&lt;/author&gt;
    &lt;isbn lang=&quot;CN&quot;&gt;1234567&lt;/isbn&gt;
    &lt;tags&gt;
        &lt;tag&gt;Java&lt;/tag&gt;
        &lt;tag&gt;Network&lt;/tag&gt;
    &lt;/tags&gt;
    &lt;pubDate/&gt;
&lt;/book&gt;
</code></pre><p>我们发现，它完全可以对应到一个定义好的JavaBean中：</p>
<pre><code>public class Book {
    public long id;
    public String name;
    public String author;
    public String isbn;
    public List&lt;String&gt; tags;
    public String pubDate;
}
</code></pre><p>如果能直接从XML文档解析成一个JavaBean，那比DOM或者SAX不知道容易到哪里去了。</p>
<p>幸运的是，一个名叫Jackson的开源的第三方库可以轻松做到XML到JavaBean的转换。我们要使用Jackson，先添加两个Maven的依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;
    &lt;version&gt;2.10.1&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.codehaus.woodstox&lt;/groupId&gt;
    &lt;artifactId&gt;woodstox-core-asl&lt;/artifactId&gt;
    &lt;version&gt;4.4.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>然后，定义好JavaBean，就可以用下面几行代码解析：</p>
<pre><code>InputStream input = Main.class.getResourceAsStream(&quot;/book.xml&quot;);
JacksonXmlModule module = new JacksonXmlModule();
XmlMapper mapper = new XmlMapper(module);
Book book = mapper.readValue(input, Book.class);
System.out.println(book.id);
System.out.println(book.name);
System.out.println(book.author);
System.out.println(book.isbn);
System.out.println(book.tags);
System.out.println(book.pubDate);
</code></pre><p>注意到XmlMapper就是我们需要创建的核心对象，可以用readValue(InputStream, Class)直接读取XML并返回一个JavaBean。运行上述代码，就可以直接从Book对象中拿到数据：</p>
<pre><code>注意到XmlMapper就是我们需要创建的核心对象，可以用readValue(InputStream, Class)直接读取XML并返回一个JavaBean。运行上述代码，就可以直接从Book对象中拿到数据：
</code></pre><h3 id="小结-38">小结</h3>
<p>使用Jackson解析XML，可以直接把XML解析为JavaBean，十分方便。</p>
<hr>
<h2 id="155-使用json">15.5 使用JSON</h2>
<p>前面我们讨论了XML这种数据格式。XML的特点是功能全面，但标签繁琐，格式复杂。在Web上使用XML现在越来越少，取而代之的是JSON这种数据结构。</p>
<p>JSON是JavaScript Object Notation的缩写，它去除了所有JavaScript执行代码，只保留JavaScript的对象格式。一个典型的JSON如下：</p>
<pre><code>{
    &quot;id&quot;: 1,
    &quot;name&quot;: &quot;Java核心技术&quot;,
    &quot;author&quot;: {
        &quot;firstName&quot;: &quot;Abc&quot;,
        &quot;lastName&quot;: &quot;Xyz&quot;
    },
    &quot;isbn&quot;: &quot;1234567&quot;,
    &quot;tags&quot;: [&quot;Java&quot;, &quot;Network&quot;]
}
</code></pre><p>JSON作为数据传输的格式，有几个显著的优点：</p>
<ul>
<li>JSON只允许使用UTF-8编码，不存在编码问题；</li>
<li>JSON只允许使用双引号作为key，特殊字符用\转义，格式简单；</li>
<li>浏览器内置JSON支持，如果把数据用JSON发送给浏览器，可以用JavaScript直接处理。</li>
</ul>
<p>因此，JSON适合表示层次结构，因为它格式简单，仅支持以下几种数据类型：</p>
<ul>
<li>键值对：{&ldquo;key&rdquo;: value}</li>
<li>数组：[1, 2, 3]</li>
<li>字符串：&ldquo;abc&rdquo;</li>
<li>数值（整数和浮点数）：12.34</li>
<li>布尔值：true或false</li>
<li>空值：null</li>
</ul>
<p>浏览器直接支持使用JavaScript对JSON进行读写：</p>
<pre><code>// JSON string to JavaScript object:
jsObj = JSON.parse(jsonStr);

// JavaScript object to JSON string:
jsonStr = JSON.stringify(jsObj);
</code></pre><p>所以，开发Web应用的时候，使用JSON作为数据传输，在浏览器端非常方便。因为JSON天生适合JavaScript处理，所以，绝大多数REST API都选择JSON作为数据传输格式。</p>
<p>现在问题来了：使用Java如何对JSON进行读写？</p>
<p>在Java中，针对JSON也有标准的JSR 353 API，但是我们在前面讲XML的时候发现，如果能直接在XML和JavaBean之间互相转换是最好的。类似的，如果能直接在JSON和JavaBean之间转换，那么用起来就简单多了。</p>
<p>常用的用于解析JSON的第三方库有：</p>
<ul>
<li>Jackson</li>
<li>Gson</li>
<li>Fastjson</li>
<li>&hellip;</li>
</ul>
<p>注意到上一节提到的那个可以解析XML的浓眉大眼的Jackson也可以解析JSON！因此我们只需要引入以下Maven依赖：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.10.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>就可以使用下面的代码解析一个JSON文件：</p>
<pre><code>InputStream input = Main.class.getResourceAsStream(&quot;/book.json&quot;);
ObjectMapper mapper = new ObjectMapper();
// 反序列化时忽略不存在的JavaBean属性:
mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
Book book = mapper.readValue(input, Book.class);
</code></pre><p>核心代码是创建一个ObjectMapper对象。关闭DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES功能使得解析时如果JavaBean不存在该属性时解析不会报错。</p>
<p>把JSON解析为JavaBean的过程称为反序列化。如果把JavaBean变为JSON，那就是序列化。要实现JavaBean到JSON的序列化，只需要一行代码：</p>
<pre><code>String json = mapper.writeValueAsString(book);
</code></pre><p>要把JSON的某些值解析为特定的Java对象，例如LocalDate，也是完全可以的。例如：</p>
<pre><code>{
    &quot;name&quot;: &quot;Java核心技术&quot;,
    &quot;pubDate&quot;: &quot;2016-09-01&quot;
}
</code></pre><p>要解析为：</p>
<pre><code>public class Book {
    public String name;
    public LocalDate pubDate;
}
</code></pre><p>只需要引入标准的JSR 310关于JavaTime的数据格式定义：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-datatype-jsr310&lt;/artifactId&gt;
    &lt;version&gt;2.10.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>然后，在创建ObjectMapper时，注册一个新的JavaTimeModule：</p>
<pre><code>ObjectMapper mapper = new ObjectMapper().registerModule(new JavaTimeModule());
</code></pre><p>有些时候，内置的解析规则和扩展的解析规则如果都不满足我们的需求，还可以自定义解析。
举个例子，假设Book类的isbn是一个BigInteger：</p>
<pre><code>public class Book {
	public String name;
	public BigInteger isbn;
}
</code></pre><p>但JSON数据并不是标准的整形格式：</p>
<pre><code>{
    &quot;name&quot;: &quot;Java核心技术&quot;,
    &quot;isbn&quot;: &quot;978-7-111-54742-6&quot;
}
</code></pre><p>直接解析，肯定报错。这时，我们需要自定义一个IsbnDeserializer，用于解析含有非数字的字符串：</p>
<pre><code>public class IsbnDeserializer extends JsonDeserializer&lt;BigInteger&gt; {
    public BigInteger deserialize(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException {
        // 读取原始的JSON字符串内容:
        String s = p.getValueAsString();
        if (s != null) {
            try {
                return new BigInteger(s.replace(&quot;-&quot;, &quot;&quot;));
            } catch (NumberFormatException e) {
                throw new JsonParseException(p, s, e);
            }
        }
        return null;
    }
}
</code></pre><p>然后，在Book类中使用注解标注：</p>
<pre><code>public class Book {
    public String name;
    // 表示反序列化isbn时使用自定义的IsbnDeserializer:
    @JsonDeserialize(using = IsbnDeserializer.class)
    public BigInteger isbn;
}
</code></pre><p>类似的，自定义序列化时我们需要自定义一个IsbnSerializer，然后在Book类中标注@JsonSerialize(using = &hellip;)即可。</p>
<h3 id="小结-39">小结</h3>
<p>JSON是轻量级的数据表示方式，常用于Web应用；</p>
<p>Jackson可以实现JavaBean和JSON之间的转换；</p>
<p>可以通过Module扩展Jackson能处理的数据类型；</p>
<p>可以自定义JsonSerializer和JsonDeserializer来定制序列化和反序列化。</p>
<hr>
<h1 id="第16章-maven基础">第16章 Maven基础</h1>
<p>Maven是一个Java项目管理和构建工具，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。</p>
<h2 id="161-maven介绍">16.1 Maven介绍</h2>
<p>在了解Maven之前，我们先来看看一个Java项目需要的东西。首先，我们需要确定引入哪些依赖包。例如，如果我们需要用到commons logging，我们就必须把commons logging的jar包放入classpath。如果我们还需要log4j，就需要把log4j相关的jar包都放到classpath中。这些就是依赖包的管理。</p>
<p>其次，我们要确定项目的目录结构。例如，src目录存放Java源码，resources目录存放配置文件，bin目录存放编译生成的.class文件。</p>
<p>此外，我们还需要配置环境，例如JDK的版本，编译打包的流程，当前代码的版本号。</p>
<p>最后，除了使用Eclipse这样的IDE进行编译外，我们还必须能通过命令行工具进行编译，才能够让项目在一个独立的服务器上编译、测试、部署。</p>
<p>这些工作难度不大，但是非常琐碎且耗时。如果每一个项目都自己搞一套配置，肯定会一团糟。我们需要的是一个标准化的Java项目管理和构建工具。</p>
<p>Maven就是是专门为Java项目打造的管理和构建工具，它的主要功能有：</p>
<ul>
<li>提供了一套标准化的项目结构；</li>
<li>提供了一套标准化的构建流程（编译，测试，打包，发布……）；</li>
<li>提供了一套依赖管理机制。</li>
</ul>
<h3 id="maven项目结构">Maven项目结构</h3>
<p>一个使用Maven管理的普通的Java项目，它的目录结构默认如下：</p>
<pre><code>a-maven-project
├── pom.xml
├── src
│   ├── main
│   │   ├── java
│   │   └── resources
│   └── test
│       ├── java
│       └── resources
└── target
</code></pre><p>项目的根目录a-maven-project是项目名，它有一个项目描述文件pom.xml，存放Java源码的目录是src/main/java，存放资源文件的目录是src/main/resources，存放测试源码的目录是src/test/java，存放测试资源的目录是src/test/resources，最后，所有编译、打包生成的文件都放在target目录里。这些就是一个Maven项目的标准目录结构。</p>
<p>所有的目录结构都是约定好的标准结构，我们千万不要随意修改目录结构。使用标准结构不需要做任何配置，Maven就可以正常使用。</p>
<p>我们再来看最关键的一个项目描述文件pom.xml，它的内容长得像下面：</p>
<pre><code>&lt;project ...&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
	&lt;artifactId&gt;hello&lt;/artifactId&gt;
	&lt;version&gt;1.0&lt;/version&gt;
	&lt;packaging&gt;jar&lt;/packaging&gt;
	&lt;properties&gt;
        ...
	&lt;/properties&gt;
	&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;commons-logging&lt;/groupId&gt;
            &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
            &lt;version&gt;1.2&lt;/version&gt;
        &lt;/dependency&gt;
	&lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>其中，groupId类似于Java的包名，通常是公司或组织名称，artifactId类似于Java的类名，通常是项目名称，再加上version，一个Maven工程就是由groupId，artifactId和version作为唯一标识。我们在引用其他第三方库的时候，也是通过这3个变量确定。例如，依赖commons-logging：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;commons-logging&lt;/groupId&gt;
    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>使用<!-- raw HTML omitted -->声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</p>
<h3 id="安装maven">安装Maven</h3>
<p>要安装Maven，可以从Maven官网下载最新的Maven 3.6.x，然后在本地解压，设置几个环境变量：</p>
<pre><code>M2_HOME=/path/to/maven-3.6.x
PATH=$PATH:$M2_HOME/bin
</code></pre><p>Windows可以把%M2_HOME%\bin添加到系统Path变量中。</p>
<p>然后，打开命令行窗口，输入mvn -version，应该看到Maven的版本信息：</p>
<pre><code>┌────────────────────────────────────────────────────────┐
│Command Prompt                                    - □ x │
├────────────────────────────────────────────────────────┤
│Microsoft Windows [Version 10.0.0]                      │
│(c) 2015 Microsoft Corporation. All rights reserved.    │
│                                                        │
│C:\&gt; mvn -version                                       │
│Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918...) │
│Maven home: C:\Users\liaoxuefeng\maven                  │
│Java version: ...                                       │
│...                                                     │
│C:\&gt; _                                                  │
│                                                        │
│                                                        │
└────────────────────────────────────────────────────────┘
</code></pre><p>如果提示命令未找到，说明系统PATH路径有误，需要修复后再运行。</p>
<h3 id="小结-40">小结</h3>
<p>Maven是一个Java项目的管理和构建工具：</p>
<ul>
<li>Maven使用pom.xml定义项目内容，并使用预设的目录结构；</li>
<li>在Maven中声明一个依赖项可以自动下载并导入classpath；</li>
<li>Maven使用groupId，artifactId和version唯一定位一个依赖。</li>
</ul>
<hr>
<h2 id="162-依赖管理">16.2 依赖管理</h2>
<p>如果我们的项目依赖第三方的jar包，例如commons logging，那么问题来了：commons logging发布的jar包在哪下载？</p>
<p>如果我们还希望依赖log4j，那么使用log4j需要哪些jar包？</p>
<p>类似的依赖还包括：JUnit，JavaMail，MySQL驱动等等，一个可行的方法是通过搜索引擎搜索到项目的官网，然后手动下载zip包，解压，放入classpath。但是，这个过程非常繁琐。</p>
<p>Maven解决了依赖管理问题。例如，我们的项目依赖abc这个jar包，而abc又依赖xyz这个jar包：</p>
<pre><code>┌──────────────┐
│Sample Project│
└──────────────┘
        │
        ▼
┌──────────────┐
│     abc      │
└──────────────┘
        │
        ▼
┌──────────────┐
│     xyz      │
└──────────────┘
</code></pre><p>当我们声明了abc的依赖时，Maven自动把abc和xyz都加入了我们的项目依赖，不需要我们自己去研究abc是否需要依赖xyz。</p>
<p>因此，Maven的第一个作用就是解决依赖管理。我们声明了自己的项目需要abc，Maven会自动导入abc的jar包，再判断出abc需要xyz，又会自动导入xyz的jar包，这样，最终我们的项目会依赖abc和xyz两个jar包。</p>
<p>我们来看一个复杂依赖示例：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;version&gt;1.4.2.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre><p>当我们声明一个spring-boot-starter-web依赖时，Maven会自动解析并判断最终需要大概二三十个其他依赖：</p>
<pre><code>spring-boot-starter-web
  spring-boot-starter
    spring-boot
    sprint-boot-autoconfigure
    spring-boot-starter-logging
      logback-classic
        logback-core
        slf4j-api
      jcl-over-slf4j
        slf4j-api
      jul-to-slf4j
        slf4j-api
      log4j-over-slf4j
        slf4j-api
    spring-core
    snakeyaml
  spring-boot-starter-tomcat
    tomcat-embed-core
    tomcat-embed-el
    tomcat-embed-websocket
      tomcat-embed-core
  jackson-databind
  ...
</code></pre><p>如果我们自己去手动管理这些依赖是非常费时费力的，而且出错的概率很大。</p>
<h3 id="依赖关系">依赖关系</h3>
<p>Maven定义了几种依赖关系，分别是compile、test、runtime和provided：
| scope    | 说明                                          | 示例            |
| :&mdash;&mdash;- | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash; | :&mdash;&mdash;&mdash;&mdash;&ndash; |
| compile  | 编译时需要用到该jar包（默认）                 | commons-logging |
| test     | 编译Test时需要用到该jar包                     | junit           |
| runtime  | 编译时不需要，但运行时需要用到                | mysql           |
| provided | 编译时需要用到，但运行时由JDK或某个服务器提供 | servlet-api     |</p>
<p>其中，默认的compile是最常用的，Maven会把这种类型的依赖直接放入classpath。</p>
<p>test依赖表示仅在测试时使用，正常运行时并不需要。最常用的test依赖就是JUnit：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;
    &lt;version&gt;5.3.2&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>runtime依赖表示编译时不需要，但运行时需要。最典型的runtime依赖是JDBC驱动，例如MySQL驱动：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.48&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>provided依赖表示编译时需要，但运行时不需要。最典型的provided依赖是Servlet API，编译的时候需要，但是运行时，Servlet服务器内置了相关的jar，所以运行期不需要：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;4.0.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre><p>最后一个问题是，Maven如何知道从何处下载所需的依赖？也就是相关的jar包？答案是Maven维护了一个中央仓库（repo1.maven.org），所有第三方库将自身的jar以及相关信息上传至中央仓库，Maven就可以从中央仓库把所需依赖下载到本地。</p>
<p>Maven并不会每次都从中央仓库下载jar包。一个jar包一旦被下载过，就会被Maven自动缓存在本地目录（用户主目录的.m2目录），所以，除了第一次编译时因为下载需要时间会比较慢，后续过程因为有本地缓存，并不会重复下载相同的jar包。</p>
<h3 id="唯一id">唯一ID</h3>
<p>对于某个依赖，Maven只需要3个变量即可唯一确定某个jar包：</p>
<ul>
<li>groupId：属于组织的名称，类似Java的包名；</li>
<li>artifactId：该jar包自身的名称，类似Java的类名；</li>
<li>version：该jar包的版本。</li>
</ul>
<p>通过上述3个变量，即可唯一确定某个jar包。Maven通过对jar包进行PGP签名确保任何一个jar包一经发布就无法修改。修改已发布jar包的唯一方法是发布一个新版本。</p>
<p>因此，某个jar包一旦被Maven下载过，即可永久地安全缓存在本地。</p>
<p>注：只有以-SNAPSHOT结尾的版本号会被Maven视为开发版本，开发版本每次都会重复下载，这种SNAPSHOT版本只能用于内部私有的Maven repo，公开发布的版本不允许出现SNAPSHOT。</p>
<h3 id="maven镜像">Maven镜像</h3>
<p>除了可以从Maven的中央仓库下载外，还可以从Maven的镜像仓库下载。如果访问Maven的中央仓库非常慢，我们可以选择一个速度较快的Maven的镜像仓库。Maven镜像仓库定期从中央仓库同步：</p>
<pre><code>           slow    ┌───────────────────┐
    ┌─────────────&gt;│Maven Central Repo.│
    │              └───────────────────┘
    │                        │
    │                        │sync
    │                        ▼
┌───────┐  fast    ┌───────────────────┐
│ User  │─────────&gt;│Maven Mirror Repo. │
└───────┘          └───────────────────┘
</code></pre><p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入.m2目录，创建一个settings.xml配置文件，内容如下：</p>
<pre><code>&lt;settings&gt;
    &lt;mirrors&gt;
        &lt;mirror&gt;
            &lt;id&gt;aliyun&lt;/id&gt;
            &lt;name&gt;aliyun&lt;/name&gt;
            &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;
            &lt;!-- 国内推荐阿里云的Maven镜像 --&gt;
            &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;
        &lt;/mirror&gt;
    &lt;/mirrors&gt;
&lt;/settings&gt;
</code></pre><p>配置镜像仓库后，Maven的下载速度就会非常快。</p>
<h3 id="搜索第三方组件">搜索第三方组件</h3>
<p>最后一个问题：如果我们要引用一个第三方组件，比如okhttp，如何确切地获得它的groupId、artifactId和version？方法是通过search.maven.org搜索关键字，找到对应的组件后，直接复制：</p>
<!-- raw HTML omitted -->
<h3 id="小结-41">小结</h3>
<p>Maven通过解析依赖关系确定项目所需的jar包，常用的4种scope有：compile（默认），test，runtime和provided；</p>
<p>Maven从中央仓库下载所需的jar包并缓存在本地；</p>
<p>可以通过镜像仓库加速下载。</p>
<hr>
<h2 id="163-构建流程">16.3 构建流程</h2>
<p>Maven不但有标准化的项目结构，而且还有一套标准化的构建流程，可以自动化实现编译，打包，发布，等等。</p>
<h3 id="lifecycle和phase">Lifecycle和Phase</h3>
<p>使用Maven时，我们首先要了解什么是Maven的生命周期（lifecycle）。</p>
<p>Maven的生命周期由一系列阶段（phase）构成，以内置的生命周期default为例，它包含以下phase：</p>
<pre><code>validate
initialize
generate-sources
process-sources
generate-resources
process-resources
compile
process-classes
generate-test-sources
process-test-sources
generate-test-resources
process-test-resources
test-compile
process-test-classes
test
prepare-package
package
pre-integration-test
integration-test
post-integration-test
verify
install
deploy
</code></pre>
<p>如果我们运行mvn package，Maven就会执行default生命周期，它会从开始一直运行到package这个phase为止：</p>
<pre><code>validate
...
package
</code></pre>
<p>如果我们运行mvn compile，Maven也会执行default生命周期，但这次它只会运行到compile，即以下几个phase：</p>
<pre><code>validate
...
compile
</code></pre>
<p>Maven另一个常用的生命周期是clean，它会执行3个phase：</p>
<pre><code>pre-clean
clean （注意这个clean不是lifecycle而是phase）
post-clean
</code></pre>
<p>所以，我们使用mvn这个命令时，后面的参数是phase，Maven自动根据生命周期运行到指定的phase。</p>
<p>更复杂的例子是指定多个phase，例如，运行mvn clean package，Maven先执行clean生命周期并运行到clean这个phase，然后执行default生命周期并运行到package这个phase，实际执行的phase如下：</p>
<pre><code>pre-clean
clean （注意这个clean是phase）
validate
...
package
</code></pre>
<p>在实际开发过程中，经常使用的命令有：</p>
<pre><code>mvn clean：清理所有生成的class和jar；

mvn clean compile：先清理，再执行到compile；

mvn clean test：先清理，再执行到test，因为执行test前必须执行compile，所以这里不必指定compile；

mvn clean package：先清理，再执行到package。
</code></pre><p>大多数phase在执行过程中，因为我们通常没有在pom.xml中配置相关的设置，所以这些phase什么事情都不做。</p>
<p>经常用到的phase其实只有几个：</p>
<pre><code>clean：清理
compile：编译
test：运行测试
package：打包
</code></pre>
<h3 id="goal">Goal</h3>
<p>执行一个phase又会触发一个或多个goal：
| 执行的Phase | 对应执行的Goal                        |
| :&mdash;&mdash;&mdash;- | :&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; |
| compile     | compiler:compile                      |
| test        | compoler:testCompile<!-- raw HTML omitted -->surefile:test |</p>
<p>goal的命名总是abc:xyz这种形式。</p>
<p>看到这里，相信大家对lifecycle、phase和goal已经明白了吧？</p>
<!-- raw HTML omitted -->
<p>其实我们类比一下就明白了：</p>
<pre><code>lifecycle相当于Java的package，它包含一个或多个phase；

phase相当于Java的class，它包含一个或多个goal；

goal相当于class的method，它其实才是真正干活的。
</code></pre>
<p>大多数情况，我们只要指定phase，就默认执行这些phase默认绑定的goal，只有少数情况，我们可以直接指定运行一个goal，例如，启动Tomcat服务器：</p>
<pre><code>mvn tomcat:run
</code></pre><h3 id="小结-42">小结</h3>
<p>Maven通过lifecycle、phase和goal来提供标准的构建流程。</p>
<p>最常用的构建命令是指定phase，然后让Maven执行到指定的phase：</p>
<pre><code>mvn clean
mvn clean compile
mvn clean test
mvn clean package
</code></pre>
<p>通常情况，我们总是执行phase默认绑定的goal，因此不必指定goal。</p>
<hr>
<h2 id="164-使用插件">16.4 使用插件</h2>
<p>我们在前面介绍了Maven的lifecycle，phase和goal：使用Maven构建项目就是执行lifecycle，执行到指定的phase为止。每个phase会执行自己默认的一个或多个goal。goal是最小任务单元。</p>
<p>我们以compile这个phase为例，如果执行：</p>
<pre><code>mvn compile
</code></pre><p>Maven将执行compile这个phase，这个phase会调用compiler插件执行关联的compiler:compile这个goal。</p>
<p>实际上，执行每个phase，都是通过某个插件（plugin）来执行的，Maven本身其实并不知道如何执行compile，它只是负责找到对应的compiler插件，然后执行默认的compiler:compile这个goal来完成编译。</p>
<p>所以，使用Maven，实际上就是配置好需要使用的插件，然后通过phase调用它们。</p>
<p>Maven已经内置了一些常用的标准插件：
| 插件名称 | 对应执行的phase |
| :&mdash;&mdash;- | :&mdash;&mdash;&mdash;&mdash;&ndash; |
| clean    | clean           |
| compiler | compile         |
| surefire | test            |
| jar      | package         |</p>
<p>如果标准插件无法满足需求，我们还可以使用自定义插件。使用自定义插件的时候，需要声明。例如，使用maven-shade-plugin可以创建一个可执行的jar，要使用这个插件，需要在pom.xml中声明它：</p>
<pre><code>&lt;project&gt;
    ...
	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
				&lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.2.1&lt;/version&gt;
				&lt;executions&gt;
					&lt;execution&gt;
						&lt;phase&gt;package&lt;/phase&gt;
						&lt;goals&gt;
							&lt;goal&gt;shade&lt;/goal&gt;
						&lt;/goals&gt;
						&lt;configuration&gt;
                            ...
						&lt;/configuration&gt;
					&lt;/execution&gt;
				&lt;/executions&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;
&lt;/project&gt;
</code></pre><p>自定义插件往往需要一些配置，例如，maven-shade-plugin需要指定Java程序的入口，它的配置是：</p>
<pre><code>&lt;configuration&gt;
    &lt;transformers&gt;
        &lt;transformer implementation=&quot;org.apache.maven.plugins.shade.resource.ManifestResourceTransformer&quot;&gt;
            &lt;mainClass&gt;com.itranswarp.learnjava.Main&lt;/mainClass&gt;
        &lt;/transformer&gt;
    &lt;/transformers&gt;
&lt;/configuration&gt;
</code></pre><p>注意，Maven自带的标准插件例如compiler是无需声明的，只有引入其它的插件才需要声明。</p>
<p>下面列举了一些常用的插件：</p>
<pre><code>maven-shade-plugin：打包所有依赖包并生成可执行jar；
cobertura-maven-plugin：生成单元测试覆盖率报告；
findbugs-maven-plugin：对Java源码进行静态分析以找出潜在问题。
</code></pre>
<h3 id="小结-43">小结</h3>
<p>Maven通过自定义插件可以执行项目构建时需要的额外功能，使用自定义插件必须在pom.xml中声明插件及配置；</p>
<p>插件会在某个phase被执行时执行；</p>
<p>插件的配置和用法需参考插件的官方文档。</p>
<hr>
<h2 id="165-模块管理">16.5 模块管理</h2>
<p>在软件开发中，把一个大项目分拆为多个模块是降低软件复杂度的有效方法：</p>
<pre><code>                        ┌ ─ ─ ─ ─ ─ ─ ┐
                          ┌─────────┐
                        │ │Module A │ │
                          └─────────┘
┌──────────────┐ split  │ ┌─────────┐ │
│Single Project│───────&gt;  │Module B │
└──────────────┘        │ └─────────┘ │
                          ┌─────────┐
                        │ │Module C │ │
                          └─────────┘
                        └ ─ ─ ─ ─ ─ ─ ┘
</code></pre><p>对于Maven工程来说，原来是一个大项目：</p>
<pre><code>single-project
├── pom.xml
└── src
</code></pre><p>现在可以分拆成3个模块：</p>
<pre><code>mutiple-project
├── module-a
│   ├── pom.xml
│   └── src
├── module-b
│   ├── pom.xml
│   └── src
└── module-c
    ├── pom.xml
    └── src
</code></pre><p>Maven可以有效地管理多个模块，我们只需要把每个模块当作一个独立的Maven项目，它们有各自独立的pom.xml。例如，模块A的pom.xml：</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;module-a&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;module-a&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>模块B的pom.xml：</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;module-b&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;

    &lt;name&gt;module-b&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>可以看出来，模块A和模块B的pom.xml高度相似，因此，我们可以提取出共同部分作为parent：</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;parent&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;

    &lt;name&gt;parent&lt;/name&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;
        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;
        &lt;java.version&gt;11&lt;/java.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;
            &lt;version&gt;1.7.28&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.3&lt;/version&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;
            &lt;artifactId&gt;junit-jupiter-engine&lt;/artifactId&gt;
            &lt;version&gt;5.5.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre><p>注意到parent的<!-- raw HTML omitted -->是pom而不是jar，因为parent本身不含任何Java代码。编写parent的pom.xml只是为了在各个模块中减少重复的配置。现在我们的整个工程结构如下：</p>
<pre><code>multiple-project
├── pom.xml
├── parent
│   └── pom.xml
├── module-a
│   ├── pom.xml
│   └── src
├── module-b
│   ├── pom.xml
│   └── src
└── module-c
    ├── pom.xml
    └── src
</code></pre><p>这样模块A就可以简化为：</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;parent&gt;
        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
        &lt;artifactId&gt;parent&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
        &lt;relativePath&gt;../parent/pom.xml&lt;/relativePath&gt;
    &lt;/parent&gt;

    &lt;artifactId&gt;parent&lt;/artifactId&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;name&gt;module-a&lt;/name&gt;
&lt;/project&gt;
</code></pre><p>模块B、模块C都可以直接从parent继承，大幅简化了pom.xml的编写。</p>
<p>如果模块A依赖模块B，则模块A需要模块B的jar包才能正常编译，我们需要在模块A中引入模块B：</p>
<pre><code>...
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
        &lt;artifactId&gt;module-b&lt;/artifactId&gt;
        &lt;version&gt;1.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre><p>最后，在编译的时候，需要在根目录创建一个pom.xml统一编译：</p>
<pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;

    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;groupId&gt;com.itranswarp.learnjava&lt;/groupId&gt;
    &lt;artifactId&gt;build&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;name&gt;build&lt;/name&gt;

    &lt;modules&gt;
        &lt;module&gt;parent&lt;/module&gt;
        &lt;module&gt;module-a&lt;/module&gt;
        &lt;module&gt;module-b&lt;/module&gt;
        &lt;module&gt;module-c&lt;/module&gt;
    &lt;/modules&gt;
&lt;/project&gt;
</code></pre><p>这样，在根目录执行mvn clean package时，Maven根据根目录的pom.xml找到包括parent在内的共4个<!-- raw HTML omitted -->，一次性全部编译。</p>
<h3 id="中央仓库">中央仓库</h3>
<p>其实我们使用的大多数第三方模块都是这个用法，例如，我们使用commons logging、log4j这些第三方模块， 就是第三方模块的开发者自己把编译好的jar包发布到Maven的中央仓库中。</p>
<h3 id="私有仓库">私有仓库</h3>
<p>私有仓库是指公司内部如果不希望把源码和jar包放到公网上，那么可以搭建私有仓库。私有仓库总是在公司内部使用，它只需要在本地的~/.m2/settings.xml中配置好，使用方式和中央仓位没有任何区别。</p>
<h3 id="本地仓库">本地仓库</h3>
<p>本地仓库是指把本地开发的项目“发布”在本地，这样其他项目可以通过本地仓库引用它。但是我们不推荐把自己的模块安装到Maven的本地仓库，因为每次修改某个模块的源码，都需要重新安装，非常容易出现版本不一致的情况。更好的方法是使用模块化编译，在编译的时候，告诉Maven几个模块之间存在依赖关系，需要一块编译，Maven就会自动按依赖顺序编译这些模块。</p>
<h3 id="小结-44">小结</h3>
<p>Maven支持模块化管理，可以把一个大项目拆成几个模块：</p>
<ul>
<li>可以通过继承在parent的pom.xml统一定义重复配置；</li>
<li>可以通过<!-- raw HTML omitted -->编译多个模块。</li>
</ul>
<hr>
<h2 id="166-使用mvnw">16.6 使用mvnw</h2>
<p>我们使用Maven时，基本上只会用到mvn这一个命令。有些童鞋可能听说过mvnw，这个是啥？</p>
<p>mvnw是Maven Wrapper的缩写。因为我们安装Maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。</p>
<p>简单地说，Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。</p>
<h3 id="安装maven-wrapper">安装Maven Wrapper</h3>
<p>安装Maven Wrapper最简单的方式是在项目的根目录（即pom.xml所在的目录）下运行安装命令：</p>
<pre><code>mvn -N io.takari:maven:0.7.6:wrapper
</code></pre>
<p>它会自动使用最新版本的Maven。注意0.7.6是Maven Wrapper的版本。最新的Maven Wrapper版本可以去官方网站查看。</p>
<p>如果要指定使用的Maven版本，使用下面的安装命令指定版本，例如3.3.3：</p>
<pre><code>mvn -N io.takari:maven:0.7.6:wrapper -Dmaven=3.3.3
</code></pre>
<p>安装后，查看项目结构：</p>
<pre><code>my-project
├── .mvn
│   └── wrapper
│       ├── MavenWrapperDownloader.java
│       ├── maven-wrapper.jar
│       └── maven-wrapper.properties
├── mvnw
├── mvnw.cmd
├── pom.xml
└── src
    ├── main
    │   ├── java
    │   └── resources
    └── test
        ├── java
        └── resources
</code></pre><p>发现多了mvnw、mvnw.cmd和.mvn目录，我们只需要把mvn命令改成mvnw就可以使用跟项目关联的Maven。例如：</p>
<pre><code>mvnw clean package
</code></pre>
<p>在Linux或macOS下运行时需要加上./：</p>
<pre><code>./mvnw clean package
</code></pre>
<p>Maven Wrapper的另一个作用是把项目的mvnw、mvnw.cmd和.mvn提交到版本库中，可以使所有开发人员使用统一的Maven版本。</p>
<h3 id="小结-45">小结</h3>
<p>使用Maven Wrapper，可以为一个项目指定特定的Maven版本。</p>
<hr>
<h1 id="第17章-设计模式">第17章 设计模式</h1>
<p>设计模式，即Design Patterns，是指在软件设计中，被反复使用的一种代码设计经验。使用设计模式的目的是为了可重用代码，提高代码的可扩展性和可维护性。</p>
<p>设计模式这个术语是上个世纪90年代由Erich Gamma、Richard Helm、Raplh Johnson和Jonhn Vlissides四个人总结提炼出来的，并且写了一本Design Patterns的书。这四人也被称为四人帮（GoF）。</p>
<p>为什么要使用设计模式？根本原因还是软件开发要实现可维护、可扩展，就必须尽量复用代码，并且降低代码的耦合度。设计模式主要是基于OOP编程提炼的，它基于以下几个原则：</p>
<p>1、开闭原则（Open Close Principle）</p>
<p>由Bertrand Meyer提出的开闭原则（Open Closed Principle）是指，软件应该对扩展开放，而对修改关闭。这里的意思是在增加新功能的时候，能不改代码就尽量不要改，如果只增加代码就完成了新功能，那是最好的。</p>
<p>2、里氏代换原则（Liskov Substitution Principle）</p>
<p>里氏替换原则是Barbara Liskov提出的，这是一种面向对象的设计原则，即如果我们调用一个父类的方法可以成功，那么替换成子类调用也应该完全可以运行。</p>
<p>3、依赖倒转原则（Dependence Inversion Principle）</p>
<p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p>
<p>4、接口隔离原则（Interface Segregation Principle）</p>
<p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p>
<p>5、迪米特法则（最少知道原则）（Demeter Principle）</p>
<p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p>
<p>6、合成复用原则（Composite Reuse Principle）</p>
<p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p>
<p>设计模式把一些常用的设计思想提炼出一个个模式，然后给每个模式命名，这样在使用的时候更方便交流。GoF把23个常用模式分为创建型模式、结构型模式和行为型模式三类，我们后续会一一讲解。</p>
<p>学习设计模式，关键是学习设计思想，不能简单地生搬硬套，也不能为了使用设计模式而过度设计，要合理平衡设计的复杂度和灵活性，并意识到设计模式也并不是万能的。</p>
<!-- raw HTML omitted -->
<h2 id="171-创建型模式">17.1 创建型模式</h2>
<p>创建型模式关注点是如何创建对象，其核心思想是要把对象的创建和使用相分离，这样使得两者能相对独立地变换。</p>
<p>创建型模式包括：</p>
<ul>
<li>工厂方法：Factory Method</li>
<li>抽象工厂：Abstract Factory</li>
<li>建造者：Builder</li>
<li>原型：Prototype</li>
<li>单例：Singleton</li>
</ul>
<hr>
<h3 id="1711-工厂方法">17.1.1 工厂方法</h3>
<pre><code>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
</code></pre>
<p>工厂方法即Factory Method，是一种对象创建型模式。</p>
<p>工厂方法的目的是使得创建对象和使用对象是分离的，并且客户端总是引用抽象工厂和抽象产品：</p>
<pre><code>┌─────────────┐      ┌─────────────┐
│   Product   │      │   Factory   │
└─────────────┘      └─────────────┘
       ▲                    ▲
       │                    │
┌─────────────┐      ┌─────────────┐
│ ProductImpl │&lt;─ ─ ─│ FactoryImpl │
└─────────────┘      └─────────────┘
</code></pre><hr>
<h3 id="1712-抽象工厂">17.1.2 抽象工厂</h3>
<pre><code>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
</code></pre>
<p>抽象工厂模式（Abstract Factory）是一个比较复杂的创建型模式。</p>
<p>抽象工厂模式和工厂方法不太一样，它要解决的问题比较复杂，不但工厂是抽象的，产品是抽象的，而且有多个产品需要创建，因此，这个抽象工厂会对应到多个实际工厂，每个实际工厂负责创建多个实际产品：</p>
<pre><code>                                ┌────────┐
                             ─ &gt;│ProductA│
┌────────┐    ┌─────────┐   │   └────────┘
│ Client │─ ─&gt;│ Factory │─ ─
└────────┘    └─────────┘   │   ┌────────┐
                   ▲         ─ &gt;│ProductB│
           ┌───────┴───────┐    └────────┘
           │               │
      ┌─────────┐     ┌─────────┐
      │Factory1 │     │Factory2 │
      └─────────┘     └─────────┘
           │   ┌─────────┐ │   ┌─────────┐
            ─ &gt;│ProductA1│  ─ &gt;│ProductA2│
           │   └─────────┘ │   └─────────┘
               ┌─────────┐     ┌─────────┐
           └ ─&gt;│ProductB1│ └ ─&gt;│ProductB2│
               └─────────┘     └─────────┘
</code></pre><p>这种模式有点类似于多个供应商负责提供一系列类型的产品。</p>
<hr>
<h3 id="1713-生成器">17.1.3 生成器</h3>
<pre><code>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
</code></pre>
<p>生成器模式（Builder）是使用多个“小型”工厂来最终创建出一个完整对象。</p>
<p>当我们使用Builder的时候，一般来说，是因为创建这个对象的步骤比较多，每个步骤都需要一个零部件，最终组合成一个完整的对象。</p>
<hr>
<h3 id="1714-原型">17.1.4 原型</h3>
<pre><code>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
</code></pre>
<p>原型模式，即Prototype，是指创建新对象的时候，根据现有的一个原型来创建。</p>
<hr>
<h3 id="1715-单例">17.1.5 单例</h3>
<pre><code>保证一个类仅有一个实例，并提供一个访问它的全局访问点。
</code></pre>
<p>单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。</p>
<hr>
<h2 id="172-结构型模式">17.2 结构型模式</h2>
<p>结构型模式主要涉及如何组合各种对象以便获得更好、更灵活的结构。虽然面向对象的继承机制提供了最基本的子类扩展父类的功能，但结构型模式不仅仅简单地使用继承，而更多地通过组合与运行期的动态组合来实现更灵活的功能。</p>
<p>结构型模式有：</p>
<ul>
<li>适配器</li>
<li>桥接</li>
<li>组合</li>
<li>装饰器</li>
<li>外观</li>
<li>享元</li>
<li>代理</li>
</ul>
<hr>
<h2 id="173-行为型模式">17.3 行为型模式</h2>
<p>行为型模式主要涉及算法和对象间的职责分配。通过使用对象组合，行为型模式可以描述一组对象应该如何协作来完成一个整体任务。</p>
<p>行为型模式有：</p>
<ul>
<li>责任链</li>
<li>命令</li>
<li>解释器</li>
<li>迭代器</li>
<li>中介</li>
<li>备忘录</li>
<li>观察者</li>
<li>状态</li>
<li>策略</li>
<li>模板方法</li>
<li>访问者</li>
</ul>
<hr>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
