<!doctype html>
<html lang="en-us">
  <head>
    <title>Spring Framework的AOP编程 // Daniel1n</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.69.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Daniel1n" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://daniel1n.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring Framework的AOP编程"/>
<meta name="twitter:description" content="第一章 AOP 的相关概念  1.1 AOP 概述  1.1.1 什么是 AOP 1.1.2 AOP 的作用及优势 1.1.3 AOP 的实现方式     第二章 动态代理  2.1 动态代理的特点 2.2 动态代理常用的有两种方式 2.3 使用 JDK 官方的 Proxy 类创建代理对象 2.4 使用 CGLib 的 Enhancer 类创建代理对象   第三章 Spring 中的 AOP  3.1 Spring 中 AOP 的细节  3.1.1 AOP 相关术语 3.1.2 spring 中的 AOP 的执行过程   3.2 基于 XML 的 AOP 配置  3."/>

    <meta property="og:title" content="Spring Framework的AOP编程" />
<meta property="og:description" content="第一章 AOP 的相关概念  1.1 AOP 概述  1.1.1 什么是 AOP 1.1.2 AOP 的作用及优势 1.1.3 AOP 的实现方式     第二章 动态代理  2.1 动态代理的特点 2.2 动态代理常用的有两种方式 2.3 使用 JDK 官方的 Proxy 类创建代理对象 2.4 使用 CGLib 的 Enhancer 类创建代理对象   第三章 Spring 中的 AOP  3.1 Spring 中 AOP 的细节  3.1.1 AOP 相关术语 3.1.2 spring 中的 AOP 的执行过程   3.2 基于 XML 的 AOP 配置  3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://daniel1n.github.io/post/5.springblog3/" />
<meta property="article:published_time" content="2020-05-07T17:29:57+08:00" />
<meta property="article:modified_time" content="2020-05-07T17:29:57+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://daniel1n.github.io/"><img class="app-header-avatar" src="/qq1.jpg" alt="Daniel1n" /></a>
      <h1>Daniel1n</h1>
      <p>热爱生活，向往自由，脚踏实地，仰望星空。</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/daniel1n" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/daniel1n" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <title>twitter</title>
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Spring Framework的AOP编程</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          May 7, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          7 min read
        </div></div>
    </header>
    <div class="post-content">
      <!-- raw HTML omitted -->
<ul>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-aop-%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5">第一章 AOP 的相关概念</a>
<ul>
<li><a href="#11-aop-%E6%A6%82%E8%BF%B0">1.1 AOP 概述</a>
<ul>
<li><a href="#111-%E4%BB%80%E4%B9%88%E6%98%AF-aop">1.1.1 什么是 AOP</a></li>
<li><a href="#112-aop-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E4%BC%98%E5%8A%BF">1.1.2 AOP 的作用及优势</a></li>
<li><a href="#113-aop-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">1.1.3 AOP 的实现方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86">第二章 动态代理</a>
<ul>
<li><a href="#21-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E7%89%B9%E7%82%B9">2.1 动态代理的特点</a></li>
<li><a href="#22-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%B8%B8%E7%94%A8%E7%9A%84%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">2.2 动态代理常用的有两种方式</a></li>
<li><a href="#23-%E4%BD%BF%E7%94%A8-jdk-%E5%AE%98%E6%96%B9%E7%9A%84-proxy-%E7%B1%BB%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">2.3 使用 JDK 官方的 Proxy 类创建代理对象</a></li>
<li><a href="#24-%E4%BD%BF%E7%94%A8-cglib-%E7%9A%84-enhancer-%E7%B1%BB%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1">2.4 使用 CGLib 的 Enhancer 类创建代理对象</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0--spring-%E4%B8%AD%E7%9A%84-aop">第三章  Spring 中的 AOP</a>
<ul>
<li><a href="#31-spring-%E4%B8%AD-aop-%E7%9A%84%E7%BB%86%E8%8A%82">3.1 Spring 中 AOP 的细节</a>
<ul>
<li><a href="#311-aop-%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD">3.1.1 AOP 相关术语</a></li>
<li><a href="#312-spring-%E4%B8%AD%E7%9A%84-aop-%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B">3.1.2 spring 中的 AOP 的执行过程</a></li>
</ul>
</li>
<li><a href="#32-%E5%9F%BA%E4%BA%8E-xml-%E7%9A%84-aop-%E9%85%8D%E7%BD%AE">3.2 基于 XML 的 AOP 配置</a>
<ul>
<li><a href="#321-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">3.2.1 环境搭建</a></li>
<li><a href="#322-%E5%88%9B%E5%BB%BA-spring-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B9%B6%E5%AF%BC%E5%85%A5%E7%BA%A6%E6%9D%9F">3.2.2 创建 spring 的配置文件并导入约束</a></li>
<li><a href="#323-%E9%85%8D%E7%BD%AEspring%E7%9A%84ioc">3.2.3 配置spring的ioc</a></li>
</ul>
</li>
<li><a href="#32-%E9%9C%80%E8%A6%81%E6%B5%8B%E8%AF%95%E7%9A%84%E4%BB%A3%E7%A0%81">3.2 需要测试的代码</a></li>
<li><a href="#33-%E5%9B%9B%E7%A7%8D%E5%B8%B8%E7%94%A8advance%E7%B1%BB%E5%9E%8B">3.3 四种常用advance类型</a></li>
<li><a href="#34-%E7%8E%AF%E7%BB%95%E9%80%9A%E7%9F%A5advance%E7%9A%84%E7%94%A8%E6%B3%95">3.4 环绕通知advance的用法</a></li>
<li><a href="#35-spring%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84aop%E9%85%8D%E7%BD%AE">3.5 spring基于注解的AOP配置</a></li>
<li><a href="#36-%E4%B8%8D%E4%BD%BF%E7%94%A8-xml-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F">3.6 不使用 XML 的配置方式</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="第一章-aop-的相关概念">第一章 AOP 的相关概念</h1>
<h2 id="11-aop-概述">1.1 AOP 概述</h2>
<h3 id="111-什么是-aop">1.1.1 什么是 AOP</h3>
<p>百度百科：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</p>
<p>AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。</p>
<p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<pre><code>AOP：全称是 Aspect Oriented Programming 即：面向切面编程。

简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，
使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。
</code></pre>
<h3 id="112-aop-的作用及优势">1.1.2 AOP 的作用及优势</h3>
<pre><code>作用：
    在程序运行期间，不修改源码对已有方法进行增强。
优势：
    减少重复代码
    提高开发效率
    维护方便
</code></pre>
<h3 id="113-aop-的实现方式">1.1.3 AOP 的实现方式</h3>
<pre><code>使用动态代理技术
</code></pre>
<hr>
<h1 id="第二章-动态代理">第二章 动态代理</h1>
<h2 id="21-动态代理的特点">2.1 动态代理的特点</h2>
<pre><code>字节码随用随创建，随用随加载。
它与静态代理的区别也在于此。因为静态代理是字节码一上来就创建好，并完成加载。
装饰者模式就是静态代理的一种体现
</code></pre>
<h2 id="22-动态代理常用的有两种方式">2.2 动态代理常用的有两种方式</h2>
<pre><code>基于接口的动态代理
    提供者：JDK 官方的 Proxy 类。
    要求：被代理类最少实现一个接口。

基于子类的动态代理
    提供者：第三方的 CGLib，如果报 asmxxxx 异常，需要导入 asm.jar。
    要求：被代理类不能用 final 修饰的类（最终类）。
</code></pre>
<h2 id="23-使用-jdk-官方的-proxy-类创建代理对象">2.3 使用 JDK 官方的 Proxy 类创建代理对象</h2>
<pre><code>此处我们使用的是一个演员的例子：
在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。
而随着时间的推移，产生了一个新兴职业：经纪人（中间人），
这个时候剧组再想找演员就需要通过经纪人来找了。
下面我们就用代码演示出来。
</code></pre>
<pre><code>/**
 * 一个经纪公司的要求:
 *    能做基本的表演和危险的表演
 * @author qq_lin
 */
public interface IAcotr {
    /**
     * 基本演出
     * @param money
     */
    void basicAct(float money);

    /**
     * 危险演出
     * @param money
     */
    void dangerAct(float money);
}
</code></pre><pre><code>/**
 * 一个演员
 * @author qq_lin
 */
public class Actor implements IAcotr {
    @Override
    public void basicAct(float money) {
        System.out.println(&quot;拿到钱，开始基本的表演：&quot;+money);
    }

    @Override
    public void dangerAct(float money) {
        System.out.println(&quot;拿到钱，开始危险的表演：&quot;+money);
    }
}
</code></pre><pre><code>import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * 一个剧组
 *
 * @author qq_lin
 */
public class Client {
    public static void main(String[] args) {
        // 一个剧组找演员：
        final Actor actor = new Actor(); // 直接找

        /**
         * 代理：
         * 间接。
         * 获取代理对象：
         * 要求：
         * 被代理类最少实现一个接口
         * 创建的方式
         * Proxy.newProxyInstance(三个参数)
         * 参数含义：
         * ClassLoader：和被代理对象使用相同的类加载器。
         * Interfaces：和被代理对象具有相同的行为。实现相同的接口。
         * InvocationHandler：如何代理。
         * 策略模式：使用场景是：
         * 数据有了，目的明确。
         * 如何达成目标，就是策略。
         *
         */
        IAcotr proxyActor = (IAcotr)Proxy.newProxyInstance(
                actor.getClass().getClassLoader(),
                actor.getClass().getInterfaces(),
                new InvocationHandler() {

                    /**
                     * 执行被代理对象的任何方法，都会经过该方法。
                     * 此方法有拦截的功能。
                     *
                     * 参数：
                     * proxy：代理对象的引用。不一定每次都用得到
                     * method：当前执行的方法对象
                     * args：执行方法所需的参数
                     * 返回值：
                     * 当前执行方法的返回值
                     */
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        Object returnValue = null;
                        Float money = (Float) args[0];

                        // 每个经纪公司对不同演出收费不一样，此处开始判断
                        if (&quot;basicAct&quot;.equals(method.getName())) {
                            // 基本远程，没有2000不演
                            if (money &gt; 2000) {
                                // 看上去剧组是给了8000，实际演员到手只有4000
                                // 这就是我们没有修改原来basicAct方法的源码，对方法进行增强
                                returnValue = method.invoke(actor, money / 2);
                            }
                        }

                        if (&quot;dangerAct&quot;.equals(method.getName())) {
                            // 危险演出，没有5000不演
                            if (money &gt; 5000) {
                                //看上去剧组是给了 50000，实际到演员手里只有 25000
                                // 这就是我们没有修改原来 dangerAct 方法源码，对方法进行了增强
                                returnValue = method.invoke(actor, money / 2);
                            }
                        }

                        return returnValue;
                    }
                }
        );

        //没有经纪公司的时候，直接找演员。
        actor.basicAct(1000f);
        actor.dangerAct(5000f);
        
        //剧组无法直接联系演员，而是由经纪公司找的演员
        proxyActor.basicAct(8000f);
        proxyActor.dangerAct(50000f);
    }
}
</code></pre><h2 id="24-使用-cglib-的-enhancer-类创建代理对象">2.4 使用 CGLib 的 Enhancer 类创建代理对象</h2>
<pre><code>/**
 * 一个演员
 * @author qq_lin
 */
public class Actor  { //没有实现任何接口
    @Override
    public void basicAct(float money) {
        System.out.println(&quot;拿到钱，开始基本的表演：&quot;+money);
    }

    @Override
    public void dangerAct(float money) {
        System.out.println(&quot;拿到钱，开始危险的表演：&quot;+money);
    }
}
</code></pre><pre><code>import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

/**
 * 一个剧组
 *
 * @author qq_lin
 */
public class Client {
    /**
     * 基于子类的动态代理
     * 要求：
     * 被代理对象不能是最终类
     * 用到的类：
     * Enhancer
     * 用到的方法：
     * create(Class, Callback)
     * 方法的参数：
     * Class：被代理对象的字节码
     * Callback：如何代理
     *
     * @param args
     */
    public static void main(String[] args) {

        final Actor actor = new Actor(); // 直接找


        Actor cglibActor = (Actor) Enhancer.create(actor.getClass(),
                new MethodInterceptor() {

                    /**
                     * 执行被代理对象的任何方法，都会经过该方法。
                     * 在此方法内部就可以对被代理对象的任何方法进行增强。
                     * &lt;p&gt;
                     * 参数：
                     * 前三个和基于接口的动态代理是一样的。
                     *
                     * @param proxy
                     * @param method
                     * @param args
                     * @param methodProxy MethodProxy：当前执行方法的代理对象。
                     * @return
                     * @throws Throwable
                     */
                    @Override
                    public Object intercept(Object proxy, Method method, 
                        Object[] args, MethodProxy methodProxy) throws Throwable {

                        String name = method.getName();
                        Float money = (Float) args[0];
                        Object returnValue = null;
                        if (&quot;basicAct&quot;.equals(name)) {
                            //基本演出
                            if (money &gt; 2000) {
                                returnValue = method.invoke(actor, money / 2);
                            }
                        }

                        if (&quot;dangerAct&quot;.equals(name)) {
                            //危险演出
                            if (money &gt; 5000) {
                                returnValue = method.invoke(actor, money / 2);
                            }
                        }

                        return returnValue;
                    }
                });


        //没有经纪公司的时候，直接找演员。
        actor.basicAct(1000f);
        actor.dangerAct(5000f);

        //剧组无法直接联系演员，而是由经纪公司找的演员
        cglibActor.basicAct(8000f);
        cglibActor.dangerAct(50000f);
    }
}
</code></pre><hr>
<h1 id="第三章--spring-中的-aop">第三章  Spring 中的 AOP</h1>
<h2 id="31-spring-中-aop-的细节">3.1 Spring 中 AOP 的细节</h2>
<h3 id="311-aop-相关术语">3.1.1 AOP 相关术语</h3>
<pre><code>Joinpoint(连接点):
所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,
因为 spring 只支持方法类型的连接点。

Pointcut(切入点):
所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。

Advice(通知/增强):
    所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。
    通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。

Introduction(引介):
    引介是一种特殊的通知在不修改类代码的前提下, 
    Introduction 可以在运行期为类动态地添加一些方法或 Field。
    
Target(目标对象):
    代理的目标对象。

Weaving(织入):
    是指把增强应用到目标对象来创建新的代理对象的过程。
    spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。

Proxy（代理）:
    一个类被 AOP 织入增强后，就产生一个结果代理类。

Aspect(切面):
    是切入点和通知（引介）的结合。
</code></pre>
<hr>
<h3 id="312-spring-中的-aop-的执行过程">3.1.2 spring 中的 AOP 的执行过程</h3>
<pre><code>a、开发阶段
    编写核心业务代码（开发主线）；
    把公用代码抽取出来，制作成Advice。
    在配置文件中，声明切入点与通知间的关系，即Aspect。

b、运行阶段（Spring 框架完成的）
    Spring 框架监控Pointcut方法的执行。
    一旦监控到Pointcut方法被运行，使用代理机制
    动态创建目标对象的代理对象，根据Advice类别，在代理对象的对应位置，
    将Advice对应的功能织入，完成完整的代码逻辑运行。
</code></pre>
<hr>
<h2 id="32-基于-xml-的-aop-配置">3.2 基于 XML 的 AOP 配置</h2>
<h3 id="321-环境搭建">3.2.1 环境搭建</h3>
<ul>
<li>
<p>导入必要的maven</p>
<pre><code>  &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;
  &lt;/dependency&gt;
  &lt;dependency&gt;
      &lt;groupId&gt;org.aspectj&lt;/groupId&gt;
      &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
      &lt;version&gt;1.9.5&lt;/version&gt;
  &lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>需要的代码</p>
<pre><code>/**
* 账户的业务层接口
* @author qq_lin
*/
public interface IAccountService {
    /**
    * 模拟保存账户
    */
    void saveAccount();

    /**
    * 模拟更新账户
    * @param i
    */
    void updateAccount(int i);

    /**
    * 删除账户
    * @return
    */
    int deleteAccount();
}
</code></pre><pre><code>/**
 * 账户的业务实现层
 * @author qq_lin
 */
public class AccountServiceImpl implements IAccountService {

    @Override
    public void saveAccount() {
        System.out.println(&quot;执行了保存&quot;);

    }

    @Override
    public void updateAccount(int i) {
        System.out.println(&quot;执行了更新&quot; + i);
    }

    @Override
    public int deleteAccount() {
        System.out.println(&quot;执行了删除&quot;);
        return 0;
    }
}
</code></pre><pre><code>/**
 * 用于记录日志的工具类
 */ 
public class  Logger() {

    /**
     * 用于打印日志，计划让其在切入点方法执行之前执行
     * （切入点方法就是业务层方法
     */
    public void printLog() {
        System.out.println(&quot;Logger类中的printLog方法开始记录日志&quot;);
    }  
}
</code></pre></li>
</ul>
<hr>
<h3 id="322-创建-spring-的配置文件并导入约束">3.2.2 创建 spring 的配置文件并导入约束</h3>
<p>在resources中新增一个bean.xml文件</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;

&lt;/beans&gt;
</code></pre>
<h3 id="323-配置spring的ioc">3.2.3 配置spring的ioc</h3>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
        

    &lt;!--配置spring的IOC，把service对象配置进来--&gt;
    &lt;bean id=&quot;accountService&quot; 
        class=&quot;com.qqlin.service.impl.AccountServiceImpl&quot;/&gt;

    &lt;!--spring中基于XML的AOP配置步骤
        1.把通知Bean也交给spring来管理
        2.使用aop:config标签表明开始AOP的配置
        3.使用aop:aspect标签表明配置切面
            id属性：是给切面提供一个唯一标识
            ref属性：是指定通知类bean的ID
        4.在aop:aspect标签的内部使用对应标签来配置通知的类型
            aop:before:表示配置前置通知
                method属性：用于指定Logger类中哪个方法是前置通知
                pointcut属性：指定切入点表达式，该表达式的含义指的是对业务层中哪些方法增强

            切入点表达式的写法：
                关键字：execution(表达式)
                表达式：
                    访问修饰符 返回值 包名.包名..类名.方法名（参数列表）
                标准的表达式写法：
                    public void com.qqlin.service.impl.AccountServiceImpl.saveAccount()  
                访问修饰符、返回值，以及包名、类名、方法名和参数列表皆可省略
                    * com.qqlin.service.impl.*.*(..)  
                以上表达式，是由aspectjweaver解析的
    --&gt;      

    &lt;!--配置Logger类--&gt;
    &lt;bean id=&quot;logger&quot; class=&quot;com.qqlin.utils.Logger/&gt;

    &lt;!--配置AOP--&gt;
    &lt;aop:config&gt;
        &lt;!--配置切面--&gt;
        &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
            &lt;!--配置通知的类型，并建立通知方法的切入点方法的关联--&gt;
            &lt;aop:before method=&quot;printLog&quot;
                pointcut=&quot;excution(* com.qqlin.service.impl.*.*(..))&quot;/&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;    
              
&lt;/beans&gt;
</code></pre>
<hr>
<h2 id="32-需要测试的代码">3.2 需要测试的代码</h2>
<pre><code>public class AOPtest() {
    // 1.获取容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    // 2.获取对象
    IAccountService as = (IAcountService)ac.getBean(&quot;accountService&quot;);
    // 3.执行方法
    as.saveAccount();
    as.updateAccount();
    as.deleteAccount();
}
</code></pre><hr>
<h2 id="33-四种常用advance类型">3.3 四种常用advance类型</h2>
<p>bean.xml文件的准备</p>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/aop 
            http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
            

        &lt;!--配置spring的IOC，把service对象配置进来--&gt;
        &lt;bean id=&quot;accountService&quot; 
            class=&quot;com.qqlin.service.impl.AccountServiceImpl&quot;/&gt;

        &lt;!--配置Logger类--&gt;
        &lt;bean id=&quot;logger&quot; class=&quot;com.qqlin.utils.Logger/&gt;

        &lt;!--配置AOP--&gt;
        &lt;aop:config&gt;
            &lt;!--配置切面--&gt;
            &lt;!--配置切入点表达式 id属性用于指定表达式的唯一标识。
                expression属性用于指定表达式内容
                此标签写在aop:aspect标签内部只能当前切面使用。
                写在aop:aspect标签外面，变成所有切面可用
            --&gt;
            &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;excution(* com.qqlin.service.impl.*.*(..))&quot;/&gt;
            &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
                &lt;!--配置前置通知--&gt;
                &lt;aop:before method=&quot;beforePrintLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

                &lt;!--配置后置通知--&gt;
                &lt;aop:after-returning method=&quot;afterReturningPrintLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

                &lt;!--配置异常通知--&gt;
                &lt;aop:after-throwing method=&quot;afterThrowingPrintLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

                &lt;!--配置最终通知--&gt;
                &lt;aop:after method=&quot;afterPrintLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;
            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;    
                  
    &lt;/beans&gt;
</code></pre><p>改造记录日志的工具代码：</p>
<pre><code>/**
 * 用于记录日志的工具类
 */ 
public class  Logger() {

    /**
    * 前置通知
    */
    public void beforePrintLog() {
        System.out.println(&quot;前置通知&quot;);
        }  
    }

    /**
    * 后置通知
    */
    public void afterReturningPrintLog() {
        System.out.println(&quot;后置通知&quot;);
        }  
    }

    /**
    * 异常置通知
    */
    public void afterThrowingPrintLog() {
        System.out.println(&quot;异常通知&quot;);
        }  
    }

    /**
    * 最终通知
    */
    public void afterPrintLog() {
        System.out.println(&quot;最终通知&quot;);
        }  
    }

}
</code></pre><p>测试代码</p>
<pre><code>public class AOPtest() {
    // 1.获取容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    // 2.获取对象
    IAccountService as = (IAcountService)ac.getBean(&quot;accountService&quot;);
    // 3.执行方法
    as.saveAccount();
    as.updateAccount();
    as.deleteAccount();
}
</code></pre><hr>
<h2 id="34-环绕通知advance的用法">3.4 环绕通知advance的用法</h2>
<p>bean.xml文件的准备</p>
<pre><code>    &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
    &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
        xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans 
            http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/aop 
            http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;
            

        &lt;!--配置spring的IOC，把service对象配置进来--&gt;
        &lt;bean id=&quot;accountService&quot; 
            class=&quot;com.qqlin.service.impl.AccountServiceImpl&quot;/&gt;

        &lt;!--配置Logger类--&gt;
        &lt;bean id=&quot;logger&quot; class=&quot;com.qqlin.utils.Logger/&gt;

        &lt;!--配置AOP--&gt;
        &lt;aop:config&gt;
            &lt;!--配置切面--&gt;
            &lt;!--配置切入点表达式 id属性用于指定表达式的唯一标识。
                expression属性用于指定表达式内容
                此标签写在aop:aspect标签内部只能当前切面使用。
                写在aop:aspect标签外面，变成所有切面可用
            --&gt;
            &lt;aop:pointcut id=&quot;pointcut&quot; expression=&quot;excution(* com.qqlin.service.impl.*.*(..))&quot;/&gt;
            &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;
                &lt;!--配置环绕通知--&gt;
                &lt;aop:around method=&quot;aroundPringLog&quot; pointcut-ref=&quot;pointcut&quot;/&gt;

            &lt;/aop:aspect&gt;
        &lt;/aop:config&gt;    
                  
    &lt;/beans&gt;
</code></pre><p>改造记录日志的工具代码：</p>
<pre><code>/**
 * 用于记录日志的工具类
 */ 
public class  Logger() {

    /**
     * 环绕通知
     */
    public Object aroundPrintLog(ProceedingJoinPoint point) {
        Object returnValue = null;
        try {
            Object[] args = point.getArgs();
            System.out.println(&quot;环绕通知..前置&quot;);
            returnValue = point.proceed(args);
            System.out.println(&quot;环绕通知..后置&quot;);
            return returnValue;
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println(&quot;环绕通知..异常&quot;);
        } finally {
            System.out.println(&quot;环绕通知..最终&quot;);
        }

        return returnValue;
    }

}
</code></pre><p>测试代码</p>
<pre><code>public class AOPtest() {
    // 1.获取容器
    ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);
    // 2.获取对象
    IAccountService as = (IAcountService)ac.getBean(&quot;accountService&quot;);
    // 3.执行方法
    as.saveAccount();
    as.updateAccount();
    as.deleteAccount();
}
</code></pre><hr>
<h2 id="35-spring基于注解的aop配置">3.5 spring基于注解的AOP配置</h2>
<p>配置bean.xml</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!--配置spring创建容器时需要扫描的包--&gt;
    &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;

    &lt;!--配置spring开启注解AOP的支持--&gt;
    &lt;aop:aspectj-autoproxy/&gt;

&lt;/beans&gt;    
</code></pre>
<p>代码改造</p>
<pre><code>/**
 * 账户的业务实现层
 * @author qq_lin
 */
@Service(&quot;accountService&quot;)
public class AccountServiceImpl implements IAccountService {

    @Override
    public void saveAccount() {
        System.out.println(&quot;执行了保存&quot;);

    }

    @Override
    public void updateAccount(int i) {
        System.out.println(&quot;执行了更新&quot; + i);
    }

    @Override
    public int deleteAccount() {
        System.out.println(&quot;执行了删除&quot;);
        return 0;
    }
}
</code></pre><pre><code>/**
 * 用于记录日志的工具类，提供了公共代码
 * @author qq_lin
 */
@Component(&quot;logger&quot;)
@Aspect
public class Logger {

    @Pointcut(&quot;execution(* com.itheima.service.*.*(..))&quot;)
    private void pointcut(){};
    /**
     * 前置通知
     */
    // @Before(&quot;pointcut()&quot;)
    public void beforePrintLog() {
        System.out.println(&quot;前置通知Logger类中的beforePrintLog方法开始记录日志。。。&quot;);
    }

    /**
     * 后置通知
     */
    // @AfterReturning(&quot;pointcut()&quot;)
    public void afterReturningPrintLog() {
        System.out.println(&quot;后置通知Logger类中的afterPrintLog方法开始记录日志。。。&quot;);
    }

    /**
     * 异常通知
     */
    // @AfterThrowing(&quot;pointcut()&quot;)
    public void afterThrowingPrintLog() {
        System.out.println(&quot;异常通知Logger类中的afterThrowingPrintLog方法开始记录日志。。。&quot;);
    }

    /**
     * 最终通知
     */
    // @After(&quot;pointcut()&quot;)
    public void afterPrintLog() {
        System.out.println(&quot;最终通知Logger类中的afterPrintLog方法开始记录日志&quot;);
    }

    @Around(&quot;pointcut()&quot;)
    public Object aroundPrintLog(ProceedingJoinPoint point) {
        Object returnValue = null;
        try {
            Object[] args = point.getArgs();
            System.out.println(&quot;环绕通知Logger类中aroundPrintLog方法开始记录日志..前置&quot;);
            returnValue = point.proceed(args);
            System.out.println(&quot;环绕通知Logger类中aroundPrintLog方法开始记录日志..后置&quot;);
            return returnValue;
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println(&quot;环绕通知Logger类中aroundPrintLog方法开始记录日志..异常&quot;);
        } finally {
            System.out.println(&quot;环绕通知Logger类中aroundPrintLog方法开始记录日志..最终&quot;);
        }


        return returnValue;
    }
}
</code></pre><h2 id="36-不使用-xml-的配置方式">3.6 不使用 XML 的配置方式</h2>
<p>构造一个config的包，类是SpringConfiguration</p>
<pre><code>@Configuration
@ComponentScan(basePackages=&quot;com.qqlin&quot;)
@EnableAspectJAutoProxy
public class SpringConfiguration {
}
</code></pre>
<p>最后，就可以不用使用bean.xml文件，直接用注解了</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
